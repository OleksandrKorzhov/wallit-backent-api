// Code generated by ent, DO NOT EDIT.

package ent

import (
	"context"
	"encoding/base64"
	"errors"
	"fmt"
	"io"
	"strconv"
	"strings"
	"wallit/ent/discountoffer"
	"wallit/ent/merchant"
	"wallit/ent/notification"
	"wallit/ent/plaidinstitution"
	"wallit/ent/plaidinstitutionaccount"
	"wallit/ent/plaiditem"
	"wallit/ent/spendingcategory"
	"wallit/ent/transaction"
	"wallit/ent/transactionsync"
	"wallit/ent/user"
	"wallit/ent/usernotificationchannelpreferences"

	"entgo.io/ent/dialect/sql"
	"github.com/99designs/gqlgen/graphql"
	"github.com/99designs/gqlgen/graphql/errcode"
	"github.com/vektah/gqlparser/v2/gqlerror"
	"github.com/vmihailenco/msgpack/v5"
)

// OrderDirection defines the directions in which to order a list of items.
type OrderDirection string

const (
	// OrderDirectionAsc specifies an ascending order.
	OrderDirectionAsc OrderDirection = "ASC"
	// OrderDirectionDesc specifies a descending order.
	OrderDirectionDesc OrderDirection = "DESC"
)

// Validate the order direction value.
func (o OrderDirection) Validate() error {
	if o != OrderDirectionAsc && o != OrderDirectionDesc {
		return fmt.Errorf("%s is not a valid OrderDirection", o)
	}
	return nil
}

// String implements fmt.Stringer interface.
func (o OrderDirection) String() string {
	return string(o)
}

// MarshalGQL implements graphql.Marshaler interface.
func (o OrderDirection) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(o.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (o *OrderDirection) UnmarshalGQL(val interface{}) error {
	str, ok := val.(string)
	if !ok {
		return fmt.Errorf("order direction %T must be a string", val)
	}
	*o = OrderDirection(str)
	return o.Validate()
}

func (o OrderDirection) reverse() OrderDirection {
	if o == OrderDirectionDesc {
		return OrderDirectionAsc
	}
	return OrderDirectionDesc
}

func (o OrderDirection) orderFunc(field string) OrderFunc {
	if o == OrderDirectionDesc {
		return Desc(field)
	}
	return Asc(field)
}

func cursorsToPredicates(direction OrderDirection, after, before *Cursor, field, idField string) []func(s *sql.Selector) {
	var predicates []func(s *sql.Selector)
	if after != nil {
		if after.Value != nil {
			var predicate func([]string, ...interface{}) *sql.Predicate
			if direction == OrderDirectionAsc {
				predicate = sql.CompositeGT
			} else {
				predicate = sql.CompositeLT
			}
			predicates = append(predicates, func(s *sql.Selector) {
				s.Where(predicate(
					s.Columns(field, idField),
					after.Value, after.ID,
				))
			})
		} else {
			var predicate func(string, interface{}) *sql.Predicate
			if direction == OrderDirectionAsc {
				predicate = sql.GT
			} else {
				predicate = sql.LT
			}
			predicates = append(predicates, func(s *sql.Selector) {
				s.Where(predicate(
					s.C(idField),
					after.ID,
				))
			})
		}
	}
	if before != nil {
		if before.Value != nil {
			var predicate func([]string, ...interface{}) *sql.Predicate
			if direction == OrderDirectionAsc {
				predicate = sql.CompositeLT
			} else {
				predicate = sql.CompositeGT
			}
			predicates = append(predicates, func(s *sql.Selector) {
				s.Where(predicate(
					s.Columns(field, idField),
					before.Value, before.ID,
				))
			})
		} else {
			var predicate func(string, interface{}) *sql.Predicate
			if direction == OrderDirectionAsc {
				predicate = sql.LT
			} else {
				predicate = sql.GT
			}
			predicates = append(predicates, func(s *sql.Selector) {
				s.Where(predicate(
					s.C(idField),
					before.ID,
				))
			})
		}
	}
	return predicates
}

// PageInfo of a connection type.
type PageInfo struct {
	HasNextPage     bool    `json:"hasNextPage"`
	HasPreviousPage bool    `json:"hasPreviousPage"`
	StartCursor     *Cursor `json:"startCursor"`
	EndCursor       *Cursor `json:"endCursor"`
}

// Cursor of an edge type.
type Cursor struct {
	ID    int   `msgpack:"i"`
	Value Value `msgpack:"v,omitempty"`
}

// MarshalGQL implements graphql.Marshaler interface.
func (c Cursor) MarshalGQL(w io.Writer) {
	quote := []byte{'"'}
	w.Write(quote)
	defer w.Write(quote)
	wc := base64.NewEncoder(base64.RawStdEncoding, w)
	defer wc.Close()
	_ = msgpack.NewEncoder(wc).Encode(c)
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (c *Cursor) UnmarshalGQL(v interface{}) error {
	s, ok := v.(string)
	if !ok {
		return fmt.Errorf("%T is not a string", v)
	}
	if err := msgpack.NewDecoder(
		base64.NewDecoder(
			base64.RawStdEncoding,
			strings.NewReader(s),
		),
	).Decode(c); err != nil {
		return fmt.Errorf("cannot decode cursor: %w", err)
	}
	return nil
}

const errInvalidPagination = "INVALID_PAGINATION"

func validateFirstLast(first, last *int) (err *gqlerror.Error) {
	switch {
	case first != nil && last != nil:
		err = &gqlerror.Error{
			Message: "Passing both `first` and `last` to paginate a connection is not supported.",
		}
	case first != nil && *first < 0:
		err = &gqlerror.Error{
			Message: "`first` on a connection cannot be less than zero.",
		}
		errcode.Set(err, errInvalidPagination)
	case last != nil && *last < 0:
		err = &gqlerror.Error{
			Message: "`last` on a connection cannot be less than zero.",
		}
		errcode.Set(err, errInvalidPagination)
	}
	return err
}

func collectedField(ctx context.Context, path ...string) *graphql.CollectedField {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return nil
	}
	field := fc.Field
	oc := graphql.GetOperationContext(ctx)
walk:
	for _, name := range path {
		for _, f := range graphql.CollectFields(oc, field.Selections, nil) {
			if f.Alias == name {
				field = f
				continue walk
			}
		}
		return nil
	}
	return &field
}

func hasCollectedField(ctx context.Context, path ...string) bool {
	if graphql.GetFieldContext(ctx) == nil {
		return true
	}
	return collectedField(ctx, path...) != nil
}

const (
	edgesField      = "edges"
	nodeField       = "node"
	pageInfoField   = "pageInfo"
	totalCountField = "totalCount"
)

func paginateLimit(first, last *int) int {
	var limit int
	if first != nil {
		limit = *first + 1
	} else if last != nil {
		limit = *last + 1
	}
	return limit
}

// DiscountOfferEdge is the edge representation of DiscountOffer.
type DiscountOfferEdge struct {
	Node   *DiscountOffer `json:"node"`
	Cursor Cursor         `json:"cursor"`
}

// DiscountOfferConnection is the connection containing edges to DiscountOffer.
type DiscountOfferConnection struct {
	Edges      []*DiscountOfferEdge `json:"edges"`
	PageInfo   PageInfo             `json:"pageInfo"`
	TotalCount int                  `json:"totalCount"`
}

func (c *DiscountOfferConnection) build(nodes []*DiscountOffer, pager *discountofferPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *DiscountOffer
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *DiscountOffer {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *DiscountOffer {
			return nodes[i]
		}
	}
	c.Edges = make([]*DiscountOfferEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &DiscountOfferEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// DiscountOfferPaginateOption enables pagination customization.
type DiscountOfferPaginateOption func(*discountofferPager) error

// WithDiscountOfferOrder configures pagination ordering.
func WithDiscountOfferOrder(order *DiscountOfferOrder) DiscountOfferPaginateOption {
	if order == nil {
		order = DefaultDiscountOfferOrder
	}
	o := *order
	return func(pager *discountofferPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultDiscountOfferOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithDiscountOfferFilter configures pagination filter.
func WithDiscountOfferFilter(filter func(*DiscountOfferQuery) (*DiscountOfferQuery, error)) DiscountOfferPaginateOption {
	return func(pager *discountofferPager) error {
		if filter == nil {
			return errors.New("DiscountOfferQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type discountofferPager struct {
	order  *DiscountOfferOrder
	filter func(*DiscountOfferQuery) (*DiscountOfferQuery, error)
}

func newDiscountOfferPager(opts []DiscountOfferPaginateOption) (*discountofferPager, error) {
	pager := &discountofferPager{}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultDiscountOfferOrder
	}
	return pager, nil
}

func (p *discountofferPager) applyFilter(query *DiscountOfferQuery) (*DiscountOfferQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *discountofferPager) toCursor(do *DiscountOffer) Cursor {
	return p.order.Field.toCursor(do)
}

func (p *discountofferPager) applyCursors(query *DiscountOfferQuery, after, before *Cursor) *DiscountOfferQuery {
	for _, predicate := range cursorsToPredicates(
		p.order.Direction, after, before,
		p.order.Field.field, DefaultDiscountOfferOrder.Field.field,
	) {
		query = query.Where(predicate)
	}
	return query
}

func (p *discountofferPager) applyOrder(query *DiscountOfferQuery, reverse bool) *DiscountOfferQuery {
	direction := p.order.Direction
	if reverse {
		direction = direction.reverse()
	}
	query = query.Order(direction.orderFunc(p.order.Field.field))
	if p.order.Field != DefaultDiscountOfferOrder.Field {
		query = query.Order(direction.orderFunc(DefaultDiscountOfferOrder.Field.field))
	}
	return query
}

func (p *discountofferPager) orderExpr(reverse bool) sql.Querier {
	direction := p.order.Direction
	if reverse {
		direction = direction.reverse()
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.field).Pad().WriteString(string(direction))
		if p.order.Field != DefaultDiscountOfferOrder.Field {
			b.Comma().Ident(DefaultDiscountOfferOrder.Field.field).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to DiscountOffer.
func (do *DiscountOfferQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...DiscountOfferPaginateOption,
) (*DiscountOfferConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newDiscountOfferPager(opts)
	if err != nil {
		return nil, err
	}
	if do, err = pager.applyFilter(do); err != nil {
		return nil, err
	}
	conn := &DiscountOfferConnection{Edges: []*DiscountOfferEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			if conn.TotalCount, err = do.Clone().Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}

	do = pager.applyCursors(do, after, before)
	do = pager.applyOrder(do, last != nil)
	if limit := paginateLimit(first, last); limit != 0 {
		do.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := do.collectField(ctx, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}

	nodes, err := do.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// DiscountOfferOrderFieldCreatedAt orders DiscountOffer by created_at.
	DiscountOfferOrderFieldCreatedAt = &DiscountOfferOrderField{
		field: discountoffer.FieldCreatedAt,
		toCursor: func(do *DiscountOffer) Cursor {
			return Cursor{
				ID:    do.ID,
				Value: do.CreatedAt,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f DiscountOfferOrderField) String() string {
	var str string
	switch f.field {
	case discountoffer.FieldCreatedAt:
		str = "CREATED_AT"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f DiscountOfferOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *DiscountOfferOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("DiscountOfferOrderField %T must be a string", v)
	}
	switch str {
	case "CREATED_AT":
		*f = *DiscountOfferOrderFieldCreatedAt
	default:
		return fmt.Errorf("%s is not a valid DiscountOfferOrderField", str)
	}
	return nil
}

// DiscountOfferOrderField defines the ordering field of DiscountOffer.
type DiscountOfferOrderField struct {
	field    string
	toCursor func(*DiscountOffer) Cursor
}

// DiscountOfferOrder defines the ordering of DiscountOffer.
type DiscountOfferOrder struct {
	Direction OrderDirection           `json:"direction"`
	Field     *DiscountOfferOrderField `json:"field"`
}

// DefaultDiscountOfferOrder is the default ordering of DiscountOffer.
var DefaultDiscountOfferOrder = &DiscountOfferOrder{
	Direction: OrderDirectionAsc,
	Field: &DiscountOfferOrderField{
		field: discountoffer.FieldID,
		toCursor: func(do *DiscountOffer) Cursor {
			return Cursor{ID: do.ID}
		},
	},
}

// ToEdge converts DiscountOffer into DiscountOfferEdge.
func (do *DiscountOffer) ToEdge(order *DiscountOfferOrder) *DiscountOfferEdge {
	if order == nil {
		order = DefaultDiscountOfferOrder
	}
	return &DiscountOfferEdge{
		Node:   do,
		Cursor: order.Field.toCursor(do),
	}
}

// MerchantEdge is the edge representation of Merchant.
type MerchantEdge struct {
	Node   *Merchant `json:"node"`
	Cursor Cursor    `json:"cursor"`
}

// MerchantConnection is the connection containing edges to Merchant.
type MerchantConnection struct {
	Edges      []*MerchantEdge `json:"edges"`
	PageInfo   PageInfo        `json:"pageInfo"`
	TotalCount int             `json:"totalCount"`
}

func (c *MerchantConnection) build(nodes []*Merchant, pager *merchantPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *Merchant
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *Merchant {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *Merchant {
			return nodes[i]
		}
	}
	c.Edges = make([]*MerchantEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &MerchantEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// MerchantPaginateOption enables pagination customization.
type MerchantPaginateOption func(*merchantPager) error

// WithMerchantOrder configures pagination ordering.
func WithMerchantOrder(order *MerchantOrder) MerchantPaginateOption {
	if order == nil {
		order = DefaultMerchantOrder
	}
	o := *order
	return func(pager *merchantPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultMerchantOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithMerchantFilter configures pagination filter.
func WithMerchantFilter(filter func(*MerchantQuery) (*MerchantQuery, error)) MerchantPaginateOption {
	return func(pager *merchantPager) error {
		if filter == nil {
			return errors.New("MerchantQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type merchantPager struct {
	order  *MerchantOrder
	filter func(*MerchantQuery) (*MerchantQuery, error)
}

func newMerchantPager(opts []MerchantPaginateOption) (*merchantPager, error) {
	pager := &merchantPager{}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultMerchantOrder
	}
	return pager, nil
}

func (p *merchantPager) applyFilter(query *MerchantQuery) (*MerchantQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *merchantPager) toCursor(m *Merchant) Cursor {
	return p.order.Field.toCursor(m)
}

func (p *merchantPager) applyCursors(query *MerchantQuery, after, before *Cursor) *MerchantQuery {
	for _, predicate := range cursorsToPredicates(
		p.order.Direction, after, before,
		p.order.Field.field, DefaultMerchantOrder.Field.field,
	) {
		query = query.Where(predicate)
	}
	return query
}

func (p *merchantPager) applyOrder(query *MerchantQuery, reverse bool) *MerchantQuery {
	direction := p.order.Direction
	if reverse {
		direction = direction.reverse()
	}
	query = query.Order(direction.orderFunc(p.order.Field.field))
	if p.order.Field != DefaultMerchantOrder.Field {
		query = query.Order(direction.orderFunc(DefaultMerchantOrder.Field.field))
	}
	return query
}

func (p *merchantPager) orderExpr(reverse bool) sql.Querier {
	direction := p.order.Direction
	if reverse {
		direction = direction.reverse()
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.field).Pad().WriteString(string(direction))
		if p.order.Field != DefaultMerchantOrder.Field {
			b.Comma().Ident(DefaultMerchantOrder.Field.field).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to Merchant.
func (m *MerchantQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...MerchantPaginateOption,
) (*MerchantConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newMerchantPager(opts)
	if err != nil {
		return nil, err
	}
	if m, err = pager.applyFilter(m); err != nil {
		return nil, err
	}
	conn := &MerchantConnection{Edges: []*MerchantEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			if conn.TotalCount, err = m.Clone().Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}

	m = pager.applyCursors(m, after, before)
	m = pager.applyOrder(m, last != nil)
	if limit := paginateLimit(first, last); limit != 0 {
		m.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := m.collectField(ctx, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}

	nodes, err := m.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

// MerchantOrderField defines the ordering field of Merchant.
type MerchantOrderField struct {
	field    string
	toCursor func(*Merchant) Cursor
}

// MerchantOrder defines the ordering of Merchant.
type MerchantOrder struct {
	Direction OrderDirection      `json:"direction"`
	Field     *MerchantOrderField `json:"field"`
}

// DefaultMerchantOrder is the default ordering of Merchant.
var DefaultMerchantOrder = &MerchantOrder{
	Direction: OrderDirectionAsc,
	Field: &MerchantOrderField{
		field: merchant.FieldID,
		toCursor: func(m *Merchant) Cursor {
			return Cursor{ID: m.ID}
		},
	},
}

// ToEdge converts Merchant into MerchantEdge.
func (m *Merchant) ToEdge(order *MerchantOrder) *MerchantEdge {
	if order == nil {
		order = DefaultMerchantOrder
	}
	return &MerchantEdge{
		Node:   m,
		Cursor: order.Field.toCursor(m),
	}
}

// NotificationEdge is the edge representation of Notification.
type NotificationEdge struct {
	Node   *Notification `json:"node"`
	Cursor Cursor        `json:"cursor"`
}

// NotificationConnection is the connection containing edges to Notification.
type NotificationConnection struct {
	Edges      []*NotificationEdge `json:"edges"`
	PageInfo   PageInfo            `json:"pageInfo"`
	TotalCount int                 `json:"totalCount"`
}

func (c *NotificationConnection) build(nodes []*Notification, pager *notificationPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *Notification
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *Notification {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *Notification {
			return nodes[i]
		}
	}
	c.Edges = make([]*NotificationEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &NotificationEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// NotificationPaginateOption enables pagination customization.
type NotificationPaginateOption func(*notificationPager) error

// WithNotificationOrder configures pagination ordering.
func WithNotificationOrder(order *NotificationOrder) NotificationPaginateOption {
	if order == nil {
		order = DefaultNotificationOrder
	}
	o := *order
	return func(pager *notificationPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultNotificationOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithNotificationFilter configures pagination filter.
func WithNotificationFilter(filter func(*NotificationQuery) (*NotificationQuery, error)) NotificationPaginateOption {
	return func(pager *notificationPager) error {
		if filter == nil {
			return errors.New("NotificationQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type notificationPager struct {
	order  *NotificationOrder
	filter func(*NotificationQuery) (*NotificationQuery, error)
}

func newNotificationPager(opts []NotificationPaginateOption) (*notificationPager, error) {
	pager := &notificationPager{}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultNotificationOrder
	}
	return pager, nil
}

func (p *notificationPager) applyFilter(query *NotificationQuery) (*NotificationQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *notificationPager) toCursor(n *Notification) Cursor {
	return p.order.Field.toCursor(n)
}

func (p *notificationPager) applyCursors(query *NotificationQuery, after, before *Cursor) *NotificationQuery {
	for _, predicate := range cursorsToPredicates(
		p.order.Direction, after, before,
		p.order.Field.field, DefaultNotificationOrder.Field.field,
	) {
		query = query.Where(predicate)
	}
	return query
}

func (p *notificationPager) applyOrder(query *NotificationQuery, reverse bool) *NotificationQuery {
	direction := p.order.Direction
	if reverse {
		direction = direction.reverse()
	}
	query = query.Order(direction.orderFunc(p.order.Field.field))
	if p.order.Field != DefaultNotificationOrder.Field {
		query = query.Order(direction.orderFunc(DefaultNotificationOrder.Field.field))
	}
	return query
}

func (p *notificationPager) orderExpr(reverse bool) sql.Querier {
	direction := p.order.Direction
	if reverse {
		direction = direction.reverse()
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.field).Pad().WriteString(string(direction))
		if p.order.Field != DefaultNotificationOrder.Field {
			b.Comma().Ident(DefaultNotificationOrder.Field.field).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to Notification.
func (n *NotificationQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...NotificationPaginateOption,
) (*NotificationConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newNotificationPager(opts)
	if err != nil {
		return nil, err
	}
	if n, err = pager.applyFilter(n); err != nil {
		return nil, err
	}
	conn := &NotificationConnection{Edges: []*NotificationEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			if conn.TotalCount, err = n.Clone().Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}

	n = pager.applyCursors(n, after, before)
	n = pager.applyOrder(n, last != nil)
	if limit := paginateLimit(first, last); limit != 0 {
		n.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := n.collectField(ctx, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}

	nodes, err := n.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// NotificationOrderFieldCreatedAt orders Notification by created_at.
	NotificationOrderFieldCreatedAt = &NotificationOrderField{
		field: notification.FieldCreatedAt,
		toCursor: func(n *Notification) Cursor {
			return Cursor{
				ID:    n.ID,
				Value: n.CreatedAt,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f NotificationOrderField) String() string {
	var str string
	switch f.field {
	case notification.FieldCreatedAt:
		str = "CREATED_AT"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f NotificationOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *NotificationOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("NotificationOrderField %T must be a string", v)
	}
	switch str {
	case "CREATED_AT":
		*f = *NotificationOrderFieldCreatedAt
	default:
		return fmt.Errorf("%s is not a valid NotificationOrderField", str)
	}
	return nil
}

// NotificationOrderField defines the ordering field of Notification.
type NotificationOrderField struct {
	field    string
	toCursor func(*Notification) Cursor
}

// NotificationOrder defines the ordering of Notification.
type NotificationOrder struct {
	Direction OrderDirection          `json:"direction"`
	Field     *NotificationOrderField `json:"field"`
}

// DefaultNotificationOrder is the default ordering of Notification.
var DefaultNotificationOrder = &NotificationOrder{
	Direction: OrderDirectionAsc,
	Field: &NotificationOrderField{
		field: notification.FieldID,
		toCursor: func(n *Notification) Cursor {
			return Cursor{ID: n.ID}
		},
	},
}

// ToEdge converts Notification into NotificationEdge.
func (n *Notification) ToEdge(order *NotificationOrder) *NotificationEdge {
	if order == nil {
		order = DefaultNotificationOrder
	}
	return &NotificationEdge{
		Node:   n,
		Cursor: order.Field.toCursor(n),
	}
}

// PlaidInstitutionEdge is the edge representation of PlaidInstitution.
type PlaidInstitutionEdge struct {
	Node   *PlaidInstitution `json:"node"`
	Cursor Cursor            `json:"cursor"`
}

// PlaidInstitutionConnection is the connection containing edges to PlaidInstitution.
type PlaidInstitutionConnection struct {
	Edges      []*PlaidInstitutionEdge `json:"edges"`
	PageInfo   PageInfo                `json:"pageInfo"`
	TotalCount int                     `json:"totalCount"`
}

func (c *PlaidInstitutionConnection) build(nodes []*PlaidInstitution, pager *plaidinstitutionPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *PlaidInstitution
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *PlaidInstitution {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *PlaidInstitution {
			return nodes[i]
		}
	}
	c.Edges = make([]*PlaidInstitutionEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &PlaidInstitutionEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// PlaidInstitutionPaginateOption enables pagination customization.
type PlaidInstitutionPaginateOption func(*plaidinstitutionPager) error

// WithPlaidInstitutionOrder configures pagination ordering.
func WithPlaidInstitutionOrder(order *PlaidInstitutionOrder) PlaidInstitutionPaginateOption {
	if order == nil {
		order = DefaultPlaidInstitutionOrder
	}
	o := *order
	return func(pager *plaidinstitutionPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultPlaidInstitutionOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithPlaidInstitutionFilter configures pagination filter.
func WithPlaidInstitutionFilter(filter func(*PlaidInstitutionQuery) (*PlaidInstitutionQuery, error)) PlaidInstitutionPaginateOption {
	return func(pager *plaidinstitutionPager) error {
		if filter == nil {
			return errors.New("PlaidInstitutionQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type plaidinstitutionPager struct {
	order  *PlaidInstitutionOrder
	filter func(*PlaidInstitutionQuery) (*PlaidInstitutionQuery, error)
}

func newPlaidInstitutionPager(opts []PlaidInstitutionPaginateOption) (*plaidinstitutionPager, error) {
	pager := &plaidinstitutionPager{}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultPlaidInstitutionOrder
	}
	return pager, nil
}

func (p *plaidinstitutionPager) applyFilter(query *PlaidInstitutionQuery) (*PlaidInstitutionQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *plaidinstitutionPager) toCursor(pi *PlaidInstitution) Cursor {
	return p.order.Field.toCursor(pi)
}

func (p *plaidinstitutionPager) applyCursors(query *PlaidInstitutionQuery, after, before *Cursor) *PlaidInstitutionQuery {
	for _, predicate := range cursorsToPredicates(
		p.order.Direction, after, before,
		p.order.Field.field, DefaultPlaidInstitutionOrder.Field.field,
	) {
		query = query.Where(predicate)
	}
	return query
}

func (p *plaidinstitutionPager) applyOrder(query *PlaidInstitutionQuery, reverse bool) *PlaidInstitutionQuery {
	direction := p.order.Direction
	if reverse {
		direction = direction.reverse()
	}
	query = query.Order(direction.orderFunc(p.order.Field.field))
	if p.order.Field != DefaultPlaidInstitutionOrder.Field {
		query = query.Order(direction.orderFunc(DefaultPlaidInstitutionOrder.Field.field))
	}
	return query
}

func (p *plaidinstitutionPager) orderExpr(reverse bool) sql.Querier {
	direction := p.order.Direction
	if reverse {
		direction = direction.reverse()
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.field).Pad().WriteString(string(direction))
		if p.order.Field != DefaultPlaidInstitutionOrder.Field {
			b.Comma().Ident(DefaultPlaidInstitutionOrder.Field.field).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to PlaidInstitution.
func (pi *PlaidInstitutionQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...PlaidInstitutionPaginateOption,
) (*PlaidInstitutionConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newPlaidInstitutionPager(opts)
	if err != nil {
		return nil, err
	}
	if pi, err = pager.applyFilter(pi); err != nil {
		return nil, err
	}
	conn := &PlaidInstitutionConnection{Edges: []*PlaidInstitutionEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			if conn.TotalCount, err = pi.Clone().Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}

	pi = pager.applyCursors(pi, after, before)
	pi = pager.applyOrder(pi, last != nil)
	if limit := paginateLimit(first, last); limit != 0 {
		pi.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := pi.collectField(ctx, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}

	nodes, err := pi.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

// PlaidInstitutionOrderField defines the ordering field of PlaidInstitution.
type PlaidInstitutionOrderField struct {
	field    string
	toCursor func(*PlaidInstitution) Cursor
}

// PlaidInstitutionOrder defines the ordering of PlaidInstitution.
type PlaidInstitutionOrder struct {
	Direction OrderDirection              `json:"direction"`
	Field     *PlaidInstitutionOrderField `json:"field"`
}

// DefaultPlaidInstitutionOrder is the default ordering of PlaidInstitution.
var DefaultPlaidInstitutionOrder = &PlaidInstitutionOrder{
	Direction: OrderDirectionAsc,
	Field: &PlaidInstitutionOrderField{
		field: plaidinstitution.FieldID,
		toCursor: func(pi *PlaidInstitution) Cursor {
			return Cursor{ID: pi.ID}
		},
	},
}

// ToEdge converts PlaidInstitution into PlaidInstitutionEdge.
func (pi *PlaidInstitution) ToEdge(order *PlaidInstitutionOrder) *PlaidInstitutionEdge {
	if order == nil {
		order = DefaultPlaidInstitutionOrder
	}
	return &PlaidInstitutionEdge{
		Node:   pi,
		Cursor: order.Field.toCursor(pi),
	}
}

// PlaidInstitutionAccountEdge is the edge representation of PlaidInstitutionAccount.
type PlaidInstitutionAccountEdge struct {
	Node   *PlaidInstitutionAccount `json:"node"`
	Cursor Cursor                   `json:"cursor"`
}

// PlaidInstitutionAccountConnection is the connection containing edges to PlaidInstitutionAccount.
type PlaidInstitutionAccountConnection struct {
	Edges      []*PlaidInstitutionAccountEdge `json:"edges"`
	PageInfo   PageInfo                       `json:"pageInfo"`
	TotalCount int                            `json:"totalCount"`
}

func (c *PlaidInstitutionAccountConnection) build(nodes []*PlaidInstitutionAccount, pager *plaidinstitutionaccountPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *PlaidInstitutionAccount
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *PlaidInstitutionAccount {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *PlaidInstitutionAccount {
			return nodes[i]
		}
	}
	c.Edges = make([]*PlaidInstitutionAccountEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &PlaidInstitutionAccountEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// PlaidInstitutionAccountPaginateOption enables pagination customization.
type PlaidInstitutionAccountPaginateOption func(*plaidinstitutionaccountPager) error

// WithPlaidInstitutionAccountOrder configures pagination ordering.
func WithPlaidInstitutionAccountOrder(order *PlaidInstitutionAccountOrder) PlaidInstitutionAccountPaginateOption {
	if order == nil {
		order = DefaultPlaidInstitutionAccountOrder
	}
	o := *order
	return func(pager *plaidinstitutionaccountPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultPlaidInstitutionAccountOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithPlaidInstitutionAccountFilter configures pagination filter.
func WithPlaidInstitutionAccountFilter(filter func(*PlaidInstitutionAccountQuery) (*PlaidInstitutionAccountQuery, error)) PlaidInstitutionAccountPaginateOption {
	return func(pager *plaidinstitutionaccountPager) error {
		if filter == nil {
			return errors.New("PlaidInstitutionAccountQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type plaidinstitutionaccountPager struct {
	order  *PlaidInstitutionAccountOrder
	filter func(*PlaidInstitutionAccountQuery) (*PlaidInstitutionAccountQuery, error)
}

func newPlaidInstitutionAccountPager(opts []PlaidInstitutionAccountPaginateOption) (*plaidinstitutionaccountPager, error) {
	pager := &plaidinstitutionaccountPager{}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultPlaidInstitutionAccountOrder
	}
	return pager, nil
}

func (p *plaidinstitutionaccountPager) applyFilter(query *PlaidInstitutionAccountQuery) (*PlaidInstitutionAccountQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *plaidinstitutionaccountPager) toCursor(pia *PlaidInstitutionAccount) Cursor {
	return p.order.Field.toCursor(pia)
}

func (p *plaidinstitutionaccountPager) applyCursors(query *PlaidInstitutionAccountQuery, after, before *Cursor) *PlaidInstitutionAccountQuery {
	for _, predicate := range cursorsToPredicates(
		p.order.Direction, after, before,
		p.order.Field.field, DefaultPlaidInstitutionAccountOrder.Field.field,
	) {
		query = query.Where(predicate)
	}
	return query
}

func (p *plaidinstitutionaccountPager) applyOrder(query *PlaidInstitutionAccountQuery, reverse bool) *PlaidInstitutionAccountQuery {
	direction := p.order.Direction
	if reverse {
		direction = direction.reverse()
	}
	query = query.Order(direction.orderFunc(p.order.Field.field))
	if p.order.Field != DefaultPlaidInstitutionAccountOrder.Field {
		query = query.Order(direction.orderFunc(DefaultPlaidInstitutionAccountOrder.Field.field))
	}
	return query
}

func (p *plaidinstitutionaccountPager) orderExpr(reverse bool) sql.Querier {
	direction := p.order.Direction
	if reverse {
		direction = direction.reverse()
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.field).Pad().WriteString(string(direction))
		if p.order.Field != DefaultPlaidInstitutionAccountOrder.Field {
			b.Comma().Ident(DefaultPlaidInstitutionAccountOrder.Field.field).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to PlaidInstitutionAccount.
func (pia *PlaidInstitutionAccountQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...PlaidInstitutionAccountPaginateOption,
) (*PlaidInstitutionAccountConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newPlaidInstitutionAccountPager(opts)
	if err != nil {
		return nil, err
	}
	if pia, err = pager.applyFilter(pia); err != nil {
		return nil, err
	}
	conn := &PlaidInstitutionAccountConnection{Edges: []*PlaidInstitutionAccountEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			if conn.TotalCount, err = pia.Clone().Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}

	pia = pager.applyCursors(pia, after, before)
	pia = pager.applyOrder(pia, last != nil)
	if limit := paginateLimit(first, last); limit != 0 {
		pia.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := pia.collectField(ctx, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}

	nodes, err := pia.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

// PlaidInstitutionAccountOrderField defines the ordering field of PlaidInstitutionAccount.
type PlaidInstitutionAccountOrderField struct {
	field    string
	toCursor func(*PlaidInstitutionAccount) Cursor
}

// PlaidInstitutionAccountOrder defines the ordering of PlaidInstitutionAccount.
type PlaidInstitutionAccountOrder struct {
	Direction OrderDirection                     `json:"direction"`
	Field     *PlaidInstitutionAccountOrderField `json:"field"`
}

// DefaultPlaidInstitutionAccountOrder is the default ordering of PlaidInstitutionAccount.
var DefaultPlaidInstitutionAccountOrder = &PlaidInstitutionAccountOrder{
	Direction: OrderDirectionAsc,
	Field: &PlaidInstitutionAccountOrderField{
		field: plaidinstitutionaccount.FieldID,
		toCursor: func(pia *PlaidInstitutionAccount) Cursor {
			return Cursor{ID: pia.ID}
		},
	},
}

// ToEdge converts PlaidInstitutionAccount into PlaidInstitutionAccountEdge.
func (pia *PlaidInstitutionAccount) ToEdge(order *PlaidInstitutionAccountOrder) *PlaidInstitutionAccountEdge {
	if order == nil {
		order = DefaultPlaidInstitutionAccountOrder
	}
	return &PlaidInstitutionAccountEdge{
		Node:   pia,
		Cursor: order.Field.toCursor(pia),
	}
}

// PlaidItemEdge is the edge representation of PlaidItem.
type PlaidItemEdge struct {
	Node   *PlaidItem `json:"node"`
	Cursor Cursor     `json:"cursor"`
}

// PlaidItemConnection is the connection containing edges to PlaidItem.
type PlaidItemConnection struct {
	Edges      []*PlaidItemEdge `json:"edges"`
	PageInfo   PageInfo         `json:"pageInfo"`
	TotalCount int              `json:"totalCount"`
}

func (c *PlaidItemConnection) build(nodes []*PlaidItem, pager *plaiditemPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *PlaidItem
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *PlaidItem {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *PlaidItem {
			return nodes[i]
		}
	}
	c.Edges = make([]*PlaidItemEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &PlaidItemEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// PlaidItemPaginateOption enables pagination customization.
type PlaidItemPaginateOption func(*plaiditemPager) error

// WithPlaidItemOrder configures pagination ordering.
func WithPlaidItemOrder(order *PlaidItemOrder) PlaidItemPaginateOption {
	if order == nil {
		order = DefaultPlaidItemOrder
	}
	o := *order
	return func(pager *plaiditemPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultPlaidItemOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithPlaidItemFilter configures pagination filter.
func WithPlaidItemFilter(filter func(*PlaidItemQuery) (*PlaidItemQuery, error)) PlaidItemPaginateOption {
	return func(pager *plaiditemPager) error {
		if filter == nil {
			return errors.New("PlaidItemQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type plaiditemPager struct {
	order  *PlaidItemOrder
	filter func(*PlaidItemQuery) (*PlaidItemQuery, error)
}

func newPlaidItemPager(opts []PlaidItemPaginateOption) (*plaiditemPager, error) {
	pager := &plaiditemPager{}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultPlaidItemOrder
	}
	return pager, nil
}

func (p *plaiditemPager) applyFilter(query *PlaidItemQuery) (*PlaidItemQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *plaiditemPager) toCursor(pi *PlaidItem) Cursor {
	return p.order.Field.toCursor(pi)
}

func (p *plaiditemPager) applyCursors(query *PlaidItemQuery, after, before *Cursor) *PlaidItemQuery {
	for _, predicate := range cursorsToPredicates(
		p.order.Direction, after, before,
		p.order.Field.field, DefaultPlaidItemOrder.Field.field,
	) {
		query = query.Where(predicate)
	}
	return query
}

func (p *plaiditemPager) applyOrder(query *PlaidItemQuery, reverse bool) *PlaidItemQuery {
	direction := p.order.Direction
	if reverse {
		direction = direction.reverse()
	}
	query = query.Order(direction.orderFunc(p.order.Field.field))
	if p.order.Field != DefaultPlaidItemOrder.Field {
		query = query.Order(direction.orderFunc(DefaultPlaidItemOrder.Field.field))
	}
	return query
}

func (p *plaiditemPager) orderExpr(reverse bool) sql.Querier {
	direction := p.order.Direction
	if reverse {
		direction = direction.reverse()
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.field).Pad().WriteString(string(direction))
		if p.order.Field != DefaultPlaidItemOrder.Field {
			b.Comma().Ident(DefaultPlaidItemOrder.Field.field).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to PlaidItem.
func (pi *PlaidItemQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...PlaidItemPaginateOption,
) (*PlaidItemConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newPlaidItemPager(opts)
	if err != nil {
		return nil, err
	}
	if pi, err = pager.applyFilter(pi); err != nil {
		return nil, err
	}
	conn := &PlaidItemConnection{Edges: []*PlaidItemEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			if conn.TotalCount, err = pi.Clone().Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}

	pi = pager.applyCursors(pi, after, before)
	pi = pager.applyOrder(pi, last != nil)
	if limit := paginateLimit(first, last); limit != 0 {
		pi.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := pi.collectField(ctx, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}

	nodes, err := pi.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// PlaidItemOrderFieldCreatedAt orders PlaidItem by created_at.
	PlaidItemOrderFieldCreatedAt = &PlaidItemOrderField{
		field: plaiditem.FieldCreatedAt,
		toCursor: func(pi *PlaidItem) Cursor {
			return Cursor{
				ID:    pi.ID,
				Value: pi.CreatedAt,
			}
		},
	}
	// PlaidItemOrderFieldUpdatedAt orders PlaidItem by updated_at.
	PlaidItemOrderFieldUpdatedAt = &PlaidItemOrderField{
		field: plaiditem.FieldUpdatedAt,
		toCursor: func(pi *PlaidItem) Cursor {
			return Cursor{
				ID:    pi.ID,
				Value: pi.UpdatedAt,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f PlaidItemOrderField) String() string {
	var str string
	switch f.field {
	case plaiditem.FieldCreatedAt:
		str = "CREATED_AT"
	case plaiditem.FieldUpdatedAt:
		str = "UPDATED_AT"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f PlaidItemOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *PlaidItemOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("PlaidItemOrderField %T must be a string", v)
	}
	switch str {
	case "CREATED_AT":
		*f = *PlaidItemOrderFieldCreatedAt
	case "UPDATED_AT":
		*f = *PlaidItemOrderFieldUpdatedAt
	default:
		return fmt.Errorf("%s is not a valid PlaidItemOrderField", str)
	}
	return nil
}

// PlaidItemOrderField defines the ordering field of PlaidItem.
type PlaidItemOrderField struct {
	field    string
	toCursor func(*PlaidItem) Cursor
}

// PlaidItemOrder defines the ordering of PlaidItem.
type PlaidItemOrder struct {
	Direction OrderDirection       `json:"direction"`
	Field     *PlaidItemOrderField `json:"field"`
}

// DefaultPlaidItemOrder is the default ordering of PlaidItem.
var DefaultPlaidItemOrder = &PlaidItemOrder{
	Direction: OrderDirectionAsc,
	Field: &PlaidItemOrderField{
		field: plaiditem.FieldID,
		toCursor: func(pi *PlaidItem) Cursor {
			return Cursor{ID: pi.ID}
		},
	},
}

// ToEdge converts PlaidItem into PlaidItemEdge.
func (pi *PlaidItem) ToEdge(order *PlaidItemOrder) *PlaidItemEdge {
	if order == nil {
		order = DefaultPlaidItemOrder
	}
	return &PlaidItemEdge{
		Node:   pi,
		Cursor: order.Field.toCursor(pi),
	}
}

// SpendingCategoryEdge is the edge representation of SpendingCategory.
type SpendingCategoryEdge struct {
	Node   *SpendingCategory `json:"node"`
	Cursor Cursor            `json:"cursor"`
}

// SpendingCategoryConnection is the connection containing edges to SpendingCategory.
type SpendingCategoryConnection struct {
	Edges      []*SpendingCategoryEdge `json:"edges"`
	PageInfo   PageInfo                `json:"pageInfo"`
	TotalCount int                     `json:"totalCount"`
}

func (c *SpendingCategoryConnection) build(nodes []*SpendingCategory, pager *spendingcategoryPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *SpendingCategory
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *SpendingCategory {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *SpendingCategory {
			return nodes[i]
		}
	}
	c.Edges = make([]*SpendingCategoryEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &SpendingCategoryEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// SpendingCategoryPaginateOption enables pagination customization.
type SpendingCategoryPaginateOption func(*spendingcategoryPager) error

// WithSpendingCategoryOrder configures pagination ordering.
func WithSpendingCategoryOrder(order *SpendingCategoryOrder) SpendingCategoryPaginateOption {
	if order == nil {
		order = DefaultSpendingCategoryOrder
	}
	o := *order
	return func(pager *spendingcategoryPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultSpendingCategoryOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithSpendingCategoryFilter configures pagination filter.
func WithSpendingCategoryFilter(filter func(*SpendingCategoryQuery) (*SpendingCategoryQuery, error)) SpendingCategoryPaginateOption {
	return func(pager *spendingcategoryPager) error {
		if filter == nil {
			return errors.New("SpendingCategoryQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type spendingcategoryPager struct {
	order  *SpendingCategoryOrder
	filter func(*SpendingCategoryQuery) (*SpendingCategoryQuery, error)
}

func newSpendingCategoryPager(opts []SpendingCategoryPaginateOption) (*spendingcategoryPager, error) {
	pager := &spendingcategoryPager{}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultSpendingCategoryOrder
	}
	return pager, nil
}

func (p *spendingcategoryPager) applyFilter(query *SpendingCategoryQuery) (*SpendingCategoryQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *spendingcategoryPager) toCursor(sc *SpendingCategory) Cursor {
	return p.order.Field.toCursor(sc)
}

func (p *spendingcategoryPager) applyCursors(query *SpendingCategoryQuery, after, before *Cursor) *SpendingCategoryQuery {
	for _, predicate := range cursorsToPredicates(
		p.order.Direction, after, before,
		p.order.Field.field, DefaultSpendingCategoryOrder.Field.field,
	) {
		query = query.Where(predicate)
	}
	return query
}

func (p *spendingcategoryPager) applyOrder(query *SpendingCategoryQuery, reverse bool) *SpendingCategoryQuery {
	direction := p.order.Direction
	if reverse {
		direction = direction.reverse()
	}
	query = query.Order(direction.orderFunc(p.order.Field.field))
	if p.order.Field != DefaultSpendingCategoryOrder.Field {
		query = query.Order(direction.orderFunc(DefaultSpendingCategoryOrder.Field.field))
	}
	return query
}

func (p *spendingcategoryPager) orderExpr(reverse bool) sql.Querier {
	direction := p.order.Direction
	if reverse {
		direction = direction.reverse()
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.field).Pad().WriteString(string(direction))
		if p.order.Field != DefaultSpendingCategoryOrder.Field {
			b.Comma().Ident(DefaultSpendingCategoryOrder.Field.field).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to SpendingCategory.
func (sc *SpendingCategoryQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...SpendingCategoryPaginateOption,
) (*SpendingCategoryConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newSpendingCategoryPager(opts)
	if err != nil {
		return nil, err
	}
	if sc, err = pager.applyFilter(sc); err != nil {
		return nil, err
	}
	conn := &SpendingCategoryConnection{Edges: []*SpendingCategoryEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			if conn.TotalCount, err = sc.Clone().Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}

	sc = pager.applyCursors(sc, after, before)
	sc = pager.applyOrder(sc, last != nil)
	if limit := paginateLimit(first, last); limit != 0 {
		sc.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := sc.collectField(ctx, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}

	nodes, err := sc.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

// SpendingCategoryOrderField defines the ordering field of SpendingCategory.
type SpendingCategoryOrderField struct {
	field    string
	toCursor func(*SpendingCategory) Cursor
}

// SpendingCategoryOrder defines the ordering of SpendingCategory.
type SpendingCategoryOrder struct {
	Direction OrderDirection              `json:"direction"`
	Field     *SpendingCategoryOrderField `json:"field"`
}

// DefaultSpendingCategoryOrder is the default ordering of SpendingCategory.
var DefaultSpendingCategoryOrder = &SpendingCategoryOrder{
	Direction: OrderDirectionAsc,
	Field: &SpendingCategoryOrderField{
		field: spendingcategory.FieldID,
		toCursor: func(sc *SpendingCategory) Cursor {
			return Cursor{ID: sc.ID}
		},
	},
}

// ToEdge converts SpendingCategory into SpendingCategoryEdge.
func (sc *SpendingCategory) ToEdge(order *SpendingCategoryOrder) *SpendingCategoryEdge {
	if order == nil {
		order = DefaultSpendingCategoryOrder
	}
	return &SpendingCategoryEdge{
		Node:   sc,
		Cursor: order.Field.toCursor(sc),
	}
}

// TransactionEdge is the edge representation of Transaction.
type TransactionEdge struct {
	Node   *Transaction `json:"node"`
	Cursor Cursor       `json:"cursor"`
}

// TransactionConnection is the connection containing edges to Transaction.
type TransactionConnection struct {
	Edges      []*TransactionEdge `json:"edges"`
	PageInfo   PageInfo           `json:"pageInfo"`
	TotalCount int                `json:"totalCount"`
}

func (c *TransactionConnection) build(nodes []*Transaction, pager *transactionPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *Transaction
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *Transaction {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *Transaction {
			return nodes[i]
		}
	}
	c.Edges = make([]*TransactionEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &TransactionEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// TransactionPaginateOption enables pagination customization.
type TransactionPaginateOption func(*transactionPager) error

// WithTransactionOrder configures pagination ordering.
func WithTransactionOrder(order *TransactionOrder) TransactionPaginateOption {
	if order == nil {
		order = DefaultTransactionOrder
	}
	o := *order
	return func(pager *transactionPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultTransactionOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithTransactionFilter configures pagination filter.
func WithTransactionFilter(filter func(*TransactionQuery) (*TransactionQuery, error)) TransactionPaginateOption {
	return func(pager *transactionPager) error {
		if filter == nil {
			return errors.New("TransactionQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type transactionPager struct {
	order  *TransactionOrder
	filter func(*TransactionQuery) (*TransactionQuery, error)
}

func newTransactionPager(opts []TransactionPaginateOption) (*transactionPager, error) {
	pager := &transactionPager{}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultTransactionOrder
	}
	return pager, nil
}

func (p *transactionPager) applyFilter(query *TransactionQuery) (*TransactionQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *transactionPager) toCursor(t *Transaction) Cursor {
	return p.order.Field.toCursor(t)
}

func (p *transactionPager) applyCursors(query *TransactionQuery, after, before *Cursor) *TransactionQuery {
	for _, predicate := range cursorsToPredicates(
		p.order.Direction, after, before,
		p.order.Field.field, DefaultTransactionOrder.Field.field,
	) {
		query = query.Where(predicate)
	}
	return query
}

func (p *transactionPager) applyOrder(query *TransactionQuery, reverse bool) *TransactionQuery {
	direction := p.order.Direction
	if reverse {
		direction = direction.reverse()
	}
	query = query.Order(direction.orderFunc(p.order.Field.field))
	if p.order.Field != DefaultTransactionOrder.Field {
		query = query.Order(direction.orderFunc(DefaultTransactionOrder.Field.field))
	}
	return query
}

func (p *transactionPager) orderExpr(reverse bool) sql.Querier {
	direction := p.order.Direction
	if reverse {
		direction = direction.reverse()
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.field).Pad().WriteString(string(direction))
		if p.order.Field != DefaultTransactionOrder.Field {
			b.Comma().Ident(DefaultTransactionOrder.Field.field).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to Transaction.
func (t *TransactionQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...TransactionPaginateOption,
) (*TransactionConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newTransactionPager(opts)
	if err != nil {
		return nil, err
	}
	if t, err = pager.applyFilter(t); err != nil {
		return nil, err
	}
	conn := &TransactionConnection{Edges: []*TransactionEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			if conn.TotalCount, err = t.Clone().Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}

	t = pager.applyCursors(t, after, before)
	t = pager.applyOrder(t, last != nil)
	if limit := paginateLimit(first, last); limit != 0 {
		t.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := t.collectField(ctx, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}

	nodes, err := t.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// TransactionOrderFieldDate orders Transaction by date.
	TransactionOrderFieldDate = &TransactionOrderField{
		field: transaction.FieldDate,
		toCursor: func(t *Transaction) Cursor {
			return Cursor{
				ID:    t.ID,
				Value: t.Date,
			}
		},
	}
	// TransactionOrderFieldDatetime orders Transaction by datetime.
	TransactionOrderFieldDatetime = &TransactionOrderField{
		field: transaction.FieldDatetime,
		toCursor: func(t *Transaction) Cursor {
			return Cursor{
				ID:    t.ID,
				Value: t.Datetime,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f TransactionOrderField) String() string {
	var str string
	switch f.field {
	case transaction.FieldDate:
		str = "DATE"
	case transaction.FieldDatetime:
		str = "DATETIME"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f TransactionOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *TransactionOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("TransactionOrderField %T must be a string", v)
	}
	switch str {
	case "DATE":
		*f = *TransactionOrderFieldDate
	case "DATETIME":
		*f = *TransactionOrderFieldDatetime
	default:
		return fmt.Errorf("%s is not a valid TransactionOrderField", str)
	}
	return nil
}

// TransactionOrderField defines the ordering field of Transaction.
type TransactionOrderField struct {
	field    string
	toCursor func(*Transaction) Cursor
}

// TransactionOrder defines the ordering of Transaction.
type TransactionOrder struct {
	Direction OrderDirection         `json:"direction"`
	Field     *TransactionOrderField `json:"field"`
}

// DefaultTransactionOrder is the default ordering of Transaction.
var DefaultTransactionOrder = &TransactionOrder{
	Direction: OrderDirectionAsc,
	Field: &TransactionOrderField{
		field: transaction.FieldID,
		toCursor: func(t *Transaction) Cursor {
			return Cursor{ID: t.ID}
		},
	},
}

// ToEdge converts Transaction into TransactionEdge.
func (t *Transaction) ToEdge(order *TransactionOrder) *TransactionEdge {
	if order == nil {
		order = DefaultTransactionOrder
	}
	return &TransactionEdge{
		Node:   t,
		Cursor: order.Field.toCursor(t),
	}
}

// TransactionSyncEdge is the edge representation of TransactionSync.
type TransactionSyncEdge struct {
	Node   *TransactionSync `json:"node"`
	Cursor Cursor           `json:"cursor"`
}

// TransactionSyncConnection is the connection containing edges to TransactionSync.
type TransactionSyncConnection struct {
	Edges      []*TransactionSyncEdge `json:"edges"`
	PageInfo   PageInfo               `json:"pageInfo"`
	TotalCount int                    `json:"totalCount"`
}

func (c *TransactionSyncConnection) build(nodes []*TransactionSync, pager *transactionsyncPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *TransactionSync
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *TransactionSync {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *TransactionSync {
			return nodes[i]
		}
	}
	c.Edges = make([]*TransactionSyncEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &TransactionSyncEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// TransactionSyncPaginateOption enables pagination customization.
type TransactionSyncPaginateOption func(*transactionsyncPager) error

// WithTransactionSyncOrder configures pagination ordering.
func WithTransactionSyncOrder(order *TransactionSyncOrder) TransactionSyncPaginateOption {
	if order == nil {
		order = DefaultTransactionSyncOrder
	}
	o := *order
	return func(pager *transactionsyncPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultTransactionSyncOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithTransactionSyncFilter configures pagination filter.
func WithTransactionSyncFilter(filter func(*TransactionSyncQuery) (*TransactionSyncQuery, error)) TransactionSyncPaginateOption {
	return func(pager *transactionsyncPager) error {
		if filter == nil {
			return errors.New("TransactionSyncQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type transactionsyncPager struct {
	order  *TransactionSyncOrder
	filter func(*TransactionSyncQuery) (*TransactionSyncQuery, error)
}

func newTransactionSyncPager(opts []TransactionSyncPaginateOption) (*transactionsyncPager, error) {
	pager := &transactionsyncPager{}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultTransactionSyncOrder
	}
	return pager, nil
}

func (p *transactionsyncPager) applyFilter(query *TransactionSyncQuery) (*TransactionSyncQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *transactionsyncPager) toCursor(ts *TransactionSync) Cursor {
	return p.order.Field.toCursor(ts)
}

func (p *transactionsyncPager) applyCursors(query *TransactionSyncQuery, after, before *Cursor) *TransactionSyncQuery {
	for _, predicate := range cursorsToPredicates(
		p.order.Direction, after, before,
		p.order.Field.field, DefaultTransactionSyncOrder.Field.field,
	) {
		query = query.Where(predicate)
	}
	return query
}

func (p *transactionsyncPager) applyOrder(query *TransactionSyncQuery, reverse bool) *TransactionSyncQuery {
	direction := p.order.Direction
	if reverse {
		direction = direction.reverse()
	}
	query = query.Order(direction.orderFunc(p.order.Field.field))
	if p.order.Field != DefaultTransactionSyncOrder.Field {
		query = query.Order(direction.orderFunc(DefaultTransactionSyncOrder.Field.field))
	}
	return query
}

func (p *transactionsyncPager) orderExpr(reverse bool) sql.Querier {
	direction := p.order.Direction
	if reverse {
		direction = direction.reverse()
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.field).Pad().WriteString(string(direction))
		if p.order.Field != DefaultTransactionSyncOrder.Field {
			b.Comma().Ident(DefaultTransactionSyncOrder.Field.field).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to TransactionSync.
func (ts *TransactionSyncQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...TransactionSyncPaginateOption,
) (*TransactionSyncConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newTransactionSyncPager(opts)
	if err != nil {
		return nil, err
	}
	if ts, err = pager.applyFilter(ts); err != nil {
		return nil, err
	}
	conn := &TransactionSyncConnection{Edges: []*TransactionSyncEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			if conn.TotalCount, err = ts.Clone().Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}

	ts = pager.applyCursors(ts, after, before)
	ts = pager.applyOrder(ts, last != nil)
	if limit := paginateLimit(first, last); limit != 0 {
		ts.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := ts.collectField(ctx, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}

	nodes, err := ts.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

// TransactionSyncOrderField defines the ordering field of TransactionSync.
type TransactionSyncOrderField struct {
	field    string
	toCursor func(*TransactionSync) Cursor
}

// TransactionSyncOrder defines the ordering of TransactionSync.
type TransactionSyncOrder struct {
	Direction OrderDirection             `json:"direction"`
	Field     *TransactionSyncOrderField `json:"field"`
}

// DefaultTransactionSyncOrder is the default ordering of TransactionSync.
var DefaultTransactionSyncOrder = &TransactionSyncOrder{
	Direction: OrderDirectionAsc,
	Field: &TransactionSyncOrderField{
		field: transactionsync.FieldID,
		toCursor: func(ts *TransactionSync) Cursor {
			return Cursor{ID: ts.ID}
		},
	},
}

// ToEdge converts TransactionSync into TransactionSyncEdge.
func (ts *TransactionSync) ToEdge(order *TransactionSyncOrder) *TransactionSyncEdge {
	if order == nil {
		order = DefaultTransactionSyncOrder
	}
	return &TransactionSyncEdge{
		Node:   ts,
		Cursor: order.Field.toCursor(ts),
	}
}

// UserEdge is the edge representation of User.
type UserEdge struct {
	Node   *User  `json:"node"`
	Cursor Cursor `json:"cursor"`
}

// UserConnection is the connection containing edges to User.
type UserConnection struct {
	Edges      []*UserEdge `json:"edges"`
	PageInfo   PageInfo    `json:"pageInfo"`
	TotalCount int         `json:"totalCount"`
}

func (c *UserConnection) build(nodes []*User, pager *userPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *User
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *User {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *User {
			return nodes[i]
		}
	}
	c.Edges = make([]*UserEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &UserEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// UserPaginateOption enables pagination customization.
type UserPaginateOption func(*userPager) error

// WithUserOrder configures pagination ordering.
func WithUserOrder(order *UserOrder) UserPaginateOption {
	if order == nil {
		order = DefaultUserOrder
	}
	o := *order
	return func(pager *userPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultUserOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithUserFilter configures pagination filter.
func WithUserFilter(filter func(*UserQuery) (*UserQuery, error)) UserPaginateOption {
	return func(pager *userPager) error {
		if filter == nil {
			return errors.New("UserQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type userPager struct {
	order  *UserOrder
	filter func(*UserQuery) (*UserQuery, error)
}

func newUserPager(opts []UserPaginateOption) (*userPager, error) {
	pager := &userPager{}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultUserOrder
	}
	return pager, nil
}

func (p *userPager) applyFilter(query *UserQuery) (*UserQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *userPager) toCursor(u *User) Cursor {
	return p.order.Field.toCursor(u)
}

func (p *userPager) applyCursors(query *UserQuery, after, before *Cursor) *UserQuery {
	for _, predicate := range cursorsToPredicates(
		p.order.Direction, after, before,
		p.order.Field.field, DefaultUserOrder.Field.field,
	) {
		query = query.Where(predicate)
	}
	return query
}

func (p *userPager) applyOrder(query *UserQuery, reverse bool) *UserQuery {
	direction := p.order.Direction
	if reverse {
		direction = direction.reverse()
	}
	query = query.Order(direction.orderFunc(p.order.Field.field))
	if p.order.Field != DefaultUserOrder.Field {
		query = query.Order(direction.orderFunc(DefaultUserOrder.Field.field))
	}
	return query
}

func (p *userPager) orderExpr(reverse bool) sql.Querier {
	direction := p.order.Direction
	if reverse {
		direction = direction.reverse()
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.field).Pad().WriteString(string(direction))
		if p.order.Field != DefaultUserOrder.Field {
			b.Comma().Ident(DefaultUserOrder.Field.field).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to User.
func (u *UserQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...UserPaginateOption,
) (*UserConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newUserPager(opts)
	if err != nil {
		return nil, err
	}
	if u, err = pager.applyFilter(u); err != nil {
		return nil, err
	}
	conn := &UserConnection{Edges: []*UserEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			if conn.TotalCount, err = u.Clone().Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}

	u = pager.applyCursors(u, after, before)
	u = pager.applyOrder(u, last != nil)
	if limit := paginateLimit(first, last); limit != 0 {
		u.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := u.collectField(ctx, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}

	nodes, err := u.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

// UserOrderField defines the ordering field of User.
type UserOrderField struct {
	field    string
	toCursor func(*User) Cursor
}

// UserOrder defines the ordering of User.
type UserOrder struct {
	Direction OrderDirection  `json:"direction"`
	Field     *UserOrderField `json:"field"`
}

// DefaultUserOrder is the default ordering of User.
var DefaultUserOrder = &UserOrder{
	Direction: OrderDirectionAsc,
	Field: &UserOrderField{
		field: user.FieldID,
		toCursor: func(u *User) Cursor {
			return Cursor{ID: u.ID}
		},
	},
}

// ToEdge converts User into UserEdge.
func (u *User) ToEdge(order *UserOrder) *UserEdge {
	if order == nil {
		order = DefaultUserOrder
	}
	return &UserEdge{
		Node:   u,
		Cursor: order.Field.toCursor(u),
	}
}

// UserNotificationChannelPreferencesEdge is the edge representation of UserNotificationChannelPreferences.
type UserNotificationChannelPreferencesEdge struct {
	Node   *UserNotificationChannelPreferences `json:"node"`
	Cursor Cursor                              `json:"cursor"`
}

// UserNotificationChannelPreferencesConnection is the connection containing edges to UserNotificationChannelPreferences.
type UserNotificationChannelPreferencesConnection struct {
	Edges      []*UserNotificationChannelPreferencesEdge `json:"edges"`
	PageInfo   PageInfo                                  `json:"pageInfo"`
	TotalCount int                                       `json:"totalCount"`
}

func (c *UserNotificationChannelPreferencesConnection) build(nodes []*UserNotificationChannelPreferences, pager *usernotificationchannelpreferencesPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *UserNotificationChannelPreferences
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *UserNotificationChannelPreferences {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *UserNotificationChannelPreferences {
			return nodes[i]
		}
	}
	c.Edges = make([]*UserNotificationChannelPreferencesEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &UserNotificationChannelPreferencesEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// UserNotificationChannelPreferencesPaginateOption enables pagination customization.
type UserNotificationChannelPreferencesPaginateOption func(*usernotificationchannelpreferencesPager) error

// WithUserNotificationChannelPreferencesOrder configures pagination ordering.
func WithUserNotificationChannelPreferencesOrder(order *UserNotificationChannelPreferencesOrder) UserNotificationChannelPreferencesPaginateOption {
	if order == nil {
		order = DefaultUserNotificationChannelPreferencesOrder
	}
	o := *order
	return func(pager *usernotificationchannelpreferencesPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultUserNotificationChannelPreferencesOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithUserNotificationChannelPreferencesFilter configures pagination filter.
func WithUserNotificationChannelPreferencesFilter(filter func(*UserNotificationChannelPreferencesQuery) (*UserNotificationChannelPreferencesQuery, error)) UserNotificationChannelPreferencesPaginateOption {
	return func(pager *usernotificationchannelpreferencesPager) error {
		if filter == nil {
			return errors.New("UserNotificationChannelPreferencesQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type usernotificationchannelpreferencesPager struct {
	order  *UserNotificationChannelPreferencesOrder
	filter func(*UserNotificationChannelPreferencesQuery) (*UserNotificationChannelPreferencesQuery, error)
}

func newUserNotificationChannelPreferencesPager(opts []UserNotificationChannelPreferencesPaginateOption) (*usernotificationchannelpreferencesPager, error) {
	pager := &usernotificationchannelpreferencesPager{}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultUserNotificationChannelPreferencesOrder
	}
	return pager, nil
}

func (p *usernotificationchannelpreferencesPager) applyFilter(query *UserNotificationChannelPreferencesQuery) (*UserNotificationChannelPreferencesQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *usernotificationchannelpreferencesPager) toCursor(uncp *UserNotificationChannelPreferences) Cursor {
	return p.order.Field.toCursor(uncp)
}

func (p *usernotificationchannelpreferencesPager) applyCursors(query *UserNotificationChannelPreferencesQuery, after, before *Cursor) *UserNotificationChannelPreferencesQuery {
	for _, predicate := range cursorsToPredicates(
		p.order.Direction, after, before,
		p.order.Field.field, DefaultUserNotificationChannelPreferencesOrder.Field.field,
	) {
		query = query.Where(predicate)
	}
	return query
}

func (p *usernotificationchannelpreferencesPager) applyOrder(query *UserNotificationChannelPreferencesQuery, reverse bool) *UserNotificationChannelPreferencesQuery {
	direction := p.order.Direction
	if reverse {
		direction = direction.reverse()
	}
	query = query.Order(direction.orderFunc(p.order.Field.field))
	if p.order.Field != DefaultUserNotificationChannelPreferencesOrder.Field {
		query = query.Order(direction.orderFunc(DefaultUserNotificationChannelPreferencesOrder.Field.field))
	}
	return query
}

func (p *usernotificationchannelpreferencesPager) orderExpr(reverse bool) sql.Querier {
	direction := p.order.Direction
	if reverse {
		direction = direction.reverse()
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.field).Pad().WriteString(string(direction))
		if p.order.Field != DefaultUserNotificationChannelPreferencesOrder.Field {
			b.Comma().Ident(DefaultUserNotificationChannelPreferencesOrder.Field.field).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to UserNotificationChannelPreferences.
func (uncp *UserNotificationChannelPreferencesQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...UserNotificationChannelPreferencesPaginateOption,
) (*UserNotificationChannelPreferencesConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newUserNotificationChannelPreferencesPager(opts)
	if err != nil {
		return nil, err
	}
	if uncp, err = pager.applyFilter(uncp); err != nil {
		return nil, err
	}
	conn := &UserNotificationChannelPreferencesConnection{Edges: []*UserNotificationChannelPreferencesEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			if conn.TotalCount, err = uncp.Clone().Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}

	uncp = pager.applyCursors(uncp, after, before)
	uncp = pager.applyOrder(uncp, last != nil)
	if limit := paginateLimit(first, last); limit != 0 {
		uncp.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := uncp.collectField(ctx, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}

	nodes, err := uncp.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

// UserNotificationChannelPreferencesOrderField defines the ordering field of UserNotificationChannelPreferences.
type UserNotificationChannelPreferencesOrderField struct {
	field    string
	toCursor func(*UserNotificationChannelPreferences) Cursor
}

// UserNotificationChannelPreferencesOrder defines the ordering of UserNotificationChannelPreferences.
type UserNotificationChannelPreferencesOrder struct {
	Direction OrderDirection                                `json:"direction"`
	Field     *UserNotificationChannelPreferencesOrderField `json:"field"`
}

// DefaultUserNotificationChannelPreferencesOrder is the default ordering of UserNotificationChannelPreferences.
var DefaultUserNotificationChannelPreferencesOrder = &UserNotificationChannelPreferencesOrder{
	Direction: OrderDirectionAsc,
	Field: &UserNotificationChannelPreferencesOrderField{
		field: usernotificationchannelpreferences.FieldID,
		toCursor: func(uncp *UserNotificationChannelPreferences) Cursor {
			return Cursor{ID: uncp.ID}
		},
	},
}

// ToEdge converts UserNotificationChannelPreferences into UserNotificationChannelPreferencesEdge.
func (uncp *UserNotificationChannelPreferences) ToEdge(order *UserNotificationChannelPreferencesOrder) *UserNotificationChannelPreferencesEdge {
	if order == nil {
		order = DefaultUserNotificationChannelPreferencesOrder
	}
	return &UserNotificationChannelPreferencesEdge{
		Node:   uncp,
		Cursor: order.Field.toCursor(uncp),
	}
}
