// Code generated by ent, DO NOT EDIT.

package ent

import (
	"errors"
	"fmt"
	"time"
	"wallit/ent/discountoffer"
	"wallit/ent/merchant"
	"wallit/ent/notification"
	"wallit/ent/plaidinstitution"
	"wallit/ent/plaidinstitutionaccount"
	"wallit/ent/plaiditem"
	"wallit/ent/predicate"
	"wallit/ent/spendingcategory"
	"wallit/ent/transaction"
	"wallit/ent/transactionsync"
	"wallit/ent/user"
	"wallit/ent/usernotificationchannelpreferences"
)

// DiscountOfferWhereInput represents a where input for filtering DiscountOffer queries.
type DiscountOfferWhereInput struct {
	Predicates []predicate.DiscountOffer  `json:"-"`
	Not        *DiscountOfferWhereInput   `json:"not,omitempty"`
	Or         []*DiscountOfferWhereInput `json:"or,omitempty"`
	And        []*DiscountOfferWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *int  `json:"id,omitempty"`
	IDNEQ   *int  `json:"idNEQ,omitempty"`
	IDIn    []int `json:"idIn,omitempty"`
	IDNotIn []int `json:"idNotIn,omitempty"`
	IDGT    *int  `json:"idGT,omitempty"`
	IDGTE   *int  `json:"idGTE,omitempty"`
	IDLT    *int  `json:"idLT,omitempty"`
	IDLTE   *int  `json:"idLTE,omitempty"`

	// "amount" field predicates.
	Amount      *int  `json:"amount,omitempty"`
	AmountNEQ   *int  `json:"amountNEQ,omitempty"`
	AmountIn    []int `json:"amountIn,omitempty"`
	AmountNotIn []int `json:"amountNotIn,omitempty"`
	AmountGT    *int  `json:"amountGT,omitempty"`
	AmountGTE   *int  `json:"amountGTE,omitempty"`
	AmountLT    *int  `json:"amountLT,omitempty"`
	AmountLTE   *int  `json:"amountLTE,omitempty"`

	// "type" field predicates.
	Type      *discountoffer.Type  `json:"type,omitempty"`
	TypeNEQ   *discountoffer.Type  `json:"typeNEQ,omitempty"`
	TypeIn    []discountoffer.Type `json:"typeIn,omitempty"`
	TypeNotIn []discountoffer.Type `json:"typeNotIn,omitempty"`

	// "currency" field predicates.
	Currency             *string  `json:"currency,omitempty"`
	CurrencyNEQ          *string  `json:"currencyNEQ,omitempty"`
	CurrencyIn           []string `json:"currencyIn,omitempty"`
	CurrencyNotIn        []string `json:"currencyNotIn,omitempty"`
	CurrencyGT           *string  `json:"currencyGT,omitempty"`
	CurrencyGTE          *string  `json:"currencyGTE,omitempty"`
	CurrencyLT           *string  `json:"currencyLT,omitempty"`
	CurrencyLTE          *string  `json:"currencyLTE,omitempty"`
	CurrencyContains     *string  `json:"currencyContains,omitempty"`
	CurrencyHasPrefix    *string  `json:"currencyHasPrefix,omitempty"`
	CurrencyHasSuffix    *string  `json:"currencyHasSuffix,omitempty"`
	CurrencyIsNil        bool     `json:"currencyIsNil,omitempty"`
	CurrencyNotNil       bool     `json:"currencyNotNil,omitempty"`
	CurrencyEqualFold    *string  `json:"currencyEqualFold,omitempty"`
	CurrencyContainsFold *string  `json:"currencyContainsFold,omitempty"`

	// "description" field predicates.
	Description             *string  `json:"description,omitempty"`
	DescriptionNEQ          *string  `json:"descriptionNEQ,omitempty"`
	DescriptionIn           []string `json:"descriptionIn,omitempty"`
	DescriptionNotIn        []string `json:"descriptionNotIn,omitempty"`
	DescriptionGT           *string  `json:"descriptionGT,omitempty"`
	DescriptionGTE          *string  `json:"descriptionGTE,omitempty"`
	DescriptionLT           *string  `json:"descriptionLT,omitempty"`
	DescriptionLTE          *string  `json:"descriptionLTE,omitempty"`
	DescriptionContains     *string  `json:"descriptionContains,omitempty"`
	DescriptionHasPrefix    *string  `json:"descriptionHasPrefix,omitempty"`
	DescriptionHasSuffix    *string  `json:"descriptionHasSuffix,omitempty"`
	DescriptionEqualFold    *string  `json:"descriptionEqualFold,omitempty"`
	DescriptionContainsFold *string  `json:"descriptionContainsFold,omitempty"`

	// "merchant_specific_identification" field predicates.
	MerchantSpecificIdentification             *string  `json:"merchantSpecificIdentification,omitempty"`
	MerchantSpecificIdentificationNEQ          *string  `json:"merchantSpecificIdentificationNEQ,omitempty"`
	MerchantSpecificIdentificationIn           []string `json:"merchantSpecificIdentificationIn,omitempty"`
	MerchantSpecificIdentificationNotIn        []string `json:"merchantSpecificIdentificationNotIn,omitempty"`
	MerchantSpecificIdentificationGT           *string  `json:"merchantSpecificIdentificationGT,omitempty"`
	MerchantSpecificIdentificationGTE          *string  `json:"merchantSpecificIdentificationGTE,omitempty"`
	MerchantSpecificIdentificationLT           *string  `json:"merchantSpecificIdentificationLT,omitempty"`
	MerchantSpecificIdentificationLTE          *string  `json:"merchantSpecificIdentificationLTE,omitempty"`
	MerchantSpecificIdentificationContains     *string  `json:"merchantSpecificIdentificationContains,omitempty"`
	MerchantSpecificIdentificationHasPrefix    *string  `json:"merchantSpecificIdentificationHasPrefix,omitempty"`
	MerchantSpecificIdentificationHasSuffix    *string  `json:"merchantSpecificIdentificationHasSuffix,omitempty"`
	MerchantSpecificIdentificationEqualFold    *string  `json:"merchantSpecificIdentificationEqualFold,omitempty"`
	MerchantSpecificIdentificationContainsFold *string  `json:"merchantSpecificIdentificationContainsFold,omitempty"`

	// "created_at" field predicates.
	CreatedAt      *time.Time  `json:"createdAt,omitempty"`
	CreatedAtNEQ   *time.Time  `json:"createdAtNEQ,omitempty"`
	CreatedAtIn    []time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn []time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGT    *time.Time  `json:"createdAtGT,omitempty"`
	CreatedAtGTE   *time.Time  `json:"createdAtGTE,omitempty"`
	CreatedAtLT    *time.Time  `json:"createdAtLT,omitempty"`
	CreatedAtLTE   *time.Time  `json:"createdAtLTE,omitempty"`

	// "expires_at" field predicates.
	ExpiresAt      *time.Time  `json:"expiresAt,omitempty"`
	ExpiresAtNEQ   *time.Time  `json:"expiresAtNEQ,omitempty"`
	ExpiresAtIn    []time.Time `json:"expiresAtIn,omitempty"`
	ExpiresAtNotIn []time.Time `json:"expiresAtNotIn,omitempty"`
	ExpiresAtGT    *time.Time  `json:"expiresAtGT,omitempty"`
	ExpiresAtGTE   *time.Time  `json:"expiresAtGTE,omitempty"`
	ExpiresAtLT    *time.Time  `json:"expiresAtLT,omitempty"`
	ExpiresAtLTE   *time.Time  `json:"expiresAtLTE,omitempty"`

	// "owner_merchant" edge predicates.
	HasOwnerMerchant     *bool                 `json:"hasOwnerMerchant,omitempty"`
	HasOwnerMerchantWith []*MerchantWhereInput `json:"hasOwnerMerchantWith,omitempty"`

	// "discount_eligible_users" edge predicates.
	HasDiscountEligibleUsers     *bool             `json:"hasDiscountEligibleUsers,omitempty"`
	HasDiscountEligibleUsersWith []*UserWhereInput `json:"hasDiscountEligibleUsersWith,omitempty"`

	// "discount_offer_notification" edge predicates.
	HasDiscountOfferNotification     *bool                     `json:"hasDiscountOfferNotification,omitempty"`
	HasDiscountOfferNotificationWith []*NotificationWhereInput `json:"hasDiscountOfferNotificationWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *DiscountOfferWhereInput) AddPredicates(predicates ...predicate.DiscountOffer) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the DiscountOfferWhereInput filter on the DiscountOfferQuery builder.
func (i *DiscountOfferWhereInput) Filter(q *DiscountOfferQuery) (*DiscountOfferQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyDiscountOfferWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyDiscountOfferWhereInput is returned in case the DiscountOfferWhereInput is empty.
var ErrEmptyDiscountOfferWhereInput = errors.New("ent: empty predicate DiscountOfferWhereInput")

// P returns a predicate for filtering discountoffers.
// An error is returned if the input is empty or invalid.
func (i *DiscountOfferWhereInput) P() (predicate.DiscountOffer, error) {
	var predicates []predicate.DiscountOffer
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, discountoffer.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.DiscountOffer, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, discountoffer.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.DiscountOffer, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, discountoffer.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, discountoffer.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, discountoffer.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, discountoffer.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, discountoffer.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, discountoffer.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, discountoffer.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, discountoffer.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, discountoffer.IDLTE(*i.IDLTE))
	}
	if i.Amount != nil {
		predicates = append(predicates, discountoffer.AmountEQ(*i.Amount))
	}
	if i.AmountNEQ != nil {
		predicates = append(predicates, discountoffer.AmountNEQ(*i.AmountNEQ))
	}
	if len(i.AmountIn) > 0 {
		predicates = append(predicates, discountoffer.AmountIn(i.AmountIn...))
	}
	if len(i.AmountNotIn) > 0 {
		predicates = append(predicates, discountoffer.AmountNotIn(i.AmountNotIn...))
	}
	if i.AmountGT != nil {
		predicates = append(predicates, discountoffer.AmountGT(*i.AmountGT))
	}
	if i.AmountGTE != nil {
		predicates = append(predicates, discountoffer.AmountGTE(*i.AmountGTE))
	}
	if i.AmountLT != nil {
		predicates = append(predicates, discountoffer.AmountLT(*i.AmountLT))
	}
	if i.AmountLTE != nil {
		predicates = append(predicates, discountoffer.AmountLTE(*i.AmountLTE))
	}
	if i.Type != nil {
		predicates = append(predicates, discountoffer.TypeEQ(*i.Type))
	}
	if i.TypeNEQ != nil {
		predicates = append(predicates, discountoffer.TypeNEQ(*i.TypeNEQ))
	}
	if len(i.TypeIn) > 0 {
		predicates = append(predicates, discountoffer.TypeIn(i.TypeIn...))
	}
	if len(i.TypeNotIn) > 0 {
		predicates = append(predicates, discountoffer.TypeNotIn(i.TypeNotIn...))
	}
	if i.Currency != nil {
		predicates = append(predicates, discountoffer.CurrencyEQ(*i.Currency))
	}
	if i.CurrencyNEQ != nil {
		predicates = append(predicates, discountoffer.CurrencyNEQ(*i.CurrencyNEQ))
	}
	if len(i.CurrencyIn) > 0 {
		predicates = append(predicates, discountoffer.CurrencyIn(i.CurrencyIn...))
	}
	if len(i.CurrencyNotIn) > 0 {
		predicates = append(predicates, discountoffer.CurrencyNotIn(i.CurrencyNotIn...))
	}
	if i.CurrencyGT != nil {
		predicates = append(predicates, discountoffer.CurrencyGT(*i.CurrencyGT))
	}
	if i.CurrencyGTE != nil {
		predicates = append(predicates, discountoffer.CurrencyGTE(*i.CurrencyGTE))
	}
	if i.CurrencyLT != nil {
		predicates = append(predicates, discountoffer.CurrencyLT(*i.CurrencyLT))
	}
	if i.CurrencyLTE != nil {
		predicates = append(predicates, discountoffer.CurrencyLTE(*i.CurrencyLTE))
	}
	if i.CurrencyContains != nil {
		predicates = append(predicates, discountoffer.CurrencyContains(*i.CurrencyContains))
	}
	if i.CurrencyHasPrefix != nil {
		predicates = append(predicates, discountoffer.CurrencyHasPrefix(*i.CurrencyHasPrefix))
	}
	if i.CurrencyHasSuffix != nil {
		predicates = append(predicates, discountoffer.CurrencyHasSuffix(*i.CurrencyHasSuffix))
	}
	if i.CurrencyIsNil {
		predicates = append(predicates, discountoffer.CurrencyIsNil())
	}
	if i.CurrencyNotNil {
		predicates = append(predicates, discountoffer.CurrencyNotNil())
	}
	if i.CurrencyEqualFold != nil {
		predicates = append(predicates, discountoffer.CurrencyEqualFold(*i.CurrencyEqualFold))
	}
	if i.CurrencyContainsFold != nil {
		predicates = append(predicates, discountoffer.CurrencyContainsFold(*i.CurrencyContainsFold))
	}
	if i.Description != nil {
		predicates = append(predicates, discountoffer.DescriptionEQ(*i.Description))
	}
	if i.DescriptionNEQ != nil {
		predicates = append(predicates, discountoffer.DescriptionNEQ(*i.DescriptionNEQ))
	}
	if len(i.DescriptionIn) > 0 {
		predicates = append(predicates, discountoffer.DescriptionIn(i.DescriptionIn...))
	}
	if len(i.DescriptionNotIn) > 0 {
		predicates = append(predicates, discountoffer.DescriptionNotIn(i.DescriptionNotIn...))
	}
	if i.DescriptionGT != nil {
		predicates = append(predicates, discountoffer.DescriptionGT(*i.DescriptionGT))
	}
	if i.DescriptionGTE != nil {
		predicates = append(predicates, discountoffer.DescriptionGTE(*i.DescriptionGTE))
	}
	if i.DescriptionLT != nil {
		predicates = append(predicates, discountoffer.DescriptionLT(*i.DescriptionLT))
	}
	if i.DescriptionLTE != nil {
		predicates = append(predicates, discountoffer.DescriptionLTE(*i.DescriptionLTE))
	}
	if i.DescriptionContains != nil {
		predicates = append(predicates, discountoffer.DescriptionContains(*i.DescriptionContains))
	}
	if i.DescriptionHasPrefix != nil {
		predicates = append(predicates, discountoffer.DescriptionHasPrefix(*i.DescriptionHasPrefix))
	}
	if i.DescriptionHasSuffix != nil {
		predicates = append(predicates, discountoffer.DescriptionHasSuffix(*i.DescriptionHasSuffix))
	}
	if i.DescriptionEqualFold != nil {
		predicates = append(predicates, discountoffer.DescriptionEqualFold(*i.DescriptionEqualFold))
	}
	if i.DescriptionContainsFold != nil {
		predicates = append(predicates, discountoffer.DescriptionContainsFold(*i.DescriptionContainsFold))
	}
	if i.MerchantSpecificIdentification != nil {
		predicates = append(predicates, discountoffer.MerchantSpecificIdentificationEQ(*i.MerchantSpecificIdentification))
	}
	if i.MerchantSpecificIdentificationNEQ != nil {
		predicates = append(predicates, discountoffer.MerchantSpecificIdentificationNEQ(*i.MerchantSpecificIdentificationNEQ))
	}
	if len(i.MerchantSpecificIdentificationIn) > 0 {
		predicates = append(predicates, discountoffer.MerchantSpecificIdentificationIn(i.MerchantSpecificIdentificationIn...))
	}
	if len(i.MerchantSpecificIdentificationNotIn) > 0 {
		predicates = append(predicates, discountoffer.MerchantSpecificIdentificationNotIn(i.MerchantSpecificIdentificationNotIn...))
	}
	if i.MerchantSpecificIdentificationGT != nil {
		predicates = append(predicates, discountoffer.MerchantSpecificIdentificationGT(*i.MerchantSpecificIdentificationGT))
	}
	if i.MerchantSpecificIdentificationGTE != nil {
		predicates = append(predicates, discountoffer.MerchantSpecificIdentificationGTE(*i.MerchantSpecificIdentificationGTE))
	}
	if i.MerchantSpecificIdentificationLT != nil {
		predicates = append(predicates, discountoffer.MerchantSpecificIdentificationLT(*i.MerchantSpecificIdentificationLT))
	}
	if i.MerchantSpecificIdentificationLTE != nil {
		predicates = append(predicates, discountoffer.MerchantSpecificIdentificationLTE(*i.MerchantSpecificIdentificationLTE))
	}
	if i.MerchantSpecificIdentificationContains != nil {
		predicates = append(predicates, discountoffer.MerchantSpecificIdentificationContains(*i.MerchantSpecificIdentificationContains))
	}
	if i.MerchantSpecificIdentificationHasPrefix != nil {
		predicates = append(predicates, discountoffer.MerchantSpecificIdentificationHasPrefix(*i.MerchantSpecificIdentificationHasPrefix))
	}
	if i.MerchantSpecificIdentificationHasSuffix != nil {
		predicates = append(predicates, discountoffer.MerchantSpecificIdentificationHasSuffix(*i.MerchantSpecificIdentificationHasSuffix))
	}
	if i.MerchantSpecificIdentificationEqualFold != nil {
		predicates = append(predicates, discountoffer.MerchantSpecificIdentificationEqualFold(*i.MerchantSpecificIdentificationEqualFold))
	}
	if i.MerchantSpecificIdentificationContainsFold != nil {
		predicates = append(predicates, discountoffer.MerchantSpecificIdentificationContainsFold(*i.MerchantSpecificIdentificationContainsFold))
	}
	if i.CreatedAt != nil {
		predicates = append(predicates, discountoffer.CreatedAtEQ(*i.CreatedAt))
	}
	if i.CreatedAtNEQ != nil {
		predicates = append(predicates, discountoffer.CreatedAtNEQ(*i.CreatedAtNEQ))
	}
	if len(i.CreatedAtIn) > 0 {
		predicates = append(predicates, discountoffer.CreatedAtIn(i.CreatedAtIn...))
	}
	if len(i.CreatedAtNotIn) > 0 {
		predicates = append(predicates, discountoffer.CreatedAtNotIn(i.CreatedAtNotIn...))
	}
	if i.CreatedAtGT != nil {
		predicates = append(predicates, discountoffer.CreatedAtGT(*i.CreatedAtGT))
	}
	if i.CreatedAtGTE != nil {
		predicates = append(predicates, discountoffer.CreatedAtGTE(*i.CreatedAtGTE))
	}
	if i.CreatedAtLT != nil {
		predicates = append(predicates, discountoffer.CreatedAtLT(*i.CreatedAtLT))
	}
	if i.CreatedAtLTE != nil {
		predicates = append(predicates, discountoffer.CreatedAtLTE(*i.CreatedAtLTE))
	}
	if i.ExpiresAt != nil {
		predicates = append(predicates, discountoffer.ExpiresAtEQ(*i.ExpiresAt))
	}
	if i.ExpiresAtNEQ != nil {
		predicates = append(predicates, discountoffer.ExpiresAtNEQ(*i.ExpiresAtNEQ))
	}
	if len(i.ExpiresAtIn) > 0 {
		predicates = append(predicates, discountoffer.ExpiresAtIn(i.ExpiresAtIn...))
	}
	if len(i.ExpiresAtNotIn) > 0 {
		predicates = append(predicates, discountoffer.ExpiresAtNotIn(i.ExpiresAtNotIn...))
	}
	if i.ExpiresAtGT != nil {
		predicates = append(predicates, discountoffer.ExpiresAtGT(*i.ExpiresAtGT))
	}
	if i.ExpiresAtGTE != nil {
		predicates = append(predicates, discountoffer.ExpiresAtGTE(*i.ExpiresAtGTE))
	}
	if i.ExpiresAtLT != nil {
		predicates = append(predicates, discountoffer.ExpiresAtLT(*i.ExpiresAtLT))
	}
	if i.ExpiresAtLTE != nil {
		predicates = append(predicates, discountoffer.ExpiresAtLTE(*i.ExpiresAtLTE))
	}

	if i.HasOwnerMerchant != nil {
		p := discountoffer.HasOwnerMerchant()
		if !*i.HasOwnerMerchant {
			p = discountoffer.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasOwnerMerchantWith) > 0 {
		with := make([]predicate.Merchant, 0, len(i.HasOwnerMerchantWith))
		for _, w := range i.HasOwnerMerchantWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasOwnerMerchantWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, discountoffer.HasOwnerMerchantWith(with...))
	}
	if i.HasDiscountEligibleUsers != nil {
		p := discountoffer.HasDiscountEligibleUsers()
		if !*i.HasDiscountEligibleUsers {
			p = discountoffer.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasDiscountEligibleUsersWith) > 0 {
		with := make([]predicate.User, 0, len(i.HasDiscountEligibleUsersWith))
		for _, w := range i.HasDiscountEligibleUsersWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasDiscountEligibleUsersWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, discountoffer.HasDiscountEligibleUsersWith(with...))
	}
	if i.HasDiscountOfferNotification != nil {
		p := discountoffer.HasDiscountOfferNotification()
		if !*i.HasDiscountOfferNotification {
			p = discountoffer.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasDiscountOfferNotificationWith) > 0 {
		with := make([]predicate.Notification, 0, len(i.HasDiscountOfferNotificationWith))
		for _, w := range i.HasDiscountOfferNotificationWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasDiscountOfferNotificationWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, discountoffer.HasDiscountOfferNotificationWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyDiscountOfferWhereInput
	case 1:
		return predicates[0], nil
	default:
		return discountoffer.And(predicates...), nil
	}
}

// MerchantWhereInput represents a where input for filtering Merchant queries.
type MerchantWhereInput struct {
	Predicates []predicate.Merchant  `json:"-"`
	Not        *MerchantWhereInput   `json:"not,omitempty"`
	Or         []*MerchantWhereInput `json:"or,omitempty"`
	And        []*MerchantWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *int  `json:"id,omitempty"`
	IDNEQ   *int  `json:"idNEQ,omitempty"`
	IDIn    []int `json:"idIn,omitempty"`
	IDNotIn []int `json:"idNotIn,omitempty"`
	IDGT    *int  `json:"idGT,omitempty"`
	IDGTE   *int  `json:"idGTE,omitempty"`
	IDLT    *int  `json:"idLT,omitempty"`
	IDLTE   *int  `json:"idLTE,omitempty"`

	// "name" field predicates.
	Name             *string  `json:"name,omitempty"`
	NameNEQ          *string  `json:"nameNEQ,omitempty"`
	NameIn           []string `json:"nameIn,omitempty"`
	NameNotIn        []string `json:"nameNotIn,omitempty"`
	NameGT           *string  `json:"nameGT,omitempty"`
	NameGTE          *string  `json:"nameGTE,omitempty"`
	NameLT           *string  `json:"nameLT,omitempty"`
	NameLTE          *string  `json:"nameLTE,omitempty"`
	NameContains     *string  `json:"nameContains,omitempty"`
	NameHasPrefix    *string  `json:"nameHasPrefix,omitempty"`
	NameHasSuffix    *string  `json:"nameHasSuffix,omitempty"`
	NameEqualFold    *string  `json:"nameEqualFold,omitempty"`
	NameContainsFold *string  `json:"nameContainsFold,omitempty"`

	// "discount_offers" edge predicates.
	HasDiscountOffers     *bool                      `json:"hasDiscountOffers,omitempty"`
	HasDiscountOffersWith []*DiscountOfferWhereInput `json:"hasDiscountOffersWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *MerchantWhereInput) AddPredicates(predicates ...predicate.Merchant) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the MerchantWhereInput filter on the MerchantQuery builder.
func (i *MerchantWhereInput) Filter(q *MerchantQuery) (*MerchantQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyMerchantWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyMerchantWhereInput is returned in case the MerchantWhereInput is empty.
var ErrEmptyMerchantWhereInput = errors.New("ent: empty predicate MerchantWhereInput")

// P returns a predicate for filtering merchants.
// An error is returned if the input is empty or invalid.
func (i *MerchantWhereInput) P() (predicate.Merchant, error) {
	var predicates []predicate.Merchant
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, merchant.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.Merchant, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, merchant.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.Merchant, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, merchant.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, merchant.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, merchant.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, merchant.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, merchant.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, merchant.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, merchant.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, merchant.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, merchant.IDLTE(*i.IDLTE))
	}
	if i.Name != nil {
		predicates = append(predicates, merchant.NameEQ(*i.Name))
	}
	if i.NameNEQ != nil {
		predicates = append(predicates, merchant.NameNEQ(*i.NameNEQ))
	}
	if len(i.NameIn) > 0 {
		predicates = append(predicates, merchant.NameIn(i.NameIn...))
	}
	if len(i.NameNotIn) > 0 {
		predicates = append(predicates, merchant.NameNotIn(i.NameNotIn...))
	}
	if i.NameGT != nil {
		predicates = append(predicates, merchant.NameGT(*i.NameGT))
	}
	if i.NameGTE != nil {
		predicates = append(predicates, merchant.NameGTE(*i.NameGTE))
	}
	if i.NameLT != nil {
		predicates = append(predicates, merchant.NameLT(*i.NameLT))
	}
	if i.NameLTE != nil {
		predicates = append(predicates, merchant.NameLTE(*i.NameLTE))
	}
	if i.NameContains != nil {
		predicates = append(predicates, merchant.NameContains(*i.NameContains))
	}
	if i.NameHasPrefix != nil {
		predicates = append(predicates, merchant.NameHasPrefix(*i.NameHasPrefix))
	}
	if i.NameHasSuffix != nil {
		predicates = append(predicates, merchant.NameHasSuffix(*i.NameHasSuffix))
	}
	if i.NameEqualFold != nil {
		predicates = append(predicates, merchant.NameEqualFold(*i.NameEqualFold))
	}
	if i.NameContainsFold != nil {
		predicates = append(predicates, merchant.NameContainsFold(*i.NameContainsFold))
	}

	if i.HasDiscountOffers != nil {
		p := merchant.HasDiscountOffers()
		if !*i.HasDiscountOffers {
			p = merchant.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasDiscountOffersWith) > 0 {
		with := make([]predicate.DiscountOffer, 0, len(i.HasDiscountOffersWith))
		for _, w := range i.HasDiscountOffersWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasDiscountOffersWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, merchant.HasDiscountOffersWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyMerchantWhereInput
	case 1:
		return predicates[0], nil
	default:
		return merchant.And(predicates...), nil
	}
}

// NotificationWhereInput represents a where input for filtering Notification queries.
type NotificationWhereInput struct {
	Predicates []predicate.Notification  `json:"-"`
	Not        *NotificationWhereInput   `json:"not,omitempty"`
	Or         []*NotificationWhereInput `json:"or,omitempty"`
	And        []*NotificationWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *int  `json:"id,omitempty"`
	IDNEQ   *int  `json:"idNEQ,omitempty"`
	IDIn    []int `json:"idIn,omitempty"`
	IDNotIn []int `json:"idNotIn,omitempty"`
	IDGT    *int  `json:"idGT,omitempty"`
	IDGTE   *int  `json:"idGTE,omitempty"`
	IDLT    *int  `json:"idLT,omitempty"`
	IDLTE   *int  `json:"idLTE,omitempty"`

	// "checked_in_app" field predicates.
	CheckedInApp    *bool `json:"checkedInApp,omitempty"`
	CheckedInAppNEQ *bool `json:"checkedInAppNEQ,omitempty"`

	// "type" field predicates.
	Type      *notification.Type  `json:"type,omitempty"`
	TypeNEQ   *notification.Type  `json:"typeNEQ,omitempty"`
	TypeIn    []notification.Type `json:"typeIn,omitempty"`
	TypeNotIn []notification.Type `json:"typeNotIn,omitempty"`

	// "created_at" field predicates.
	CreatedAt      *time.Time  `json:"createdAt,omitempty"`
	CreatedAtNEQ   *time.Time  `json:"createdAtNEQ,omitempty"`
	CreatedAtIn    []time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn []time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGT    *time.Time  `json:"createdAtGT,omitempty"`
	CreatedAtGTE   *time.Time  `json:"createdAtGTE,omitempty"`
	CreatedAtLT    *time.Time  `json:"createdAtLT,omitempty"`
	CreatedAtLTE   *time.Time  `json:"createdAtLTE,omitempty"`

	// "included_in_aggregated_offer_at" field predicates.
	IncludedInAggregatedOfferAt       *time.Time  `json:"includedInAggregatedOfferAt,omitempty"`
	IncludedInAggregatedOfferAtNEQ    *time.Time  `json:"includedInAggregatedOfferAtNEQ,omitempty"`
	IncludedInAggregatedOfferAtIn     []time.Time `json:"includedInAggregatedOfferAtIn,omitempty"`
	IncludedInAggregatedOfferAtNotIn  []time.Time `json:"includedInAggregatedOfferAtNotIn,omitempty"`
	IncludedInAggregatedOfferAtGT     *time.Time  `json:"includedInAggregatedOfferAtGT,omitempty"`
	IncludedInAggregatedOfferAtGTE    *time.Time  `json:"includedInAggregatedOfferAtGTE,omitempty"`
	IncludedInAggregatedOfferAtLT     *time.Time  `json:"includedInAggregatedOfferAtLT,omitempty"`
	IncludedInAggregatedOfferAtLTE    *time.Time  `json:"includedInAggregatedOfferAtLTE,omitempty"`
	IncludedInAggregatedOfferAtIsNil  bool        `json:"includedInAggregatedOfferAtIsNil,omitempty"`
	IncludedInAggregatedOfferAtNotNil bool        `json:"includedInAggregatedOfferAtNotNil,omitempty"`

	// "notification_recipient" edge predicates.
	HasNotificationRecipient     *bool             `json:"hasNotificationRecipient,omitempty"`
	HasNotificationRecipientWith []*UserWhereInput `json:"hasNotificationRecipientWith,omitempty"`

	// "notification_discount_offer" edge predicates.
	HasNotificationDiscountOffer     *bool                      `json:"hasNotificationDiscountOffer,omitempty"`
	HasNotificationDiscountOfferWith []*DiscountOfferWhereInput `json:"hasNotificationDiscountOfferWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *NotificationWhereInput) AddPredicates(predicates ...predicate.Notification) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the NotificationWhereInput filter on the NotificationQuery builder.
func (i *NotificationWhereInput) Filter(q *NotificationQuery) (*NotificationQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyNotificationWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyNotificationWhereInput is returned in case the NotificationWhereInput is empty.
var ErrEmptyNotificationWhereInput = errors.New("ent: empty predicate NotificationWhereInput")

// P returns a predicate for filtering notifications.
// An error is returned if the input is empty or invalid.
func (i *NotificationWhereInput) P() (predicate.Notification, error) {
	var predicates []predicate.Notification
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, notification.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.Notification, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, notification.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.Notification, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, notification.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, notification.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, notification.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, notification.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, notification.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, notification.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, notification.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, notification.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, notification.IDLTE(*i.IDLTE))
	}
	if i.CheckedInApp != nil {
		predicates = append(predicates, notification.CheckedInAppEQ(*i.CheckedInApp))
	}
	if i.CheckedInAppNEQ != nil {
		predicates = append(predicates, notification.CheckedInAppNEQ(*i.CheckedInAppNEQ))
	}
	if i.Type != nil {
		predicates = append(predicates, notification.TypeEQ(*i.Type))
	}
	if i.TypeNEQ != nil {
		predicates = append(predicates, notification.TypeNEQ(*i.TypeNEQ))
	}
	if len(i.TypeIn) > 0 {
		predicates = append(predicates, notification.TypeIn(i.TypeIn...))
	}
	if len(i.TypeNotIn) > 0 {
		predicates = append(predicates, notification.TypeNotIn(i.TypeNotIn...))
	}
	if i.CreatedAt != nil {
		predicates = append(predicates, notification.CreatedAtEQ(*i.CreatedAt))
	}
	if i.CreatedAtNEQ != nil {
		predicates = append(predicates, notification.CreatedAtNEQ(*i.CreatedAtNEQ))
	}
	if len(i.CreatedAtIn) > 0 {
		predicates = append(predicates, notification.CreatedAtIn(i.CreatedAtIn...))
	}
	if len(i.CreatedAtNotIn) > 0 {
		predicates = append(predicates, notification.CreatedAtNotIn(i.CreatedAtNotIn...))
	}
	if i.CreatedAtGT != nil {
		predicates = append(predicates, notification.CreatedAtGT(*i.CreatedAtGT))
	}
	if i.CreatedAtGTE != nil {
		predicates = append(predicates, notification.CreatedAtGTE(*i.CreatedAtGTE))
	}
	if i.CreatedAtLT != nil {
		predicates = append(predicates, notification.CreatedAtLT(*i.CreatedAtLT))
	}
	if i.CreatedAtLTE != nil {
		predicates = append(predicates, notification.CreatedAtLTE(*i.CreatedAtLTE))
	}
	if i.IncludedInAggregatedOfferAt != nil {
		predicates = append(predicates, notification.IncludedInAggregatedOfferAtEQ(*i.IncludedInAggregatedOfferAt))
	}
	if i.IncludedInAggregatedOfferAtNEQ != nil {
		predicates = append(predicates, notification.IncludedInAggregatedOfferAtNEQ(*i.IncludedInAggregatedOfferAtNEQ))
	}
	if len(i.IncludedInAggregatedOfferAtIn) > 0 {
		predicates = append(predicates, notification.IncludedInAggregatedOfferAtIn(i.IncludedInAggregatedOfferAtIn...))
	}
	if len(i.IncludedInAggregatedOfferAtNotIn) > 0 {
		predicates = append(predicates, notification.IncludedInAggregatedOfferAtNotIn(i.IncludedInAggregatedOfferAtNotIn...))
	}
	if i.IncludedInAggregatedOfferAtGT != nil {
		predicates = append(predicates, notification.IncludedInAggregatedOfferAtGT(*i.IncludedInAggregatedOfferAtGT))
	}
	if i.IncludedInAggregatedOfferAtGTE != nil {
		predicates = append(predicates, notification.IncludedInAggregatedOfferAtGTE(*i.IncludedInAggregatedOfferAtGTE))
	}
	if i.IncludedInAggregatedOfferAtLT != nil {
		predicates = append(predicates, notification.IncludedInAggregatedOfferAtLT(*i.IncludedInAggregatedOfferAtLT))
	}
	if i.IncludedInAggregatedOfferAtLTE != nil {
		predicates = append(predicates, notification.IncludedInAggregatedOfferAtLTE(*i.IncludedInAggregatedOfferAtLTE))
	}
	if i.IncludedInAggregatedOfferAtIsNil {
		predicates = append(predicates, notification.IncludedInAggregatedOfferAtIsNil())
	}
	if i.IncludedInAggregatedOfferAtNotNil {
		predicates = append(predicates, notification.IncludedInAggregatedOfferAtNotNil())
	}

	if i.HasNotificationRecipient != nil {
		p := notification.HasNotificationRecipient()
		if !*i.HasNotificationRecipient {
			p = notification.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasNotificationRecipientWith) > 0 {
		with := make([]predicate.User, 0, len(i.HasNotificationRecipientWith))
		for _, w := range i.HasNotificationRecipientWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasNotificationRecipientWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, notification.HasNotificationRecipientWith(with...))
	}
	if i.HasNotificationDiscountOffer != nil {
		p := notification.HasNotificationDiscountOffer()
		if !*i.HasNotificationDiscountOffer {
			p = notification.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasNotificationDiscountOfferWith) > 0 {
		with := make([]predicate.DiscountOffer, 0, len(i.HasNotificationDiscountOfferWith))
		for _, w := range i.HasNotificationDiscountOfferWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasNotificationDiscountOfferWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, notification.HasNotificationDiscountOfferWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyNotificationWhereInput
	case 1:
		return predicates[0], nil
	default:
		return notification.And(predicates...), nil
	}
}

// PlaidInstitutionWhereInput represents a where input for filtering PlaidInstitution queries.
type PlaidInstitutionWhereInput struct {
	Predicates []predicate.PlaidInstitution  `json:"-"`
	Not        *PlaidInstitutionWhereInput   `json:"not,omitempty"`
	Or         []*PlaidInstitutionWhereInput `json:"or,omitempty"`
	And        []*PlaidInstitutionWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *int  `json:"id,omitempty"`
	IDNEQ   *int  `json:"idNEQ,omitempty"`
	IDIn    []int `json:"idIn,omitempty"`
	IDNotIn []int `json:"idNotIn,omitempty"`
	IDGT    *int  `json:"idGT,omitempty"`
	IDGTE   *int  `json:"idGTE,omitempty"`
	IDLT    *int  `json:"idLT,omitempty"`
	IDLTE   *int  `json:"idLTE,omitempty"`

	// "institution_id" field predicates.
	InstitutionID             *string  `json:"institutionID,omitempty"`
	InstitutionIDNEQ          *string  `json:"institutionIDNEQ,omitempty"`
	InstitutionIDIn           []string `json:"institutionIDIn,omitempty"`
	InstitutionIDNotIn        []string `json:"institutionIDNotIn,omitempty"`
	InstitutionIDGT           *string  `json:"institutionIDGT,omitempty"`
	InstitutionIDGTE          *string  `json:"institutionIDGTE,omitempty"`
	InstitutionIDLT           *string  `json:"institutionIDLT,omitempty"`
	InstitutionIDLTE          *string  `json:"institutionIDLTE,omitempty"`
	InstitutionIDContains     *string  `json:"institutionIDContains,omitempty"`
	InstitutionIDHasPrefix    *string  `json:"institutionIDHasPrefix,omitempty"`
	InstitutionIDHasSuffix    *string  `json:"institutionIDHasSuffix,omitempty"`
	InstitutionIDEqualFold    *string  `json:"institutionIDEqualFold,omitempty"`
	InstitutionIDContainsFold *string  `json:"institutionIDContainsFold,omitempty"`

	// "name" field predicates.
	Name             *string  `json:"name,omitempty"`
	NameNEQ          *string  `json:"nameNEQ,omitempty"`
	NameIn           []string `json:"nameIn,omitempty"`
	NameNotIn        []string `json:"nameNotIn,omitempty"`
	NameGT           *string  `json:"nameGT,omitempty"`
	NameGTE          *string  `json:"nameGTE,omitempty"`
	NameLT           *string  `json:"nameLT,omitempty"`
	NameLTE          *string  `json:"nameLTE,omitempty"`
	NameContains     *string  `json:"nameContains,omitempty"`
	NameHasPrefix    *string  `json:"nameHasPrefix,omitempty"`
	NameHasSuffix    *string  `json:"nameHasSuffix,omitempty"`
	NameEqualFold    *string  `json:"nameEqualFold,omitempty"`
	NameContainsFold *string  `json:"nameContainsFold,omitempty"`

	// "plaid_item" edge predicates.
	HasPlaidItem     *bool                  `json:"hasPlaidItem,omitempty"`
	HasPlaidItemWith []*PlaidItemWhereInput `json:"hasPlaidItemWith,omitempty"`

	// "accounts" edge predicates.
	HasAccounts     *bool                                `json:"hasAccounts,omitempty"`
	HasAccountsWith []*PlaidInstitutionAccountWhereInput `json:"hasAccountsWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *PlaidInstitutionWhereInput) AddPredicates(predicates ...predicate.PlaidInstitution) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the PlaidInstitutionWhereInput filter on the PlaidInstitutionQuery builder.
func (i *PlaidInstitutionWhereInput) Filter(q *PlaidInstitutionQuery) (*PlaidInstitutionQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyPlaidInstitutionWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyPlaidInstitutionWhereInput is returned in case the PlaidInstitutionWhereInput is empty.
var ErrEmptyPlaidInstitutionWhereInput = errors.New("ent: empty predicate PlaidInstitutionWhereInput")

// P returns a predicate for filtering plaidinstitutions.
// An error is returned if the input is empty or invalid.
func (i *PlaidInstitutionWhereInput) P() (predicate.PlaidInstitution, error) {
	var predicates []predicate.PlaidInstitution
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, plaidinstitution.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.PlaidInstitution, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, plaidinstitution.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.PlaidInstitution, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, plaidinstitution.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, plaidinstitution.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, plaidinstitution.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, plaidinstitution.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, plaidinstitution.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, plaidinstitution.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, plaidinstitution.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, plaidinstitution.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, plaidinstitution.IDLTE(*i.IDLTE))
	}
	if i.InstitutionID != nil {
		predicates = append(predicates, plaidinstitution.InstitutionIDEQ(*i.InstitutionID))
	}
	if i.InstitutionIDNEQ != nil {
		predicates = append(predicates, plaidinstitution.InstitutionIDNEQ(*i.InstitutionIDNEQ))
	}
	if len(i.InstitutionIDIn) > 0 {
		predicates = append(predicates, plaidinstitution.InstitutionIDIn(i.InstitutionIDIn...))
	}
	if len(i.InstitutionIDNotIn) > 0 {
		predicates = append(predicates, plaidinstitution.InstitutionIDNotIn(i.InstitutionIDNotIn...))
	}
	if i.InstitutionIDGT != nil {
		predicates = append(predicates, plaidinstitution.InstitutionIDGT(*i.InstitutionIDGT))
	}
	if i.InstitutionIDGTE != nil {
		predicates = append(predicates, plaidinstitution.InstitutionIDGTE(*i.InstitutionIDGTE))
	}
	if i.InstitutionIDLT != nil {
		predicates = append(predicates, plaidinstitution.InstitutionIDLT(*i.InstitutionIDLT))
	}
	if i.InstitutionIDLTE != nil {
		predicates = append(predicates, plaidinstitution.InstitutionIDLTE(*i.InstitutionIDLTE))
	}
	if i.InstitutionIDContains != nil {
		predicates = append(predicates, plaidinstitution.InstitutionIDContains(*i.InstitutionIDContains))
	}
	if i.InstitutionIDHasPrefix != nil {
		predicates = append(predicates, plaidinstitution.InstitutionIDHasPrefix(*i.InstitutionIDHasPrefix))
	}
	if i.InstitutionIDHasSuffix != nil {
		predicates = append(predicates, plaidinstitution.InstitutionIDHasSuffix(*i.InstitutionIDHasSuffix))
	}
	if i.InstitutionIDEqualFold != nil {
		predicates = append(predicates, plaidinstitution.InstitutionIDEqualFold(*i.InstitutionIDEqualFold))
	}
	if i.InstitutionIDContainsFold != nil {
		predicates = append(predicates, plaidinstitution.InstitutionIDContainsFold(*i.InstitutionIDContainsFold))
	}
	if i.Name != nil {
		predicates = append(predicates, plaidinstitution.NameEQ(*i.Name))
	}
	if i.NameNEQ != nil {
		predicates = append(predicates, plaidinstitution.NameNEQ(*i.NameNEQ))
	}
	if len(i.NameIn) > 0 {
		predicates = append(predicates, plaidinstitution.NameIn(i.NameIn...))
	}
	if len(i.NameNotIn) > 0 {
		predicates = append(predicates, plaidinstitution.NameNotIn(i.NameNotIn...))
	}
	if i.NameGT != nil {
		predicates = append(predicates, plaidinstitution.NameGT(*i.NameGT))
	}
	if i.NameGTE != nil {
		predicates = append(predicates, plaidinstitution.NameGTE(*i.NameGTE))
	}
	if i.NameLT != nil {
		predicates = append(predicates, plaidinstitution.NameLT(*i.NameLT))
	}
	if i.NameLTE != nil {
		predicates = append(predicates, plaidinstitution.NameLTE(*i.NameLTE))
	}
	if i.NameContains != nil {
		predicates = append(predicates, plaidinstitution.NameContains(*i.NameContains))
	}
	if i.NameHasPrefix != nil {
		predicates = append(predicates, plaidinstitution.NameHasPrefix(*i.NameHasPrefix))
	}
	if i.NameHasSuffix != nil {
		predicates = append(predicates, plaidinstitution.NameHasSuffix(*i.NameHasSuffix))
	}
	if i.NameEqualFold != nil {
		predicates = append(predicates, plaidinstitution.NameEqualFold(*i.NameEqualFold))
	}
	if i.NameContainsFold != nil {
		predicates = append(predicates, plaidinstitution.NameContainsFold(*i.NameContainsFold))
	}

	if i.HasPlaidItem != nil {
		p := plaidinstitution.HasPlaidItem()
		if !*i.HasPlaidItem {
			p = plaidinstitution.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasPlaidItemWith) > 0 {
		with := make([]predicate.PlaidItem, 0, len(i.HasPlaidItemWith))
		for _, w := range i.HasPlaidItemWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasPlaidItemWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, plaidinstitution.HasPlaidItemWith(with...))
	}
	if i.HasAccounts != nil {
		p := plaidinstitution.HasAccounts()
		if !*i.HasAccounts {
			p = plaidinstitution.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasAccountsWith) > 0 {
		with := make([]predicate.PlaidInstitutionAccount, 0, len(i.HasAccountsWith))
		for _, w := range i.HasAccountsWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasAccountsWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, plaidinstitution.HasAccountsWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyPlaidInstitutionWhereInput
	case 1:
		return predicates[0], nil
	default:
		return plaidinstitution.And(predicates...), nil
	}
}

// PlaidInstitutionAccountWhereInput represents a where input for filtering PlaidInstitutionAccount queries.
type PlaidInstitutionAccountWhereInput struct {
	Predicates []predicate.PlaidInstitutionAccount  `json:"-"`
	Not        *PlaidInstitutionAccountWhereInput   `json:"not,omitempty"`
	Or         []*PlaidInstitutionAccountWhereInput `json:"or,omitempty"`
	And        []*PlaidInstitutionAccountWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *int  `json:"id,omitempty"`
	IDNEQ   *int  `json:"idNEQ,omitempty"`
	IDIn    []int `json:"idIn,omitempty"`
	IDNotIn []int `json:"idNotIn,omitempty"`
	IDGT    *int  `json:"idGT,omitempty"`
	IDGTE   *int  `json:"idGTE,omitempty"`
	IDLT    *int  `json:"idLT,omitempty"`
	IDLTE   *int  `json:"idLTE,omitempty"`

	// "account_id" field predicates.
	AccountID             *string  `json:"accountID,omitempty"`
	AccountIDNEQ          *string  `json:"accountIDNEQ,omitempty"`
	AccountIDIn           []string `json:"accountIDIn,omitempty"`
	AccountIDNotIn        []string `json:"accountIDNotIn,omitempty"`
	AccountIDGT           *string  `json:"accountIDGT,omitempty"`
	AccountIDGTE          *string  `json:"accountIDGTE,omitempty"`
	AccountIDLT           *string  `json:"accountIDLT,omitempty"`
	AccountIDLTE          *string  `json:"accountIDLTE,omitempty"`
	AccountIDContains     *string  `json:"accountIDContains,omitempty"`
	AccountIDHasPrefix    *string  `json:"accountIDHasPrefix,omitempty"`
	AccountIDHasSuffix    *string  `json:"accountIDHasSuffix,omitempty"`
	AccountIDEqualFold    *string  `json:"accountIDEqualFold,omitempty"`
	AccountIDContainsFold *string  `json:"accountIDContainsFold,omitempty"`

	// "balance_available" field predicates.
	BalanceAvailable      *float64  `json:"balanceAvailable,omitempty"`
	BalanceAvailableNEQ   *float64  `json:"balanceAvailableNEQ,omitempty"`
	BalanceAvailableIn    []float64 `json:"balanceAvailableIn,omitempty"`
	BalanceAvailableNotIn []float64 `json:"balanceAvailableNotIn,omitempty"`
	BalanceAvailableGT    *float64  `json:"balanceAvailableGT,omitempty"`
	BalanceAvailableGTE   *float64  `json:"balanceAvailableGTE,omitempty"`
	BalanceAvailableLT    *float64  `json:"balanceAvailableLT,omitempty"`
	BalanceAvailableLTE   *float64  `json:"balanceAvailableLTE,omitempty"`

	// "balance_current" field predicates.
	BalanceCurrent      *float64  `json:"balanceCurrent,omitempty"`
	BalanceCurrentNEQ   *float64  `json:"balanceCurrentNEQ,omitempty"`
	BalanceCurrentIn    []float64 `json:"balanceCurrentIn,omitempty"`
	BalanceCurrentNotIn []float64 `json:"balanceCurrentNotIn,omitempty"`
	BalanceCurrentGT    *float64  `json:"balanceCurrentGT,omitempty"`
	BalanceCurrentGTE   *float64  `json:"balanceCurrentGTE,omitempty"`
	BalanceCurrentLT    *float64  `json:"balanceCurrentLT,omitempty"`
	BalanceCurrentLTE   *float64  `json:"balanceCurrentLTE,omitempty"`

	// "balance_iso_currency_code" field predicates.
	BalanceIsoCurrencyCode             *string  `json:"balanceIsoCurrencyCode,omitempty"`
	BalanceIsoCurrencyCodeNEQ          *string  `json:"balanceIsoCurrencyCodeNEQ,omitempty"`
	BalanceIsoCurrencyCodeIn           []string `json:"balanceIsoCurrencyCodeIn,omitempty"`
	BalanceIsoCurrencyCodeNotIn        []string `json:"balanceIsoCurrencyCodeNotIn,omitempty"`
	BalanceIsoCurrencyCodeGT           *string  `json:"balanceIsoCurrencyCodeGT,omitempty"`
	BalanceIsoCurrencyCodeGTE          *string  `json:"balanceIsoCurrencyCodeGTE,omitempty"`
	BalanceIsoCurrencyCodeLT           *string  `json:"balanceIsoCurrencyCodeLT,omitempty"`
	BalanceIsoCurrencyCodeLTE          *string  `json:"balanceIsoCurrencyCodeLTE,omitempty"`
	BalanceIsoCurrencyCodeContains     *string  `json:"balanceIsoCurrencyCodeContains,omitempty"`
	BalanceIsoCurrencyCodeHasPrefix    *string  `json:"balanceIsoCurrencyCodeHasPrefix,omitempty"`
	BalanceIsoCurrencyCodeHasSuffix    *string  `json:"balanceIsoCurrencyCodeHasSuffix,omitempty"`
	BalanceIsoCurrencyCodeEqualFold    *string  `json:"balanceIsoCurrencyCodeEqualFold,omitempty"`
	BalanceIsoCurrencyCodeContainsFold *string  `json:"balanceIsoCurrencyCodeContainsFold,omitempty"`

	// "mask" field predicates.
	Mask             *string  `json:"mask,omitempty"`
	MaskNEQ          *string  `json:"maskNEQ,omitempty"`
	MaskIn           []string `json:"maskIn,omitempty"`
	MaskNotIn        []string `json:"maskNotIn,omitempty"`
	MaskGT           *string  `json:"maskGT,omitempty"`
	MaskGTE          *string  `json:"maskGTE,omitempty"`
	MaskLT           *string  `json:"maskLT,omitempty"`
	MaskLTE          *string  `json:"maskLTE,omitempty"`
	MaskContains     *string  `json:"maskContains,omitempty"`
	MaskHasPrefix    *string  `json:"maskHasPrefix,omitempty"`
	MaskHasSuffix    *string  `json:"maskHasSuffix,omitempty"`
	MaskEqualFold    *string  `json:"maskEqualFold,omitempty"`
	MaskContainsFold *string  `json:"maskContainsFold,omitempty"`

	// "name" field predicates.
	Name             *string  `json:"name,omitempty"`
	NameNEQ          *string  `json:"nameNEQ,omitempty"`
	NameIn           []string `json:"nameIn,omitempty"`
	NameNotIn        []string `json:"nameNotIn,omitempty"`
	NameGT           *string  `json:"nameGT,omitempty"`
	NameGTE          *string  `json:"nameGTE,omitempty"`
	NameLT           *string  `json:"nameLT,omitempty"`
	NameLTE          *string  `json:"nameLTE,omitempty"`
	NameContains     *string  `json:"nameContains,omitempty"`
	NameHasPrefix    *string  `json:"nameHasPrefix,omitempty"`
	NameHasSuffix    *string  `json:"nameHasSuffix,omitempty"`
	NameEqualFold    *string  `json:"nameEqualFold,omitempty"`
	NameContainsFold *string  `json:"nameContainsFold,omitempty"`

	// "official_name" field predicates.
	OfficialName             *string  `json:"officialName,omitempty"`
	OfficialNameNEQ          *string  `json:"officialNameNEQ,omitempty"`
	OfficialNameIn           []string `json:"officialNameIn,omitempty"`
	OfficialNameNotIn        []string `json:"officialNameNotIn,omitempty"`
	OfficialNameGT           *string  `json:"officialNameGT,omitempty"`
	OfficialNameGTE          *string  `json:"officialNameGTE,omitempty"`
	OfficialNameLT           *string  `json:"officialNameLT,omitempty"`
	OfficialNameLTE          *string  `json:"officialNameLTE,omitempty"`
	OfficialNameContains     *string  `json:"officialNameContains,omitempty"`
	OfficialNameHasPrefix    *string  `json:"officialNameHasPrefix,omitempty"`
	OfficialNameHasSuffix    *string  `json:"officialNameHasSuffix,omitempty"`
	OfficialNameIsNil        bool     `json:"officialNameIsNil,omitempty"`
	OfficialNameNotNil       bool     `json:"officialNameNotNil,omitempty"`
	OfficialNameEqualFold    *string  `json:"officialNameEqualFold,omitempty"`
	OfficialNameContainsFold *string  `json:"officialNameContainsFold,omitempty"`

	// "type" field predicates.
	Type             *string  `json:"type,omitempty"`
	TypeNEQ          *string  `json:"typeNEQ,omitempty"`
	TypeIn           []string `json:"typeIn,omitempty"`
	TypeNotIn        []string `json:"typeNotIn,omitempty"`
	TypeGT           *string  `json:"typeGT,omitempty"`
	TypeGTE          *string  `json:"typeGTE,omitempty"`
	TypeLT           *string  `json:"typeLT,omitempty"`
	TypeLTE          *string  `json:"typeLTE,omitempty"`
	TypeContains     *string  `json:"typeContains,omitempty"`
	TypeHasPrefix    *string  `json:"typeHasPrefix,omitempty"`
	TypeHasSuffix    *string  `json:"typeHasSuffix,omitempty"`
	TypeEqualFold    *string  `json:"typeEqualFold,omitempty"`
	TypeContainsFold *string  `json:"typeContainsFold,omitempty"`

	// "parent_institution" edge predicates.
	HasParentInstitution     *bool                         `json:"hasParentInstitution,omitempty"`
	HasParentInstitutionWith []*PlaidInstitutionWhereInput `json:"hasParentInstitutionWith,omitempty"`

	// "transactions" edge predicates.
	HasTransactions     *bool                    `json:"hasTransactions,omitempty"`
	HasTransactionsWith []*TransactionWhereInput `json:"hasTransactionsWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *PlaidInstitutionAccountWhereInput) AddPredicates(predicates ...predicate.PlaidInstitutionAccount) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the PlaidInstitutionAccountWhereInput filter on the PlaidInstitutionAccountQuery builder.
func (i *PlaidInstitutionAccountWhereInput) Filter(q *PlaidInstitutionAccountQuery) (*PlaidInstitutionAccountQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyPlaidInstitutionAccountWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyPlaidInstitutionAccountWhereInput is returned in case the PlaidInstitutionAccountWhereInput is empty.
var ErrEmptyPlaidInstitutionAccountWhereInput = errors.New("ent: empty predicate PlaidInstitutionAccountWhereInput")

// P returns a predicate for filtering plaidinstitutionaccounts.
// An error is returned if the input is empty or invalid.
func (i *PlaidInstitutionAccountWhereInput) P() (predicate.PlaidInstitutionAccount, error) {
	var predicates []predicate.PlaidInstitutionAccount
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, plaidinstitutionaccount.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.PlaidInstitutionAccount, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, plaidinstitutionaccount.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.PlaidInstitutionAccount, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, plaidinstitutionaccount.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, plaidinstitutionaccount.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, plaidinstitutionaccount.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, plaidinstitutionaccount.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, plaidinstitutionaccount.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, plaidinstitutionaccount.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, plaidinstitutionaccount.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, plaidinstitutionaccount.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, plaidinstitutionaccount.IDLTE(*i.IDLTE))
	}
	if i.AccountID != nil {
		predicates = append(predicates, plaidinstitutionaccount.AccountIDEQ(*i.AccountID))
	}
	if i.AccountIDNEQ != nil {
		predicates = append(predicates, plaidinstitutionaccount.AccountIDNEQ(*i.AccountIDNEQ))
	}
	if len(i.AccountIDIn) > 0 {
		predicates = append(predicates, plaidinstitutionaccount.AccountIDIn(i.AccountIDIn...))
	}
	if len(i.AccountIDNotIn) > 0 {
		predicates = append(predicates, plaidinstitutionaccount.AccountIDNotIn(i.AccountIDNotIn...))
	}
	if i.AccountIDGT != nil {
		predicates = append(predicates, plaidinstitutionaccount.AccountIDGT(*i.AccountIDGT))
	}
	if i.AccountIDGTE != nil {
		predicates = append(predicates, plaidinstitutionaccount.AccountIDGTE(*i.AccountIDGTE))
	}
	if i.AccountIDLT != nil {
		predicates = append(predicates, plaidinstitutionaccount.AccountIDLT(*i.AccountIDLT))
	}
	if i.AccountIDLTE != nil {
		predicates = append(predicates, plaidinstitutionaccount.AccountIDLTE(*i.AccountIDLTE))
	}
	if i.AccountIDContains != nil {
		predicates = append(predicates, plaidinstitutionaccount.AccountIDContains(*i.AccountIDContains))
	}
	if i.AccountIDHasPrefix != nil {
		predicates = append(predicates, plaidinstitutionaccount.AccountIDHasPrefix(*i.AccountIDHasPrefix))
	}
	if i.AccountIDHasSuffix != nil {
		predicates = append(predicates, plaidinstitutionaccount.AccountIDHasSuffix(*i.AccountIDHasSuffix))
	}
	if i.AccountIDEqualFold != nil {
		predicates = append(predicates, plaidinstitutionaccount.AccountIDEqualFold(*i.AccountIDEqualFold))
	}
	if i.AccountIDContainsFold != nil {
		predicates = append(predicates, plaidinstitutionaccount.AccountIDContainsFold(*i.AccountIDContainsFold))
	}
	if i.BalanceAvailable != nil {
		predicates = append(predicates, plaidinstitutionaccount.BalanceAvailableEQ(*i.BalanceAvailable))
	}
	if i.BalanceAvailableNEQ != nil {
		predicates = append(predicates, plaidinstitutionaccount.BalanceAvailableNEQ(*i.BalanceAvailableNEQ))
	}
	if len(i.BalanceAvailableIn) > 0 {
		predicates = append(predicates, plaidinstitutionaccount.BalanceAvailableIn(i.BalanceAvailableIn...))
	}
	if len(i.BalanceAvailableNotIn) > 0 {
		predicates = append(predicates, plaidinstitutionaccount.BalanceAvailableNotIn(i.BalanceAvailableNotIn...))
	}
	if i.BalanceAvailableGT != nil {
		predicates = append(predicates, plaidinstitutionaccount.BalanceAvailableGT(*i.BalanceAvailableGT))
	}
	if i.BalanceAvailableGTE != nil {
		predicates = append(predicates, plaidinstitutionaccount.BalanceAvailableGTE(*i.BalanceAvailableGTE))
	}
	if i.BalanceAvailableLT != nil {
		predicates = append(predicates, plaidinstitutionaccount.BalanceAvailableLT(*i.BalanceAvailableLT))
	}
	if i.BalanceAvailableLTE != nil {
		predicates = append(predicates, plaidinstitutionaccount.BalanceAvailableLTE(*i.BalanceAvailableLTE))
	}
	if i.BalanceCurrent != nil {
		predicates = append(predicates, plaidinstitutionaccount.BalanceCurrentEQ(*i.BalanceCurrent))
	}
	if i.BalanceCurrentNEQ != nil {
		predicates = append(predicates, plaidinstitutionaccount.BalanceCurrentNEQ(*i.BalanceCurrentNEQ))
	}
	if len(i.BalanceCurrentIn) > 0 {
		predicates = append(predicates, plaidinstitutionaccount.BalanceCurrentIn(i.BalanceCurrentIn...))
	}
	if len(i.BalanceCurrentNotIn) > 0 {
		predicates = append(predicates, plaidinstitutionaccount.BalanceCurrentNotIn(i.BalanceCurrentNotIn...))
	}
	if i.BalanceCurrentGT != nil {
		predicates = append(predicates, plaidinstitutionaccount.BalanceCurrentGT(*i.BalanceCurrentGT))
	}
	if i.BalanceCurrentGTE != nil {
		predicates = append(predicates, plaidinstitutionaccount.BalanceCurrentGTE(*i.BalanceCurrentGTE))
	}
	if i.BalanceCurrentLT != nil {
		predicates = append(predicates, plaidinstitutionaccount.BalanceCurrentLT(*i.BalanceCurrentLT))
	}
	if i.BalanceCurrentLTE != nil {
		predicates = append(predicates, plaidinstitutionaccount.BalanceCurrentLTE(*i.BalanceCurrentLTE))
	}
	if i.BalanceIsoCurrencyCode != nil {
		predicates = append(predicates, plaidinstitutionaccount.BalanceIsoCurrencyCodeEQ(*i.BalanceIsoCurrencyCode))
	}
	if i.BalanceIsoCurrencyCodeNEQ != nil {
		predicates = append(predicates, plaidinstitutionaccount.BalanceIsoCurrencyCodeNEQ(*i.BalanceIsoCurrencyCodeNEQ))
	}
	if len(i.BalanceIsoCurrencyCodeIn) > 0 {
		predicates = append(predicates, plaidinstitutionaccount.BalanceIsoCurrencyCodeIn(i.BalanceIsoCurrencyCodeIn...))
	}
	if len(i.BalanceIsoCurrencyCodeNotIn) > 0 {
		predicates = append(predicates, plaidinstitutionaccount.BalanceIsoCurrencyCodeNotIn(i.BalanceIsoCurrencyCodeNotIn...))
	}
	if i.BalanceIsoCurrencyCodeGT != nil {
		predicates = append(predicates, plaidinstitutionaccount.BalanceIsoCurrencyCodeGT(*i.BalanceIsoCurrencyCodeGT))
	}
	if i.BalanceIsoCurrencyCodeGTE != nil {
		predicates = append(predicates, plaidinstitutionaccount.BalanceIsoCurrencyCodeGTE(*i.BalanceIsoCurrencyCodeGTE))
	}
	if i.BalanceIsoCurrencyCodeLT != nil {
		predicates = append(predicates, plaidinstitutionaccount.BalanceIsoCurrencyCodeLT(*i.BalanceIsoCurrencyCodeLT))
	}
	if i.BalanceIsoCurrencyCodeLTE != nil {
		predicates = append(predicates, plaidinstitutionaccount.BalanceIsoCurrencyCodeLTE(*i.BalanceIsoCurrencyCodeLTE))
	}
	if i.BalanceIsoCurrencyCodeContains != nil {
		predicates = append(predicates, plaidinstitutionaccount.BalanceIsoCurrencyCodeContains(*i.BalanceIsoCurrencyCodeContains))
	}
	if i.BalanceIsoCurrencyCodeHasPrefix != nil {
		predicates = append(predicates, plaidinstitutionaccount.BalanceIsoCurrencyCodeHasPrefix(*i.BalanceIsoCurrencyCodeHasPrefix))
	}
	if i.BalanceIsoCurrencyCodeHasSuffix != nil {
		predicates = append(predicates, plaidinstitutionaccount.BalanceIsoCurrencyCodeHasSuffix(*i.BalanceIsoCurrencyCodeHasSuffix))
	}
	if i.BalanceIsoCurrencyCodeEqualFold != nil {
		predicates = append(predicates, plaidinstitutionaccount.BalanceIsoCurrencyCodeEqualFold(*i.BalanceIsoCurrencyCodeEqualFold))
	}
	if i.BalanceIsoCurrencyCodeContainsFold != nil {
		predicates = append(predicates, plaidinstitutionaccount.BalanceIsoCurrencyCodeContainsFold(*i.BalanceIsoCurrencyCodeContainsFold))
	}
	if i.Mask != nil {
		predicates = append(predicates, plaidinstitutionaccount.MaskEQ(*i.Mask))
	}
	if i.MaskNEQ != nil {
		predicates = append(predicates, plaidinstitutionaccount.MaskNEQ(*i.MaskNEQ))
	}
	if len(i.MaskIn) > 0 {
		predicates = append(predicates, plaidinstitutionaccount.MaskIn(i.MaskIn...))
	}
	if len(i.MaskNotIn) > 0 {
		predicates = append(predicates, plaidinstitutionaccount.MaskNotIn(i.MaskNotIn...))
	}
	if i.MaskGT != nil {
		predicates = append(predicates, plaidinstitutionaccount.MaskGT(*i.MaskGT))
	}
	if i.MaskGTE != nil {
		predicates = append(predicates, plaidinstitutionaccount.MaskGTE(*i.MaskGTE))
	}
	if i.MaskLT != nil {
		predicates = append(predicates, plaidinstitutionaccount.MaskLT(*i.MaskLT))
	}
	if i.MaskLTE != nil {
		predicates = append(predicates, plaidinstitutionaccount.MaskLTE(*i.MaskLTE))
	}
	if i.MaskContains != nil {
		predicates = append(predicates, plaidinstitutionaccount.MaskContains(*i.MaskContains))
	}
	if i.MaskHasPrefix != nil {
		predicates = append(predicates, plaidinstitutionaccount.MaskHasPrefix(*i.MaskHasPrefix))
	}
	if i.MaskHasSuffix != nil {
		predicates = append(predicates, plaidinstitutionaccount.MaskHasSuffix(*i.MaskHasSuffix))
	}
	if i.MaskEqualFold != nil {
		predicates = append(predicates, plaidinstitutionaccount.MaskEqualFold(*i.MaskEqualFold))
	}
	if i.MaskContainsFold != nil {
		predicates = append(predicates, plaidinstitutionaccount.MaskContainsFold(*i.MaskContainsFold))
	}
	if i.Name != nil {
		predicates = append(predicates, plaidinstitutionaccount.NameEQ(*i.Name))
	}
	if i.NameNEQ != nil {
		predicates = append(predicates, plaidinstitutionaccount.NameNEQ(*i.NameNEQ))
	}
	if len(i.NameIn) > 0 {
		predicates = append(predicates, plaidinstitutionaccount.NameIn(i.NameIn...))
	}
	if len(i.NameNotIn) > 0 {
		predicates = append(predicates, plaidinstitutionaccount.NameNotIn(i.NameNotIn...))
	}
	if i.NameGT != nil {
		predicates = append(predicates, plaidinstitutionaccount.NameGT(*i.NameGT))
	}
	if i.NameGTE != nil {
		predicates = append(predicates, plaidinstitutionaccount.NameGTE(*i.NameGTE))
	}
	if i.NameLT != nil {
		predicates = append(predicates, plaidinstitutionaccount.NameLT(*i.NameLT))
	}
	if i.NameLTE != nil {
		predicates = append(predicates, plaidinstitutionaccount.NameLTE(*i.NameLTE))
	}
	if i.NameContains != nil {
		predicates = append(predicates, plaidinstitutionaccount.NameContains(*i.NameContains))
	}
	if i.NameHasPrefix != nil {
		predicates = append(predicates, plaidinstitutionaccount.NameHasPrefix(*i.NameHasPrefix))
	}
	if i.NameHasSuffix != nil {
		predicates = append(predicates, plaidinstitutionaccount.NameHasSuffix(*i.NameHasSuffix))
	}
	if i.NameEqualFold != nil {
		predicates = append(predicates, plaidinstitutionaccount.NameEqualFold(*i.NameEqualFold))
	}
	if i.NameContainsFold != nil {
		predicates = append(predicates, plaidinstitutionaccount.NameContainsFold(*i.NameContainsFold))
	}
	if i.OfficialName != nil {
		predicates = append(predicates, plaidinstitutionaccount.OfficialNameEQ(*i.OfficialName))
	}
	if i.OfficialNameNEQ != nil {
		predicates = append(predicates, plaidinstitutionaccount.OfficialNameNEQ(*i.OfficialNameNEQ))
	}
	if len(i.OfficialNameIn) > 0 {
		predicates = append(predicates, plaidinstitutionaccount.OfficialNameIn(i.OfficialNameIn...))
	}
	if len(i.OfficialNameNotIn) > 0 {
		predicates = append(predicates, plaidinstitutionaccount.OfficialNameNotIn(i.OfficialNameNotIn...))
	}
	if i.OfficialNameGT != nil {
		predicates = append(predicates, plaidinstitutionaccount.OfficialNameGT(*i.OfficialNameGT))
	}
	if i.OfficialNameGTE != nil {
		predicates = append(predicates, plaidinstitutionaccount.OfficialNameGTE(*i.OfficialNameGTE))
	}
	if i.OfficialNameLT != nil {
		predicates = append(predicates, plaidinstitutionaccount.OfficialNameLT(*i.OfficialNameLT))
	}
	if i.OfficialNameLTE != nil {
		predicates = append(predicates, plaidinstitutionaccount.OfficialNameLTE(*i.OfficialNameLTE))
	}
	if i.OfficialNameContains != nil {
		predicates = append(predicates, plaidinstitutionaccount.OfficialNameContains(*i.OfficialNameContains))
	}
	if i.OfficialNameHasPrefix != nil {
		predicates = append(predicates, plaidinstitutionaccount.OfficialNameHasPrefix(*i.OfficialNameHasPrefix))
	}
	if i.OfficialNameHasSuffix != nil {
		predicates = append(predicates, plaidinstitutionaccount.OfficialNameHasSuffix(*i.OfficialNameHasSuffix))
	}
	if i.OfficialNameIsNil {
		predicates = append(predicates, plaidinstitutionaccount.OfficialNameIsNil())
	}
	if i.OfficialNameNotNil {
		predicates = append(predicates, plaidinstitutionaccount.OfficialNameNotNil())
	}
	if i.OfficialNameEqualFold != nil {
		predicates = append(predicates, plaidinstitutionaccount.OfficialNameEqualFold(*i.OfficialNameEqualFold))
	}
	if i.OfficialNameContainsFold != nil {
		predicates = append(predicates, plaidinstitutionaccount.OfficialNameContainsFold(*i.OfficialNameContainsFold))
	}
	if i.Type != nil {
		predicates = append(predicates, plaidinstitutionaccount.TypeEQ(*i.Type))
	}
	if i.TypeNEQ != nil {
		predicates = append(predicates, plaidinstitutionaccount.TypeNEQ(*i.TypeNEQ))
	}
	if len(i.TypeIn) > 0 {
		predicates = append(predicates, plaidinstitutionaccount.TypeIn(i.TypeIn...))
	}
	if len(i.TypeNotIn) > 0 {
		predicates = append(predicates, plaidinstitutionaccount.TypeNotIn(i.TypeNotIn...))
	}
	if i.TypeGT != nil {
		predicates = append(predicates, plaidinstitutionaccount.TypeGT(*i.TypeGT))
	}
	if i.TypeGTE != nil {
		predicates = append(predicates, plaidinstitutionaccount.TypeGTE(*i.TypeGTE))
	}
	if i.TypeLT != nil {
		predicates = append(predicates, plaidinstitutionaccount.TypeLT(*i.TypeLT))
	}
	if i.TypeLTE != nil {
		predicates = append(predicates, plaidinstitutionaccount.TypeLTE(*i.TypeLTE))
	}
	if i.TypeContains != nil {
		predicates = append(predicates, plaidinstitutionaccount.TypeContains(*i.TypeContains))
	}
	if i.TypeHasPrefix != nil {
		predicates = append(predicates, plaidinstitutionaccount.TypeHasPrefix(*i.TypeHasPrefix))
	}
	if i.TypeHasSuffix != nil {
		predicates = append(predicates, plaidinstitutionaccount.TypeHasSuffix(*i.TypeHasSuffix))
	}
	if i.TypeEqualFold != nil {
		predicates = append(predicates, plaidinstitutionaccount.TypeEqualFold(*i.TypeEqualFold))
	}
	if i.TypeContainsFold != nil {
		predicates = append(predicates, plaidinstitutionaccount.TypeContainsFold(*i.TypeContainsFold))
	}

	if i.HasParentInstitution != nil {
		p := plaidinstitutionaccount.HasParentInstitution()
		if !*i.HasParentInstitution {
			p = plaidinstitutionaccount.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasParentInstitutionWith) > 0 {
		with := make([]predicate.PlaidInstitution, 0, len(i.HasParentInstitutionWith))
		for _, w := range i.HasParentInstitutionWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasParentInstitutionWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, plaidinstitutionaccount.HasParentInstitutionWith(with...))
	}
	if i.HasTransactions != nil {
		p := plaidinstitutionaccount.HasTransactions()
		if !*i.HasTransactions {
			p = plaidinstitutionaccount.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasTransactionsWith) > 0 {
		with := make([]predicate.Transaction, 0, len(i.HasTransactionsWith))
		for _, w := range i.HasTransactionsWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasTransactionsWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, plaidinstitutionaccount.HasTransactionsWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyPlaidInstitutionAccountWhereInput
	case 1:
		return predicates[0], nil
	default:
		return plaidinstitutionaccount.And(predicates...), nil
	}
}

// PlaidItemWhereInput represents a where input for filtering PlaidItem queries.
type PlaidItemWhereInput struct {
	Predicates []predicate.PlaidItem  `json:"-"`
	Not        *PlaidItemWhereInput   `json:"not,omitempty"`
	Or         []*PlaidItemWhereInput `json:"or,omitempty"`
	And        []*PlaidItemWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *int  `json:"id,omitempty"`
	IDNEQ   *int  `json:"idNEQ,omitempty"`
	IDIn    []int `json:"idIn,omitempty"`
	IDNotIn []int `json:"idNotIn,omitempty"`
	IDGT    *int  `json:"idGT,omitempty"`
	IDGTE   *int  `json:"idGTE,omitempty"`
	IDLT    *int  `json:"idLT,omitempty"`
	IDLTE   *int  `json:"idLTE,omitempty"`

	// "item_id" field predicates.
	ItemID             *string  `json:"itemID,omitempty"`
	ItemIDNEQ          *string  `json:"itemIDNEQ,omitempty"`
	ItemIDIn           []string `json:"itemIDIn,omitempty"`
	ItemIDNotIn        []string `json:"itemIDNotIn,omitempty"`
	ItemIDGT           *string  `json:"itemIDGT,omitempty"`
	ItemIDGTE          *string  `json:"itemIDGTE,omitempty"`
	ItemIDLT           *string  `json:"itemIDLT,omitempty"`
	ItemIDLTE          *string  `json:"itemIDLTE,omitempty"`
	ItemIDContains     *string  `json:"itemIDContains,omitempty"`
	ItemIDHasPrefix    *string  `json:"itemIDHasPrefix,omitempty"`
	ItemIDHasSuffix    *string  `json:"itemIDHasSuffix,omitempty"`
	ItemIDEqualFold    *string  `json:"itemIDEqualFold,omitempty"`
	ItemIDContainsFold *string  `json:"itemIDContainsFold,omitempty"`

	// "access_token" field predicates.
	AccessToken             *string  `json:"accessToken,omitempty"`
	AccessTokenNEQ          *string  `json:"accessTokenNEQ,omitempty"`
	AccessTokenIn           []string `json:"accessTokenIn,omitempty"`
	AccessTokenNotIn        []string `json:"accessTokenNotIn,omitempty"`
	AccessTokenGT           *string  `json:"accessTokenGT,omitempty"`
	AccessTokenGTE          *string  `json:"accessTokenGTE,omitempty"`
	AccessTokenLT           *string  `json:"accessTokenLT,omitempty"`
	AccessTokenLTE          *string  `json:"accessTokenLTE,omitempty"`
	AccessTokenContains     *string  `json:"accessTokenContains,omitempty"`
	AccessTokenHasPrefix    *string  `json:"accessTokenHasPrefix,omitempty"`
	AccessTokenHasSuffix    *string  `json:"accessTokenHasSuffix,omitempty"`
	AccessTokenEqualFold    *string  `json:"accessTokenEqualFold,omitempty"`
	AccessTokenContainsFold *string  `json:"accessTokenContainsFold,omitempty"`

	// "created_at" field predicates.
	CreatedAt      *time.Time  `json:"createdAt,omitempty"`
	CreatedAtNEQ   *time.Time  `json:"createdAtNEQ,omitempty"`
	CreatedAtIn    []time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn []time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGT    *time.Time  `json:"createdAtGT,omitempty"`
	CreatedAtGTE   *time.Time  `json:"createdAtGTE,omitempty"`
	CreatedAtLT    *time.Time  `json:"createdAtLT,omitempty"`
	CreatedAtLTE   *time.Time  `json:"createdAtLTE,omitempty"`

	// "updated_at" field predicates.
	UpdatedAt      *time.Time  `json:"updatedAt,omitempty"`
	UpdatedAtNEQ   *time.Time  `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn    []time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn []time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGT    *time.Time  `json:"updatedAtGT,omitempty"`
	UpdatedAtGTE   *time.Time  `json:"updatedAtGTE,omitempty"`
	UpdatedAtLT    *time.Time  `json:"updatedAtLT,omitempty"`
	UpdatedAtLTE   *time.Time  `json:"updatedAtLTE,omitempty"`

	// "owner" edge predicates.
	HasOwner     *bool             `json:"hasOwner,omitempty"`
	HasOwnerWith []*UserWhereInput `json:"hasOwnerWith,omitempty"`

	// "transaction_syncs" edge predicates.
	HasTransactionSyncs     *bool                        `json:"hasTransactionSyncs,omitempty"`
	HasTransactionSyncsWith []*TransactionSyncWhereInput `json:"hasTransactionSyncsWith,omitempty"`

	// "institution" edge predicates.
	HasInstitution     *bool                         `json:"hasInstitution,omitempty"`
	HasInstitutionWith []*PlaidInstitutionWhereInput `json:"hasInstitutionWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *PlaidItemWhereInput) AddPredicates(predicates ...predicate.PlaidItem) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the PlaidItemWhereInput filter on the PlaidItemQuery builder.
func (i *PlaidItemWhereInput) Filter(q *PlaidItemQuery) (*PlaidItemQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyPlaidItemWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyPlaidItemWhereInput is returned in case the PlaidItemWhereInput is empty.
var ErrEmptyPlaidItemWhereInput = errors.New("ent: empty predicate PlaidItemWhereInput")

// P returns a predicate for filtering plaiditems.
// An error is returned if the input is empty or invalid.
func (i *PlaidItemWhereInput) P() (predicate.PlaidItem, error) {
	var predicates []predicate.PlaidItem
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, plaiditem.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.PlaidItem, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, plaiditem.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.PlaidItem, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, plaiditem.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, plaiditem.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, plaiditem.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, plaiditem.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, plaiditem.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, plaiditem.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, plaiditem.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, plaiditem.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, plaiditem.IDLTE(*i.IDLTE))
	}
	if i.ItemID != nil {
		predicates = append(predicates, plaiditem.ItemIDEQ(*i.ItemID))
	}
	if i.ItemIDNEQ != nil {
		predicates = append(predicates, plaiditem.ItemIDNEQ(*i.ItemIDNEQ))
	}
	if len(i.ItemIDIn) > 0 {
		predicates = append(predicates, plaiditem.ItemIDIn(i.ItemIDIn...))
	}
	if len(i.ItemIDNotIn) > 0 {
		predicates = append(predicates, plaiditem.ItemIDNotIn(i.ItemIDNotIn...))
	}
	if i.ItemIDGT != nil {
		predicates = append(predicates, plaiditem.ItemIDGT(*i.ItemIDGT))
	}
	if i.ItemIDGTE != nil {
		predicates = append(predicates, plaiditem.ItemIDGTE(*i.ItemIDGTE))
	}
	if i.ItemIDLT != nil {
		predicates = append(predicates, plaiditem.ItemIDLT(*i.ItemIDLT))
	}
	if i.ItemIDLTE != nil {
		predicates = append(predicates, plaiditem.ItemIDLTE(*i.ItemIDLTE))
	}
	if i.ItemIDContains != nil {
		predicates = append(predicates, plaiditem.ItemIDContains(*i.ItemIDContains))
	}
	if i.ItemIDHasPrefix != nil {
		predicates = append(predicates, plaiditem.ItemIDHasPrefix(*i.ItemIDHasPrefix))
	}
	if i.ItemIDHasSuffix != nil {
		predicates = append(predicates, plaiditem.ItemIDHasSuffix(*i.ItemIDHasSuffix))
	}
	if i.ItemIDEqualFold != nil {
		predicates = append(predicates, plaiditem.ItemIDEqualFold(*i.ItemIDEqualFold))
	}
	if i.ItemIDContainsFold != nil {
		predicates = append(predicates, plaiditem.ItemIDContainsFold(*i.ItemIDContainsFold))
	}
	if i.AccessToken != nil {
		predicates = append(predicates, plaiditem.AccessTokenEQ(*i.AccessToken))
	}
	if i.AccessTokenNEQ != nil {
		predicates = append(predicates, plaiditem.AccessTokenNEQ(*i.AccessTokenNEQ))
	}
	if len(i.AccessTokenIn) > 0 {
		predicates = append(predicates, plaiditem.AccessTokenIn(i.AccessTokenIn...))
	}
	if len(i.AccessTokenNotIn) > 0 {
		predicates = append(predicates, plaiditem.AccessTokenNotIn(i.AccessTokenNotIn...))
	}
	if i.AccessTokenGT != nil {
		predicates = append(predicates, plaiditem.AccessTokenGT(*i.AccessTokenGT))
	}
	if i.AccessTokenGTE != nil {
		predicates = append(predicates, plaiditem.AccessTokenGTE(*i.AccessTokenGTE))
	}
	if i.AccessTokenLT != nil {
		predicates = append(predicates, plaiditem.AccessTokenLT(*i.AccessTokenLT))
	}
	if i.AccessTokenLTE != nil {
		predicates = append(predicates, plaiditem.AccessTokenLTE(*i.AccessTokenLTE))
	}
	if i.AccessTokenContains != nil {
		predicates = append(predicates, plaiditem.AccessTokenContains(*i.AccessTokenContains))
	}
	if i.AccessTokenHasPrefix != nil {
		predicates = append(predicates, plaiditem.AccessTokenHasPrefix(*i.AccessTokenHasPrefix))
	}
	if i.AccessTokenHasSuffix != nil {
		predicates = append(predicates, plaiditem.AccessTokenHasSuffix(*i.AccessTokenHasSuffix))
	}
	if i.AccessTokenEqualFold != nil {
		predicates = append(predicates, plaiditem.AccessTokenEqualFold(*i.AccessTokenEqualFold))
	}
	if i.AccessTokenContainsFold != nil {
		predicates = append(predicates, plaiditem.AccessTokenContainsFold(*i.AccessTokenContainsFold))
	}
	if i.CreatedAt != nil {
		predicates = append(predicates, plaiditem.CreatedAtEQ(*i.CreatedAt))
	}
	if i.CreatedAtNEQ != nil {
		predicates = append(predicates, plaiditem.CreatedAtNEQ(*i.CreatedAtNEQ))
	}
	if len(i.CreatedAtIn) > 0 {
		predicates = append(predicates, plaiditem.CreatedAtIn(i.CreatedAtIn...))
	}
	if len(i.CreatedAtNotIn) > 0 {
		predicates = append(predicates, plaiditem.CreatedAtNotIn(i.CreatedAtNotIn...))
	}
	if i.CreatedAtGT != nil {
		predicates = append(predicates, plaiditem.CreatedAtGT(*i.CreatedAtGT))
	}
	if i.CreatedAtGTE != nil {
		predicates = append(predicates, plaiditem.CreatedAtGTE(*i.CreatedAtGTE))
	}
	if i.CreatedAtLT != nil {
		predicates = append(predicates, plaiditem.CreatedAtLT(*i.CreatedAtLT))
	}
	if i.CreatedAtLTE != nil {
		predicates = append(predicates, plaiditem.CreatedAtLTE(*i.CreatedAtLTE))
	}
	if i.UpdatedAt != nil {
		predicates = append(predicates, plaiditem.UpdatedAtEQ(*i.UpdatedAt))
	}
	if i.UpdatedAtNEQ != nil {
		predicates = append(predicates, plaiditem.UpdatedAtNEQ(*i.UpdatedAtNEQ))
	}
	if len(i.UpdatedAtIn) > 0 {
		predicates = append(predicates, plaiditem.UpdatedAtIn(i.UpdatedAtIn...))
	}
	if len(i.UpdatedAtNotIn) > 0 {
		predicates = append(predicates, plaiditem.UpdatedAtNotIn(i.UpdatedAtNotIn...))
	}
	if i.UpdatedAtGT != nil {
		predicates = append(predicates, plaiditem.UpdatedAtGT(*i.UpdatedAtGT))
	}
	if i.UpdatedAtGTE != nil {
		predicates = append(predicates, plaiditem.UpdatedAtGTE(*i.UpdatedAtGTE))
	}
	if i.UpdatedAtLT != nil {
		predicates = append(predicates, plaiditem.UpdatedAtLT(*i.UpdatedAtLT))
	}
	if i.UpdatedAtLTE != nil {
		predicates = append(predicates, plaiditem.UpdatedAtLTE(*i.UpdatedAtLTE))
	}

	if i.HasOwner != nil {
		p := plaiditem.HasOwner()
		if !*i.HasOwner {
			p = plaiditem.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasOwnerWith) > 0 {
		with := make([]predicate.User, 0, len(i.HasOwnerWith))
		for _, w := range i.HasOwnerWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasOwnerWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, plaiditem.HasOwnerWith(with...))
	}
	if i.HasTransactionSyncs != nil {
		p := plaiditem.HasTransactionSyncs()
		if !*i.HasTransactionSyncs {
			p = plaiditem.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasTransactionSyncsWith) > 0 {
		with := make([]predicate.TransactionSync, 0, len(i.HasTransactionSyncsWith))
		for _, w := range i.HasTransactionSyncsWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasTransactionSyncsWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, plaiditem.HasTransactionSyncsWith(with...))
	}
	if i.HasInstitution != nil {
		p := plaiditem.HasInstitution()
		if !*i.HasInstitution {
			p = plaiditem.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasInstitutionWith) > 0 {
		with := make([]predicate.PlaidInstitution, 0, len(i.HasInstitutionWith))
		for _, w := range i.HasInstitutionWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasInstitutionWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, plaiditem.HasInstitutionWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyPlaidItemWhereInput
	case 1:
		return predicates[0], nil
	default:
		return plaiditem.And(predicates...), nil
	}
}

// SpendingCategoryWhereInput represents a where input for filtering SpendingCategory queries.
type SpendingCategoryWhereInput struct {
	Predicates []predicate.SpendingCategory  `json:"-"`
	Not        *SpendingCategoryWhereInput   `json:"not,omitempty"`
	Or         []*SpendingCategoryWhereInput `json:"or,omitempty"`
	And        []*SpendingCategoryWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *int  `json:"id,omitempty"`
	IDNEQ   *int  `json:"idNEQ,omitempty"`
	IDIn    []int `json:"idIn,omitempty"`
	IDNotIn []int `json:"idNotIn,omitempty"`
	IDGT    *int  `json:"idGT,omitempty"`
	IDGTE   *int  `json:"idGTE,omitempty"`
	IDLT    *int  `json:"idLT,omitempty"`
	IDLTE   *int  `json:"idLTE,omitempty"`

	// "name" field predicates.
	Name             *string  `json:"name,omitempty"`
	NameNEQ          *string  `json:"nameNEQ,omitempty"`
	NameIn           []string `json:"nameIn,omitempty"`
	NameNotIn        []string `json:"nameNotIn,omitempty"`
	NameGT           *string  `json:"nameGT,omitempty"`
	NameGTE          *string  `json:"nameGTE,omitempty"`
	NameLT           *string  `json:"nameLT,omitempty"`
	NameLTE          *string  `json:"nameLTE,omitempty"`
	NameContains     *string  `json:"nameContains,omitempty"`
	NameHasPrefix    *string  `json:"nameHasPrefix,omitempty"`
	NameHasSuffix    *string  `json:"nameHasSuffix,omitempty"`
	NameEqualFold    *string  `json:"nameEqualFold,omitempty"`
	NameContainsFold *string  `json:"nameContainsFold,omitempty"`

	// "category_id" field predicates.
	CategoryID             *string  `json:"categoryID,omitempty"`
	CategoryIDNEQ          *string  `json:"categoryIDNEQ,omitempty"`
	CategoryIDIn           []string `json:"categoryIDIn,omitempty"`
	CategoryIDNotIn        []string `json:"categoryIDNotIn,omitempty"`
	CategoryIDGT           *string  `json:"categoryIDGT,omitempty"`
	CategoryIDGTE          *string  `json:"categoryIDGTE,omitempty"`
	CategoryIDLT           *string  `json:"categoryIDLT,omitempty"`
	CategoryIDLTE          *string  `json:"categoryIDLTE,omitempty"`
	CategoryIDContains     *string  `json:"categoryIDContains,omitempty"`
	CategoryIDHasPrefix    *string  `json:"categoryIDHasPrefix,omitempty"`
	CategoryIDHasSuffix    *string  `json:"categoryIDHasSuffix,omitempty"`
	CategoryIDEqualFold    *string  `json:"categoryIDEqualFold,omitempty"`
	CategoryIDContainsFold *string  `json:"categoryIDContainsFold,omitempty"`

	// "created_at" field predicates.
	CreatedAt      *time.Time  `json:"createdAt,omitempty"`
	CreatedAtNEQ   *time.Time  `json:"createdAtNEQ,omitempty"`
	CreatedAtIn    []time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn []time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGT    *time.Time  `json:"createdAtGT,omitempty"`
	CreatedAtGTE   *time.Time  `json:"createdAtGTE,omitempty"`
	CreatedAtLT    *time.Time  `json:"createdAtLT,omitempty"`
	CreatedAtLTE   *time.Time  `json:"createdAtLTE,omitempty"`

	// "category_transactions" edge predicates.
	HasCategoryTransactions     *bool                    `json:"hasCategoryTransactions,omitempty"`
	HasCategoryTransactionsWith []*TransactionWhereInput `json:"hasCategoryTransactionsWith,omitempty"`

	// "interested_users" edge predicates.
	HasInterestedUsers     *bool             `json:"hasInterestedUsers,omitempty"`
	HasInterestedUsersWith []*UserWhereInput `json:"hasInterestedUsersWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *SpendingCategoryWhereInput) AddPredicates(predicates ...predicate.SpendingCategory) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the SpendingCategoryWhereInput filter on the SpendingCategoryQuery builder.
func (i *SpendingCategoryWhereInput) Filter(q *SpendingCategoryQuery) (*SpendingCategoryQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptySpendingCategoryWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptySpendingCategoryWhereInput is returned in case the SpendingCategoryWhereInput is empty.
var ErrEmptySpendingCategoryWhereInput = errors.New("ent: empty predicate SpendingCategoryWhereInput")

// P returns a predicate for filtering spendingcategories.
// An error is returned if the input is empty or invalid.
func (i *SpendingCategoryWhereInput) P() (predicate.SpendingCategory, error) {
	var predicates []predicate.SpendingCategory
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, spendingcategory.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.SpendingCategory, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, spendingcategory.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.SpendingCategory, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, spendingcategory.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, spendingcategory.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, spendingcategory.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, spendingcategory.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, spendingcategory.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, spendingcategory.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, spendingcategory.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, spendingcategory.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, spendingcategory.IDLTE(*i.IDLTE))
	}
	if i.Name != nil {
		predicates = append(predicates, spendingcategory.NameEQ(*i.Name))
	}
	if i.NameNEQ != nil {
		predicates = append(predicates, spendingcategory.NameNEQ(*i.NameNEQ))
	}
	if len(i.NameIn) > 0 {
		predicates = append(predicates, spendingcategory.NameIn(i.NameIn...))
	}
	if len(i.NameNotIn) > 0 {
		predicates = append(predicates, spendingcategory.NameNotIn(i.NameNotIn...))
	}
	if i.NameGT != nil {
		predicates = append(predicates, spendingcategory.NameGT(*i.NameGT))
	}
	if i.NameGTE != nil {
		predicates = append(predicates, spendingcategory.NameGTE(*i.NameGTE))
	}
	if i.NameLT != nil {
		predicates = append(predicates, spendingcategory.NameLT(*i.NameLT))
	}
	if i.NameLTE != nil {
		predicates = append(predicates, spendingcategory.NameLTE(*i.NameLTE))
	}
	if i.NameContains != nil {
		predicates = append(predicates, spendingcategory.NameContains(*i.NameContains))
	}
	if i.NameHasPrefix != nil {
		predicates = append(predicates, spendingcategory.NameHasPrefix(*i.NameHasPrefix))
	}
	if i.NameHasSuffix != nil {
		predicates = append(predicates, spendingcategory.NameHasSuffix(*i.NameHasSuffix))
	}
	if i.NameEqualFold != nil {
		predicates = append(predicates, spendingcategory.NameEqualFold(*i.NameEqualFold))
	}
	if i.NameContainsFold != nil {
		predicates = append(predicates, spendingcategory.NameContainsFold(*i.NameContainsFold))
	}
	if i.CategoryID != nil {
		predicates = append(predicates, spendingcategory.CategoryIDEQ(*i.CategoryID))
	}
	if i.CategoryIDNEQ != nil {
		predicates = append(predicates, spendingcategory.CategoryIDNEQ(*i.CategoryIDNEQ))
	}
	if len(i.CategoryIDIn) > 0 {
		predicates = append(predicates, spendingcategory.CategoryIDIn(i.CategoryIDIn...))
	}
	if len(i.CategoryIDNotIn) > 0 {
		predicates = append(predicates, spendingcategory.CategoryIDNotIn(i.CategoryIDNotIn...))
	}
	if i.CategoryIDGT != nil {
		predicates = append(predicates, spendingcategory.CategoryIDGT(*i.CategoryIDGT))
	}
	if i.CategoryIDGTE != nil {
		predicates = append(predicates, spendingcategory.CategoryIDGTE(*i.CategoryIDGTE))
	}
	if i.CategoryIDLT != nil {
		predicates = append(predicates, spendingcategory.CategoryIDLT(*i.CategoryIDLT))
	}
	if i.CategoryIDLTE != nil {
		predicates = append(predicates, spendingcategory.CategoryIDLTE(*i.CategoryIDLTE))
	}
	if i.CategoryIDContains != nil {
		predicates = append(predicates, spendingcategory.CategoryIDContains(*i.CategoryIDContains))
	}
	if i.CategoryIDHasPrefix != nil {
		predicates = append(predicates, spendingcategory.CategoryIDHasPrefix(*i.CategoryIDHasPrefix))
	}
	if i.CategoryIDHasSuffix != nil {
		predicates = append(predicates, spendingcategory.CategoryIDHasSuffix(*i.CategoryIDHasSuffix))
	}
	if i.CategoryIDEqualFold != nil {
		predicates = append(predicates, spendingcategory.CategoryIDEqualFold(*i.CategoryIDEqualFold))
	}
	if i.CategoryIDContainsFold != nil {
		predicates = append(predicates, spendingcategory.CategoryIDContainsFold(*i.CategoryIDContainsFold))
	}
	if i.CreatedAt != nil {
		predicates = append(predicates, spendingcategory.CreatedAtEQ(*i.CreatedAt))
	}
	if i.CreatedAtNEQ != nil {
		predicates = append(predicates, spendingcategory.CreatedAtNEQ(*i.CreatedAtNEQ))
	}
	if len(i.CreatedAtIn) > 0 {
		predicates = append(predicates, spendingcategory.CreatedAtIn(i.CreatedAtIn...))
	}
	if len(i.CreatedAtNotIn) > 0 {
		predicates = append(predicates, spendingcategory.CreatedAtNotIn(i.CreatedAtNotIn...))
	}
	if i.CreatedAtGT != nil {
		predicates = append(predicates, spendingcategory.CreatedAtGT(*i.CreatedAtGT))
	}
	if i.CreatedAtGTE != nil {
		predicates = append(predicates, spendingcategory.CreatedAtGTE(*i.CreatedAtGTE))
	}
	if i.CreatedAtLT != nil {
		predicates = append(predicates, spendingcategory.CreatedAtLT(*i.CreatedAtLT))
	}
	if i.CreatedAtLTE != nil {
		predicates = append(predicates, spendingcategory.CreatedAtLTE(*i.CreatedAtLTE))
	}

	if i.HasCategoryTransactions != nil {
		p := spendingcategory.HasCategoryTransactions()
		if !*i.HasCategoryTransactions {
			p = spendingcategory.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasCategoryTransactionsWith) > 0 {
		with := make([]predicate.Transaction, 0, len(i.HasCategoryTransactionsWith))
		for _, w := range i.HasCategoryTransactionsWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasCategoryTransactionsWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, spendingcategory.HasCategoryTransactionsWith(with...))
	}
	if i.HasInterestedUsers != nil {
		p := spendingcategory.HasInterestedUsers()
		if !*i.HasInterestedUsers {
			p = spendingcategory.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasInterestedUsersWith) > 0 {
		with := make([]predicate.User, 0, len(i.HasInterestedUsersWith))
		for _, w := range i.HasInterestedUsersWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasInterestedUsersWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, spendingcategory.HasInterestedUsersWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptySpendingCategoryWhereInput
	case 1:
		return predicates[0], nil
	default:
		return spendingcategory.And(predicates...), nil
	}
}

// TransactionWhereInput represents a where input for filtering Transaction queries.
type TransactionWhereInput struct {
	Predicates []predicate.Transaction  `json:"-"`
	Not        *TransactionWhereInput   `json:"not,omitempty"`
	Or         []*TransactionWhereInput `json:"or,omitempty"`
	And        []*TransactionWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *int  `json:"id,omitempty"`
	IDNEQ   *int  `json:"idNEQ,omitempty"`
	IDIn    []int `json:"idIn,omitempty"`
	IDNotIn []int `json:"idNotIn,omitempty"`
	IDGT    *int  `json:"idGT,omitempty"`
	IDGTE   *int  `json:"idGTE,omitempty"`
	IDLT    *int  `json:"idLT,omitempty"`
	IDLTE   *int  `json:"idLTE,omitempty"`

	// "financial_account_id" field predicates.
	FinancialAccountID             *string  `json:"financialAccountID,omitempty"`
	FinancialAccountIDNEQ          *string  `json:"financialAccountIDNEQ,omitempty"`
	FinancialAccountIDIn           []string `json:"financialAccountIDIn,omitempty"`
	FinancialAccountIDNotIn        []string `json:"financialAccountIDNotIn,omitempty"`
	FinancialAccountIDGT           *string  `json:"financialAccountIDGT,omitempty"`
	FinancialAccountIDGTE          *string  `json:"financialAccountIDGTE,omitempty"`
	FinancialAccountIDLT           *string  `json:"financialAccountIDLT,omitempty"`
	FinancialAccountIDLTE          *string  `json:"financialAccountIDLTE,omitempty"`
	FinancialAccountIDContains     *string  `json:"financialAccountIDContains,omitempty"`
	FinancialAccountIDHasPrefix    *string  `json:"financialAccountIDHasPrefix,omitempty"`
	FinancialAccountIDHasSuffix    *string  `json:"financialAccountIDHasSuffix,omitempty"`
	FinancialAccountIDEqualFold    *string  `json:"financialAccountIDEqualFold,omitempty"`
	FinancialAccountIDContainsFold *string  `json:"financialAccountIDContainsFold,omitempty"`

	// "amount" field predicates.
	Amount      *float64  `json:"amount,omitempty"`
	AmountNEQ   *float64  `json:"amountNEQ,omitempty"`
	AmountIn    []float64 `json:"amountIn,omitempty"`
	AmountNotIn []float64 `json:"amountNotIn,omitempty"`
	AmountGT    *float64  `json:"amountGT,omitempty"`
	AmountGTE   *float64  `json:"amountGTE,omitempty"`
	AmountLT    *float64  `json:"amountLT,omitempty"`
	AmountLTE   *float64  `json:"amountLTE,omitempty"`

	// "iso_currency_code" field predicates.
	IsoCurrencyCode             *string  `json:"isoCurrencyCode,omitempty"`
	IsoCurrencyCodeNEQ          *string  `json:"isoCurrencyCodeNEQ,omitempty"`
	IsoCurrencyCodeIn           []string `json:"isoCurrencyCodeIn,omitempty"`
	IsoCurrencyCodeNotIn        []string `json:"isoCurrencyCodeNotIn,omitempty"`
	IsoCurrencyCodeGT           *string  `json:"isoCurrencyCodeGT,omitempty"`
	IsoCurrencyCodeGTE          *string  `json:"isoCurrencyCodeGTE,omitempty"`
	IsoCurrencyCodeLT           *string  `json:"isoCurrencyCodeLT,omitempty"`
	IsoCurrencyCodeLTE          *string  `json:"isoCurrencyCodeLTE,omitempty"`
	IsoCurrencyCodeContains     *string  `json:"isoCurrencyCodeContains,omitempty"`
	IsoCurrencyCodeHasPrefix    *string  `json:"isoCurrencyCodeHasPrefix,omitempty"`
	IsoCurrencyCodeHasSuffix    *string  `json:"isoCurrencyCodeHasSuffix,omitempty"`
	IsoCurrencyCodeEqualFold    *string  `json:"isoCurrencyCodeEqualFold,omitempty"`
	IsoCurrencyCodeContainsFold *string  `json:"isoCurrencyCodeContainsFold,omitempty"`

	// "unofficial_currency_code" field predicates.
	UnofficialCurrencyCode             *string  `json:"unofficialCurrencyCode,omitempty"`
	UnofficialCurrencyCodeNEQ          *string  `json:"unofficialCurrencyCodeNEQ,omitempty"`
	UnofficialCurrencyCodeIn           []string `json:"unofficialCurrencyCodeIn,omitempty"`
	UnofficialCurrencyCodeNotIn        []string `json:"unofficialCurrencyCodeNotIn,omitempty"`
	UnofficialCurrencyCodeGT           *string  `json:"unofficialCurrencyCodeGT,omitempty"`
	UnofficialCurrencyCodeGTE          *string  `json:"unofficialCurrencyCodeGTE,omitempty"`
	UnofficialCurrencyCodeLT           *string  `json:"unofficialCurrencyCodeLT,omitempty"`
	UnofficialCurrencyCodeLTE          *string  `json:"unofficialCurrencyCodeLTE,omitempty"`
	UnofficialCurrencyCodeContains     *string  `json:"unofficialCurrencyCodeContains,omitempty"`
	UnofficialCurrencyCodeHasPrefix    *string  `json:"unofficialCurrencyCodeHasPrefix,omitempty"`
	UnofficialCurrencyCodeHasSuffix    *string  `json:"unofficialCurrencyCodeHasSuffix,omitempty"`
	UnofficialCurrencyCodeEqualFold    *string  `json:"unofficialCurrencyCodeEqualFold,omitempty"`
	UnofficialCurrencyCodeContainsFold *string  `json:"unofficialCurrencyCodeContainsFold,omitempty"`

	// "category" field predicates.
	Category             *string  `json:"category,omitempty"`
	CategoryNEQ          *string  `json:"categoryNEQ,omitempty"`
	CategoryIn           []string `json:"categoryIn,omitempty"`
	CategoryNotIn        []string `json:"categoryNotIn,omitempty"`
	CategoryGT           *string  `json:"categoryGT,omitempty"`
	CategoryGTE          *string  `json:"categoryGTE,omitempty"`
	CategoryLT           *string  `json:"categoryLT,omitempty"`
	CategoryLTE          *string  `json:"categoryLTE,omitempty"`
	CategoryContains     *string  `json:"categoryContains,omitempty"`
	CategoryHasPrefix    *string  `json:"categoryHasPrefix,omitempty"`
	CategoryHasSuffix    *string  `json:"categoryHasSuffix,omitempty"`
	CategoryIsNil        bool     `json:"categoryIsNil,omitempty"`
	CategoryNotNil       bool     `json:"categoryNotNil,omitempty"`
	CategoryEqualFold    *string  `json:"categoryEqualFold,omitempty"`
	CategoryContainsFold *string  `json:"categoryContainsFold,omitempty"`

	// "category_id" field predicates.
	CategoryID             *string  `json:"categoryID,omitempty"`
	CategoryIDNEQ          *string  `json:"categoryIDNEQ,omitempty"`
	CategoryIDIn           []string `json:"categoryIDIn,omitempty"`
	CategoryIDNotIn        []string `json:"categoryIDNotIn,omitempty"`
	CategoryIDGT           *string  `json:"categoryIDGT,omitempty"`
	CategoryIDGTE          *string  `json:"categoryIDGTE,omitempty"`
	CategoryIDLT           *string  `json:"categoryIDLT,omitempty"`
	CategoryIDLTE          *string  `json:"categoryIDLTE,omitempty"`
	CategoryIDContains     *string  `json:"categoryIDContains,omitempty"`
	CategoryIDHasPrefix    *string  `json:"categoryIDHasPrefix,omitempty"`
	CategoryIDHasSuffix    *string  `json:"categoryIDHasSuffix,omitempty"`
	CategoryIDIsNil        bool     `json:"categoryIDIsNil,omitempty"`
	CategoryIDNotNil       bool     `json:"categoryIDNotNil,omitempty"`
	CategoryIDEqualFold    *string  `json:"categoryIDEqualFold,omitempty"`
	CategoryIDContainsFold *string  `json:"categoryIDContainsFold,omitempty"`

	// "check_number" field predicates.
	CheckNumber             *string  `json:"checkNumber,omitempty"`
	CheckNumberNEQ          *string  `json:"checkNumberNEQ,omitempty"`
	CheckNumberIn           []string `json:"checkNumberIn,omitempty"`
	CheckNumberNotIn        []string `json:"checkNumberNotIn,omitempty"`
	CheckNumberGT           *string  `json:"checkNumberGT,omitempty"`
	CheckNumberGTE          *string  `json:"checkNumberGTE,omitempty"`
	CheckNumberLT           *string  `json:"checkNumberLT,omitempty"`
	CheckNumberLTE          *string  `json:"checkNumberLTE,omitempty"`
	CheckNumberContains     *string  `json:"checkNumberContains,omitempty"`
	CheckNumberHasPrefix    *string  `json:"checkNumberHasPrefix,omitempty"`
	CheckNumberHasSuffix    *string  `json:"checkNumberHasSuffix,omitempty"`
	CheckNumberEqualFold    *string  `json:"checkNumberEqualFold,omitempty"`
	CheckNumberContainsFold *string  `json:"checkNumberContainsFold,omitempty"`

	// "date" field predicates.
	Date             *string  `json:"date,omitempty"`
	DateNEQ          *string  `json:"dateNEQ,omitempty"`
	DateIn           []string `json:"dateIn,omitempty"`
	DateNotIn        []string `json:"dateNotIn,omitempty"`
	DateGT           *string  `json:"dateGT,omitempty"`
	DateGTE          *string  `json:"dateGTE,omitempty"`
	DateLT           *string  `json:"dateLT,omitempty"`
	DateLTE          *string  `json:"dateLTE,omitempty"`
	DateContains     *string  `json:"dateContains,omitempty"`
	DateHasPrefix    *string  `json:"dateHasPrefix,omitempty"`
	DateHasSuffix    *string  `json:"dateHasSuffix,omitempty"`
	DateEqualFold    *string  `json:"dateEqualFold,omitempty"`
	DateContainsFold *string  `json:"dateContainsFold,omitempty"`

	// "datetime" field predicates.
	Datetime       *time.Time  `json:"datetime,omitempty"`
	DatetimeNEQ    *time.Time  `json:"datetimeNEQ,omitempty"`
	DatetimeIn     []time.Time `json:"datetimeIn,omitempty"`
	DatetimeNotIn  []time.Time `json:"datetimeNotIn,omitempty"`
	DatetimeGT     *time.Time  `json:"datetimeGT,omitempty"`
	DatetimeGTE    *time.Time  `json:"datetimeGTE,omitempty"`
	DatetimeLT     *time.Time  `json:"datetimeLT,omitempty"`
	DatetimeLTE    *time.Time  `json:"datetimeLTE,omitempty"`
	DatetimeIsNil  bool        `json:"datetimeIsNil,omitempty"`
	DatetimeNotNil bool        `json:"datetimeNotNil,omitempty"`

	// "authorized_date" field predicates.
	AuthorizedDate             *string  `json:"authorizedDate,omitempty"`
	AuthorizedDateNEQ          *string  `json:"authorizedDateNEQ,omitempty"`
	AuthorizedDateIn           []string `json:"authorizedDateIn,omitempty"`
	AuthorizedDateNotIn        []string `json:"authorizedDateNotIn,omitempty"`
	AuthorizedDateGT           *string  `json:"authorizedDateGT,omitempty"`
	AuthorizedDateGTE          *string  `json:"authorizedDateGTE,omitempty"`
	AuthorizedDateLT           *string  `json:"authorizedDateLT,omitempty"`
	AuthorizedDateLTE          *string  `json:"authorizedDateLTE,omitempty"`
	AuthorizedDateContains     *string  `json:"authorizedDateContains,omitempty"`
	AuthorizedDateHasPrefix    *string  `json:"authorizedDateHasPrefix,omitempty"`
	AuthorizedDateHasSuffix    *string  `json:"authorizedDateHasSuffix,omitempty"`
	AuthorizedDateIsNil        bool     `json:"authorizedDateIsNil,omitempty"`
	AuthorizedDateNotNil       bool     `json:"authorizedDateNotNil,omitempty"`
	AuthorizedDateEqualFold    *string  `json:"authorizedDateEqualFold,omitempty"`
	AuthorizedDateContainsFold *string  `json:"authorizedDateContainsFold,omitempty"`

	// "authorized_datetime" field predicates.
	AuthorizedDatetime       *time.Time  `json:"authorizedDatetime,omitempty"`
	AuthorizedDatetimeNEQ    *time.Time  `json:"authorizedDatetimeNEQ,omitempty"`
	AuthorizedDatetimeIn     []time.Time `json:"authorizedDatetimeIn,omitempty"`
	AuthorizedDatetimeNotIn  []time.Time `json:"authorizedDatetimeNotIn,omitempty"`
	AuthorizedDatetimeGT     *time.Time  `json:"authorizedDatetimeGT,omitempty"`
	AuthorizedDatetimeGTE    *time.Time  `json:"authorizedDatetimeGTE,omitempty"`
	AuthorizedDatetimeLT     *time.Time  `json:"authorizedDatetimeLT,omitempty"`
	AuthorizedDatetimeLTE    *time.Time  `json:"authorizedDatetimeLTE,omitempty"`
	AuthorizedDatetimeIsNil  bool        `json:"authorizedDatetimeIsNil,omitempty"`
	AuthorizedDatetimeNotNil bool        `json:"authorizedDatetimeNotNil,omitempty"`

	// "location_address" field predicates.
	LocationAddress             *string  `json:"locationAddress,omitempty"`
	LocationAddressNEQ          *string  `json:"locationAddressNEQ,omitempty"`
	LocationAddressIn           []string `json:"locationAddressIn,omitempty"`
	LocationAddressNotIn        []string `json:"locationAddressNotIn,omitempty"`
	LocationAddressGT           *string  `json:"locationAddressGT,omitempty"`
	LocationAddressGTE          *string  `json:"locationAddressGTE,omitempty"`
	LocationAddressLT           *string  `json:"locationAddressLT,omitempty"`
	LocationAddressLTE          *string  `json:"locationAddressLTE,omitempty"`
	LocationAddressContains     *string  `json:"locationAddressContains,omitempty"`
	LocationAddressHasPrefix    *string  `json:"locationAddressHasPrefix,omitempty"`
	LocationAddressHasSuffix    *string  `json:"locationAddressHasSuffix,omitempty"`
	LocationAddressEqualFold    *string  `json:"locationAddressEqualFold,omitempty"`
	LocationAddressContainsFold *string  `json:"locationAddressContainsFold,omitempty"`

	// "location_city" field predicates.
	LocationCity             *string  `json:"locationCity,omitempty"`
	LocationCityNEQ          *string  `json:"locationCityNEQ,omitempty"`
	LocationCityIn           []string `json:"locationCityIn,omitempty"`
	LocationCityNotIn        []string `json:"locationCityNotIn,omitempty"`
	LocationCityGT           *string  `json:"locationCityGT,omitempty"`
	LocationCityGTE          *string  `json:"locationCityGTE,omitempty"`
	LocationCityLT           *string  `json:"locationCityLT,omitempty"`
	LocationCityLTE          *string  `json:"locationCityLTE,omitempty"`
	LocationCityContains     *string  `json:"locationCityContains,omitempty"`
	LocationCityHasPrefix    *string  `json:"locationCityHasPrefix,omitempty"`
	LocationCityHasSuffix    *string  `json:"locationCityHasSuffix,omitempty"`
	LocationCityEqualFold    *string  `json:"locationCityEqualFold,omitempty"`
	LocationCityContainsFold *string  `json:"locationCityContainsFold,omitempty"`

	// "location_region" field predicates.
	LocationRegion             *string  `json:"locationRegion,omitempty"`
	LocationRegionNEQ          *string  `json:"locationRegionNEQ,omitempty"`
	LocationRegionIn           []string `json:"locationRegionIn,omitempty"`
	LocationRegionNotIn        []string `json:"locationRegionNotIn,omitempty"`
	LocationRegionGT           *string  `json:"locationRegionGT,omitempty"`
	LocationRegionGTE          *string  `json:"locationRegionGTE,omitempty"`
	LocationRegionLT           *string  `json:"locationRegionLT,omitempty"`
	LocationRegionLTE          *string  `json:"locationRegionLTE,omitempty"`
	LocationRegionContains     *string  `json:"locationRegionContains,omitempty"`
	LocationRegionHasPrefix    *string  `json:"locationRegionHasPrefix,omitempty"`
	LocationRegionHasSuffix    *string  `json:"locationRegionHasSuffix,omitempty"`
	LocationRegionEqualFold    *string  `json:"locationRegionEqualFold,omitempty"`
	LocationRegionContainsFold *string  `json:"locationRegionContainsFold,omitempty"`

	// "location_postal_code" field predicates.
	LocationPostalCode             *string  `json:"locationPostalCode,omitempty"`
	LocationPostalCodeNEQ          *string  `json:"locationPostalCodeNEQ,omitempty"`
	LocationPostalCodeIn           []string `json:"locationPostalCodeIn,omitempty"`
	LocationPostalCodeNotIn        []string `json:"locationPostalCodeNotIn,omitempty"`
	LocationPostalCodeGT           *string  `json:"locationPostalCodeGT,omitempty"`
	LocationPostalCodeGTE          *string  `json:"locationPostalCodeGTE,omitempty"`
	LocationPostalCodeLT           *string  `json:"locationPostalCodeLT,omitempty"`
	LocationPostalCodeLTE          *string  `json:"locationPostalCodeLTE,omitempty"`
	LocationPostalCodeContains     *string  `json:"locationPostalCodeContains,omitempty"`
	LocationPostalCodeHasPrefix    *string  `json:"locationPostalCodeHasPrefix,omitempty"`
	LocationPostalCodeHasSuffix    *string  `json:"locationPostalCodeHasSuffix,omitempty"`
	LocationPostalCodeEqualFold    *string  `json:"locationPostalCodeEqualFold,omitempty"`
	LocationPostalCodeContainsFold *string  `json:"locationPostalCodeContainsFold,omitempty"`

	// "location_lat" field predicates.
	LocationLat      *float64  `json:"locationLat,omitempty"`
	LocationLatNEQ   *float64  `json:"locationLatNEQ,omitempty"`
	LocationLatIn    []float64 `json:"locationLatIn,omitempty"`
	LocationLatNotIn []float64 `json:"locationLatNotIn,omitempty"`
	LocationLatGT    *float64  `json:"locationLatGT,omitempty"`
	LocationLatGTE   *float64  `json:"locationLatGTE,omitempty"`
	LocationLatLT    *float64  `json:"locationLatLT,omitempty"`
	LocationLatLTE   *float64  `json:"locationLatLTE,omitempty"`

	// "location_lon" field predicates.
	LocationLon      *float64  `json:"locationLon,omitempty"`
	LocationLonNEQ   *float64  `json:"locationLonNEQ,omitempty"`
	LocationLonIn    []float64 `json:"locationLonIn,omitempty"`
	LocationLonNotIn []float64 `json:"locationLonNotIn,omitempty"`
	LocationLonGT    *float64  `json:"locationLonGT,omitempty"`
	LocationLonGTE   *float64  `json:"locationLonGTE,omitempty"`
	LocationLonLT    *float64  `json:"locationLonLT,omitempty"`
	LocationLonLTE   *float64  `json:"locationLonLTE,omitempty"`

	// "location_store_number" field predicates.
	LocationStoreNumber             *string  `json:"locationStoreNumber,omitempty"`
	LocationStoreNumberNEQ          *string  `json:"locationStoreNumberNEQ,omitempty"`
	LocationStoreNumberIn           []string `json:"locationStoreNumberIn,omitempty"`
	LocationStoreNumberNotIn        []string `json:"locationStoreNumberNotIn,omitempty"`
	LocationStoreNumberGT           *string  `json:"locationStoreNumberGT,omitempty"`
	LocationStoreNumberGTE          *string  `json:"locationStoreNumberGTE,omitempty"`
	LocationStoreNumberLT           *string  `json:"locationStoreNumberLT,omitempty"`
	LocationStoreNumberLTE          *string  `json:"locationStoreNumberLTE,omitempty"`
	LocationStoreNumberContains     *string  `json:"locationStoreNumberContains,omitempty"`
	LocationStoreNumberHasPrefix    *string  `json:"locationStoreNumberHasPrefix,omitempty"`
	LocationStoreNumberHasSuffix    *string  `json:"locationStoreNumberHasSuffix,omitempty"`
	LocationStoreNumberEqualFold    *string  `json:"locationStoreNumberEqualFold,omitempty"`
	LocationStoreNumberContainsFold *string  `json:"locationStoreNumberContainsFold,omitempty"`

	// "name" field predicates.
	Name             *string  `json:"name,omitempty"`
	NameNEQ          *string  `json:"nameNEQ,omitempty"`
	NameIn           []string `json:"nameIn,omitempty"`
	NameNotIn        []string `json:"nameNotIn,omitempty"`
	NameGT           *string  `json:"nameGT,omitempty"`
	NameGTE          *string  `json:"nameGTE,omitempty"`
	NameLT           *string  `json:"nameLT,omitempty"`
	NameLTE          *string  `json:"nameLTE,omitempty"`
	NameContains     *string  `json:"nameContains,omitempty"`
	NameHasPrefix    *string  `json:"nameHasPrefix,omitempty"`
	NameHasSuffix    *string  `json:"nameHasSuffix,omitempty"`
	NameEqualFold    *string  `json:"nameEqualFold,omitempty"`
	NameContainsFold *string  `json:"nameContainsFold,omitempty"`

	// "merchant_name" field predicates.
	MerchantName             *string  `json:"merchantName,omitempty"`
	MerchantNameNEQ          *string  `json:"merchantNameNEQ,omitempty"`
	MerchantNameIn           []string `json:"merchantNameIn,omitempty"`
	MerchantNameNotIn        []string `json:"merchantNameNotIn,omitempty"`
	MerchantNameGT           *string  `json:"merchantNameGT,omitempty"`
	MerchantNameGTE          *string  `json:"merchantNameGTE,omitempty"`
	MerchantNameLT           *string  `json:"merchantNameLT,omitempty"`
	MerchantNameLTE          *string  `json:"merchantNameLTE,omitempty"`
	MerchantNameContains     *string  `json:"merchantNameContains,omitempty"`
	MerchantNameHasPrefix    *string  `json:"merchantNameHasPrefix,omitempty"`
	MerchantNameHasSuffix    *string  `json:"merchantNameHasSuffix,omitempty"`
	MerchantNameEqualFold    *string  `json:"merchantNameEqualFold,omitempty"`
	MerchantNameContainsFold *string  `json:"merchantNameContainsFold,omitempty"`

	// "payment_channel" field predicates.
	PaymentChannel             *string  `json:"paymentChannel,omitempty"`
	PaymentChannelNEQ          *string  `json:"paymentChannelNEQ,omitempty"`
	PaymentChannelIn           []string `json:"paymentChannelIn,omitempty"`
	PaymentChannelNotIn        []string `json:"paymentChannelNotIn,omitempty"`
	PaymentChannelGT           *string  `json:"paymentChannelGT,omitempty"`
	PaymentChannelGTE          *string  `json:"paymentChannelGTE,omitempty"`
	PaymentChannelLT           *string  `json:"paymentChannelLT,omitempty"`
	PaymentChannelLTE          *string  `json:"paymentChannelLTE,omitempty"`
	PaymentChannelContains     *string  `json:"paymentChannelContains,omitempty"`
	PaymentChannelHasPrefix    *string  `json:"paymentChannelHasPrefix,omitempty"`
	PaymentChannelHasSuffix    *string  `json:"paymentChannelHasSuffix,omitempty"`
	PaymentChannelEqualFold    *string  `json:"paymentChannelEqualFold,omitempty"`
	PaymentChannelContainsFold *string  `json:"paymentChannelContainsFold,omitempty"`

	// "pending" field predicates.
	Pending    *bool `json:"pending,omitempty"`
	PendingNEQ *bool `json:"pendingNEQ,omitempty"`

	// "pending_transaction_id" field predicates.
	PendingTransactionID             *string  `json:"pendingTransactionID,omitempty"`
	PendingTransactionIDNEQ          *string  `json:"pendingTransactionIDNEQ,omitempty"`
	PendingTransactionIDIn           []string `json:"pendingTransactionIDIn,omitempty"`
	PendingTransactionIDNotIn        []string `json:"pendingTransactionIDNotIn,omitempty"`
	PendingTransactionIDGT           *string  `json:"pendingTransactionIDGT,omitempty"`
	PendingTransactionIDGTE          *string  `json:"pendingTransactionIDGTE,omitempty"`
	PendingTransactionIDLT           *string  `json:"pendingTransactionIDLT,omitempty"`
	PendingTransactionIDLTE          *string  `json:"pendingTransactionIDLTE,omitempty"`
	PendingTransactionIDContains     *string  `json:"pendingTransactionIDContains,omitempty"`
	PendingTransactionIDHasPrefix    *string  `json:"pendingTransactionIDHasPrefix,omitempty"`
	PendingTransactionIDHasSuffix    *string  `json:"pendingTransactionIDHasSuffix,omitempty"`
	PendingTransactionIDEqualFold    *string  `json:"pendingTransactionIDEqualFold,omitempty"`
	PendingTransactionIDContainsFold *string  `json:"pendingTransactionIDContainsFold,omitempty"`

	// "account_owner" field predicates.
	AccountOwner             *string  `json:"accountOwner,omitempty"`
	AccountOwnerNEQ          *string  `json:"accountOwnerNEQ,omitempty"`
	AccountOwnerIn           []string `json:"accountOwnerIn,omitempty"`
	AccountOwnerNotIn        []string `json:"accountOwnerNotIn,omitempty"`
	AccountOwnerGT           *string  `json:"accountOwnerGT,omitempty"`
	AccountOwnerGTE          *string  `json:"accountOwnerGTE,omitempty"`
	AccountOwnerLT           *string  `json:"accountOwnerLT,omitempty"`
	AccountOwnerLTE          *string  `json:"accountOwnerLTE,omitempty"`
	AccountOwnerContains     *string  `json:"accountOwnerContains,omitempty"`
	AccountOwnerHasPrefix    *string  `json:"accountOwnerHasPrefix,omitempty"`
	AccountOwnerHasSuffix    *string  `json:"accountOwnerHasSuffix,omitempty"`
	AccountOwnerEqualFold    *string  `json:"accountOwnerEqualFold,omitempty"`
	AccountOwnerContainsFold *string  `json:"accountOwnerContainsFold,omitempty"`

	// "transaction_id" field predicates.
	TransactionID             *string  `json:"transactionID,omitempty"`
	TransactionIDNEQ          *string  `json:"transactionIDNEQ,omitempty"`
	TransactionIDIn           []string `json:"transactionIDIn,omitempty"`
	TransactionIDNotIn        []string `json:"transactionIDNotIn,omitempty"`
	TransactionIDGT           *string  `json:"transactionIDGT,omitempty"`
	TransactionIDGTE          *string  `json:"transactionIDGTE,omitempty"`
	TransactionIDLT           *string  `json:"transactionIDLT,omitempty"`
	TransactionIDLTE          *string  `json:"transactionIDLTE,omitempty"`
	TransactionIDContains     *string  `json:"transactionIDContains,omitempty"`
	TransactionIDHasPrefix    *string  `json:"transactionIDHasPrefix,omitempty"`
	TransactionIDHasSuffix    *string  `json:"transactionIDHasSuffix,omitempty"`
	TransactionIDEqualFold    *string  `json:"transactionIDEqualFold,omitempty"`
	TransactionIDContainsFold *string  `json:"transactionIDContainsFold,omitempty"`

	// "transaction_code" field predicates.
	TransactionCode             *string  `json:"transactionCode,omitempty"`
	TransactionCodeNEQ          *string  `json:"transactionCodeNEQ,omitempty"`
	TransactionCodeIn           []string `json:"transactionCodeIn,omitempty"`
	TransactionCodeNotIn        []string `json:"transactionCodeNotIn,omitempty"`
	TransactionCodeGT           *string  `json:"transactionCodeGT,omitempty"`
	TransactionCodeGTE          *string  `json:"transactionCodeGTE,omitempty"`
	TransactionCodeLT           *string  `json:"transactionCodeLT,omitempty"`
	TransactionCodeLTE          *string  `json:"transactionCodeLTE,omitempty"`
	TransactionCodeContains     *string  `json:"transactionCodeContains,omitempty"`
	TransactionCodeHasPrefix    *string  `json:"transactionCodeHasPrefix,omitempty"`
	TransactionCodeHasSuffix    *string  `json:"transactionCodeHasSuffix,omitempty"`
	TransactionCodeEqualFold    *string  `json:"transactionCodeEqualFold,omitempty"`
	TransactionCodeContainsFold *string  `json:"transactionCodeContainsFold,omitempty"`

	// "created_at" field predicates.
	CreatedAt      *time.Time  `json:"createdAt,omitempty"`
	CreatedAtNEQ   *time.Time  `json:"createdAtNEQ,omitempty"`
	CreatedAtIn    []time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn []time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGT    *time.Time  `json:"createdAtGT,omitempty"`
	CreatedAtGTE   *time.Time  `json:"createdAtGTE,omitempty"`
	CreatedAtLT    *time.Time  `json:"createdAtLT,omitempty"`
	CreatedAtLTE   *time.Time  `json:"createdAtLTE,omitempty"`

	// "institution_account" edge predicates.
	HasInstitutionAccount     *bool                                `json:"hasInstitutionAccount,omitempty"`
	HasInstitutionAccountWith []*PlaidInstitutionAccountWhereInput `json:"hasInstitutionAccountWith,omitempty"`

	// "transaction_categories" edge predicates.
	HasTransactionCategories     *bool                         `json:"hasTransactionCategories,omitempty"`
	HasTransactionCategoriesWith []*SpendingCategoryWhereInput `json:"hasTransactionCategoriesWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *TransactionWhereInput) AddPredicates(predicates ...predicate.Transaction) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the TransactionWhereInput filter on the TransactionQuery builder.
func (i *TransactionWhereInput) Filter(q *TransactionQuery) (*TransactionQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyTransactionWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyTransactionWhereInput is returned in case the TransactionWhereInput is empty.
var ErrEmptyTransactionWhereInput = errors.New("ent: empty predicate TransactionWhereInput")

// P returns a predicate for filtering transactions.
// An error is returned if the input is empty or invalid.
func (i *TransactionWhereInput) P() (predicate.Transaction, error) {
	var predicates []predicate.Transaction
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, transaction.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.Transaction, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, transaction.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.Transaction, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, transaction.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, transaction.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, transaction.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, transaction.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, transaction.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, transaction.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, transaction.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, transaction.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, transaction.IDLTE(*i.IDLTE))
	}
	if i.FinancialAccountID != nil {
		predicates = append(predicates, transaction.FinancialAccountIDEQ(*i.FinancialAccountID))
	}
	if i.FinancialAccountIDNEQ != nil {
		predicates = append(predicates, transaction.FinancialAccountIDNEQ(*i.FinancialAccountIDNEQ))
	}
	if len(i.FinancialAccountIDIn) > 0 {
		predicates = append(predicates, transaction.FinancialAccountIDIn(i.FinancialAccountIDIn...))
	}
	if len(i.FinancialAccountIDNotIn) > 0 {
		predicates = append(predicates, transaction.FinancialAccountIDNotIn(i.FinancialAccountIDNotIn...))
	}
	if i.FinancialAccountIDGT != nil {
		predicates = append(predicates, transaction.FinancialAccountIDGT(*i.FinancialAccountIDGT))
	}
	if i.FinancialAccountIDGTE != nil {
		predicates = append(predicates, transaction.FinancialAccountIDGTE(*i.FinancialAccountIDGTE))
	}
	if i.FinancialAccountIDLT != nil {
		predicates = append(predicates, transaction.FinancialAccountIDLT(*i.FinancialAccountIDLT))
	}
	if i.FinancialAccountIDLTE != nil {
		predicates = append(predicates, transaction.FinancialAccountIDLTE(*i.FinancialAccountIDLTE))
	}
	if i.FinancialAccountIDContains != nil {
		predicates = append(predicates, transaction.FinancialAccountIDContains(*i.FinancialAccountIDContains))
	}
	if i.FinancialAccountIDHasPrefix != nil {
		predicates = append(predicates, transaction.FinancialAccountIDHasPrefix(*i.FinancialAccountIDHasPrefix))
	}
	if i.FinancialAccountIDHasSuffix != nil {
		predicates = append(predicates, transaction.FinancialAccountIDHasSuffix(*i.FinancialAccountIDHasSuffix))
	}
	if i.FinancialAccountIDEqualFold != nil {
		predicates = append(predicates, transaction.FinancialAccountIDEqualFold(*i.FinancialAccountIDEqualFold))
	}
	if i.FinancialAccountIDContainsFold != nil {
		predicates = append(predicates, transaction.FinancialAccountIDContainsFold(*i.FinancialAccountIDContainsFold))
	}
	if i.Amount != nil {
		predicates = append(predicates, transaction.AmountEQ(*i.Amount))
	}
	if i.AmountNEQ != nil {
		predicates = append(predicates, transaction.AmountNEQ(*i.AmountNEQ))
	}
	if len(i.AmountIn) > 0 {
		predicates = append(predicates, transaction.AmountIn(i.AmountIn...))
	}
	if len(i.AmountNotIn) > 0 {
		predicates = append(predicates, transaction.AmountNotIn(i.AmountNotIn...))
	}
	if i.AmountGT != nil {
		predicates = append(predicates, transaction.AmountGT(*i.AmountGT))
	}
	if i.AmountGTE != nil {
		predicates = append(predicates, transaction.AmountGTE(*i.AmountGTE))
	}
	if i.AmountLT != nil {
		predicates = append(predicates, transaction.AmountLT(*i.AmountLT))
	}
	if i.AmountLTE != nil {
		predicates = append(predicates, transaction.AmountLTE(*i.AmountLTE))
	}
	if i.IsoCurrencyCode != nil {
		predicates = append(predicates, transaction.IsoCurrencyCodeEQ(*i.IsoCurrencyCode))
	}
	if i.IsoCurrencyCodeNEQ != nil {
		predicates = append(predicates, transaction.IsoCurrencyCodeNEQ(*i.IsoCurrencyCodeNEQ))
	}
	if len(i.IsoCurrencyCodeIn) > 0 {
		predicates = append(predicates, transaction.IsoCurrencyCodeIn(i.IsoCurrencyCodeIn...))
	}
	if len(i.IsoCurrencyCodeNotIn) > 0 {
		predicates = append(predicates, transaction.IsoCurrencyCodeNotIn(i.IsoCurrencyCodeNotIn...))
	}
	if i.IsoCurrencyCodeGT != nil {
		predicates = append(predicates, transaction.IsoCurrencyCodeGT(*i.IsoCurrencyCodeGT))
	}
	if i.IsoCurrencyCodeGTE != nil {
		predicates = append(predicates, transaction.IsoCurrencyCodeGTE(*i.IsoCurrencyCodeGTE))
	}
	if i.IsoCurrencyCodeLT != nil {
		predicates = append(predicates, transaction.IsoCurrencyCodeLT(*i.IsoCurrencyCodeLT))
	}
	if i.IsoCurrencyCodeLTE != nil {
		predicates = append(predicates, transaction.IsoCurrencyCodeLTE(*i.IsoCurrencyCodeLTE))
	}
	if i.IsoCurrencyCodeContains != nil {
		predicates = append(predicates, transaction.IsoCurrencyCodeContains(*i.IsoCurrencyCodeContains))
	}
	if i.IsoCurrencyCodeHasPrefix != nil {
		predicates = append(predicates, transaction.IsoCurrencyCodeHasPrefix(*i.IsoCurrencyCodeHasPrefix))
	}
	if i.IsoCurrencyCodeHasSuffix != nil {
		predicates = append(predicates, transaction.IsoCurrencyCodeHasSuffix(*i.IsoCurrencyCodeHasSuffix))
	}
	if i.IsoCurrencyCodeEqualFold != nil {
		predicates = append(predicates, transaction.IsoCurrencyCodeEqualFold(*i.IsoCurrencyCodeEqualFold))
	}
	if i.IsoCurrencyCodeContainsFold != nil {
		predicates = append(predicates, transaction.IsoCurrencyCodeContainsFold(*i.IsoCurrencyCodeContainsFold))
	}
	if i.UnofficialCurrencyCode != nil {
		predicates = append(predicates, transaction.UnofficialCurrencyCodeEQ(*i.UnofficialCurrencyCode))
	}
	if i.UnofficialCurrencyCodeNEQ != nil {
		predicates = append(predicates, transaction.UnofficialCurrencyCodeNEQ(*i.UnofficialCurrencyCodeNEQ))
	}
	if len(i.UnofficialCurrencyCodeIn) > 0 {
		predicates = append(predicates, transaction.UnofficialCurrencyCodeIn(i.UnofficialCurrencyCodeIn...))
	}
	if len(i.UnofficialCurrencyCodeNotIn) > 0 {
		predicates = append(predicates, transaction.UnofficialCurrencyCodeNotIn(i.UnofficialCurrencyCodeNotIn...))
	}
	if i.UnofficialCurrencyCodeGT != nil {
		predicates = append(predicates, transaction.UnofficialCurrencyCodeGT(*i.UnofficialCurrencyCodeGT))
	}
	if i.UnofficialCurrencyCodeGTE != nil {
		predicates = append(predicates, transaction.UnofficialCurrencyCodeGTE(*i.UnofficialCurrencyCodeGTE))
	}
	if i.UnofficialCurrencyCodeLT != nil {
		predicates = append(predicates, transaction.UnofficialCurrencyCodeLT(*i.UnofficialCurrencyCodeLT))
	}
	if i.UnofficialCurrencyCodeLTE != nil {
		predicates = append(predicates, transaction.UnofficialCurrencyCodeLTE(*i.UnofficialCurrencyCodeLTE))
	}
	if i.UnofficialCurrencyCodeContains != nil {
		predicates = append(predicates, transaction.UnofficialCurrencyCodeContains(*i.UnofficialCurrencyCodeContains))
	}
	if i.UnofficialCurrencyCodeHasPrefix != nil {
		predicates = append(predicates, transaction.UnofficialCurrencyCodeHasPrefix(*i.UnofficialCurrencyCodeHasPrefix))
	}
	if i.UnofficialCurrencyCodeHasSuffix != nil {
		predicates = append(predicates, transaction.UnofficialCurrencyCodeHasSuffix(*i.UnofficialCurrencyCodeHasSuffix))
	}
	if i.UnofficialCurrencyCodeEqualFold != nil {
		predicates = append(predicates, transaction.UnofficialCurrencyCodeEqualFold(*i.UnofficialCurrencyCodeEqualFold))
	}
	if i.UnofficialCurrencyCodeContainsFold != nil {
		predicates = append(predicates, transaction.UnofficialCurrencyCodeContainsFold(*i.UnofficialCurrencyCodeContainsFold))
	}
	if i.Category != nil {
		predicates = append(predicates, transaction.CategoryEQ(*i.Category))
	}
	if i.CategoryNEQ != nil {
		predicates = append(predicates, transaction.CategoryNEQ(*i.CategoryNEQ))
	}
	if len(i.CategoryIn) > 0 {
		predicates = append(predicates, transaction.CategoryIn(i.CategoryIn...))
	}
	if len(i.CategoryNotIn) > 0 {
		predicates = append(predicates, transaction.CategoryNotIn(i.CategoryNotIn...))
	}
	if i.CategoryGT != nil {
		predicates = append(predicates, transaction.CategoryGT(*i.CategoryGT))
	}
	if i.CategoryGTE != nil {
		predicates = append(predicates, transaction.CategoryGTE(*i.CategoryGTE))
	}
	if i.CategoryLT != nil {
		predicates = append(predicates, transaction.CategoryLT(*i.CategoryLT))
	}
	if i.CategoryLTE != nil {
		predicates = append(predicates, transaction.CategoryLTE(*i.CategoryLTE))
	}
	if i.CategoryContains != nil {
		predicates = append(predicates, transaction.CategoryContains(*i.CategoryContains))
	}
	if i.CategoryHasPrefix != nil {
		predicates = append(predicates, transaction.CategoryHasPrefix(*i.CategoryHasPrefix))
	}
	if i.CategoryHasSuffix != nil {
		predicates = append(predicates, transaction.CategoryHasSuffix(*i.CategoryHasSuffix))
	}
	if i.CategoryIsNil {
		predicates = append(predicates, transaction.CategoryIsNil())
	}
	if i.CategoryNotNil {
		predicates = append(predicates, transaction.CategoryNotNil())
	}
	if i.CategoryEqualFold != nil {
		predicates = append(predicates, transaction.CategoryEqualFold(*i.CategoryEqualFold))
	}
	if i.CategoryContainsFold != nil {
		predicates = append(predicates, transaction.CategoryContainsFold(*i.CategoryContainsFold))
	}
	if i.CategoryID != nil {
		predicates = append(predicates, transaction.CategoryIDEQ(*i.CategoryID))
	}
	if i.CategoryIDNEQ != nil {
		predicates = append(predicates, transaction.CategoryIDNEQ(*i.CategoryIDNEQ))
	}
	if len(i.CategoryIDIn) > 0 {
		predicates = append(predicates, transaction.CategoryIDIn(i.CategoryIDIn...))
	}
	if len(i.CategoryIDNotIn) > 0 {
		predicates = append(predicates, transaction.CategoryIDNotIn(i.CategoryIDNotIn...))
	}
	if i.CategoryIDGT != nil {
		predicates = append(predicates, transaction.CategoryIDGT(*i.CategoryIDGT))
	}
	if i.CategoryIDGTE != nil {
		predicates = append(predicates, transaction.CategoryIDGTE(*i.CategoryIDGTE))
	}
	if i.CategoryIDLT != nil {
		predicates = append(predicates, transaction.CategoryIDLT(*i.CategoryIDLT))
	}
	if i.CategoryIDLTE != nil {
		predicates = append(predicates, transaction.CategoryIDLTE(*i.CategoryIDLTE))
	}
	if i.CategoryIDContains != nil {
		predicates = append(predicates, transaction.CategoryIDContains(*i.CategoryIDContains))
	}
	if i.CategoryIDHasPrefix != nil {
		predicates = append(predicates, transaction.CategoryIDHasPrefix(*i.CategoryIDHasPrefix))
	}
	if i.CategoryIDHasSuffix != nil {
		predicates = append(predicates, transaction.CategoryIDHasSuffix(*i.CategoryIDHasSuffix))
	}
	if i.CategoryIDIsNil {
		predicates = append(predicates, transaction.CategoryIDIsNil())
	}
	if i.CategoryIDNotNil {
		predicates = append(predicates, transaction.CategoryIDNotNil())
	}
	if i.CategoryIDEqualFold != nil {
		predicates = append(predicates, transaction.CategoryIDEqualFold(*i.CategoryIDEqualFold))
	}
	if i.CategoryIDContainsFold != nil {
		predicates = append(predicates, transaction.CategoryIDContainsFold(*i.CategoryIDContainsFold))
	}
	if i.CheckNumber != nil {
		predicates = append(predicates, transaction.CheckNumberEQ(*i.CheckNumber))
	}
	if i.CheckNumberNEQ != nil {
		predicates = append(predicates, transaction.CheckNumberNEQ(*i.CheckNumberNEQ))
	}
	if len(i.CheckNumberIn) > 0 {
		predicates = append(predicates, transaction.CheckNumberIn(i.CheckNumberIn...))
	}
	if len(i.CheckNumberNotIn) > 0 {
		predicates = append(predicates, transaction.CheckNumberNotIn(i.CheckNumberNotIn...))
	}
	if i.CheckNumberGT != nil {
		predicates = append(predicates, transaction.CheckNumberGT(*i.CheckNumberGT))
	}
	if i.CheckNumberGTE != nil {
		predicates = append(predicates, transaction.CheckNumberGTE(*i.CheckNumberGTE))
	}
	if i.CheckNumberLT != nil {
		predicates = append(predicates, transaction.CheckNumberLT(*i.CheckNumberLT))
	}
	if i.CheckNumberLTE != nil {
		predicates = append(predicates, transaction.CheckNumberLTE(*i.CheckNumberLTE))
	}
	if i.CheckNumberContains != nil {
		predicates = append(predicates, transaction.CheckNumberContains(*i.CheckNumberContains))
	}
	if i.CheckNumberHasPrefix != nil {
		predicates = append(predicates, transaction.CheckNumberHasPrefix(*i.CheckNumberHasPrefix))
	}
	if i.CheckNumberHasSuffix != nil {
		predicates = append(predicates, transaction.CheckNumberHasSuffix(*i.CheckNumberHasSuffix))
	}
	if i.CheckNumberEqualFold != nil {
		predicates = append(predicates, transaction.CheckNumberEqualFold(*i.CheckNumberEqualFold))
	}
	if i.CheckNumberContainsFold != nil {
		predicates = append(predicates, transaction.CheckNumberContainsFold(*i.CheckNumberContainsFold))
	}
	if i.Date != nil {
		predicates = append(predicates, transaction.DateEQ(*i.Date))
	}
	if i.DateNEQ != nil {
		predicates = append(predicates, transaction.DateNEQ(*i.DateNEQ))
	}
	if len(i.DateIn) > 0 {
		predicates = append(predicates, transaction.DateIn(i.DateIn...))
	}
	if len(i.DateNotIn) > 0 {
		predicates = append(predicates, transaction.DateNotIn(i.DateNotIn...))
	}
	if i.DateGT != nil {
		predicates = append(predicates, transaction.DateGT(*i.DateGT))
	}
	if i.DateGTE != nil {
		predicates = append(predicates, transaction.DateGTE(*i.DateGTE))
	}
	if i.DateLT != nil {
		predicates = append(predicates, transaction.DateLT(*i.DateLT))
	}
	if i.DateLTE != nil {
		predicates = append(predicates, transaction.DateLTE(*i.DateLTE))
	}
	if i.DateContains != nil {
		predicates = append(predicates, transaction.DateContains(*i.DateContains))
	}
	if i.DateHasPrefix != nil {
		predicates = append(predicates, transaction.DateHasPrefix(*i.DateHasPrefix))
	}
	if i.DateHasSuffix != nil {
		predicates = append(predicates, transaction.DateHasSuffix(*i.DateHasSuffix))
	}
	if i.DateEqualFold != nil {
		predicates = append(predicates, transaction.DateEqualFold(*i.DateEqualFold))
	}
	if i.DateContainsFold != nil {
		predicates = append(predicates, transaction.DateContainsFold(*i.DateContainsFold))
	}
	if i.Datetime != nil {
		predicates = append(predicates, transaction.DatetimeEQ(*i.Datetime))
	}
	if i.DatetimeNEQ != nil {
		predicates = append(predicates, transaction.DatetimeNEQ(*i.DatetimeNEQ))
	}
	if len(i.DatetimeIn) > 0 {
		predicates = append(predicates, transaction.DatetimeIn(i.DatetimeIn...))
	}
	if len(i.DatetimeNotIn) > 0 {
		predicates = append(predicates, transaction.DatetimeNotIn(i.DatetimeNotIn...))
	}
	if i.DatetimeGT != nil {
		predicates = append(predicates, transaction.DatetimeGT(*i.DatetimeGT))
	}
	if i.DatetimeGTE != nil {
		predicates = append(predicates, transaction.DatetimeGTE(*i.DatetimeGTE))
	}
	if i.DatetimeLT != nil {
		predicates = append(predicates, transaction.DatetimeLT(*i.DatetimeLT))
	}
	if i.DatetimeLTE != nil {
		predicates = append(predicates, transaction.DatetimeLTE(*i.DatetimeLTE))
	}
	if i.DatetimeIsNil {
		predicates = append(predicates, transaction.DatetimeIsNil())
	}
	if i.DatetimeNotNil {
		predicates = append(predicates, transaction.DatetimeNotNil())
	}
	if i.AuthorizedDate != nil {
		predicates = append(predicates, transaction.AuthorizedDateEQ(*i.AuthorizedDate))
	}
	if i.AuthorizedDateNEQ != nil {
		predicates = append(predicates, transaction.AuthorizedDateNEQ(*i.AuthorizedDateNEQ))
	}
	if len(i.AuthorizedDateIn) > 0 {
		predicates = append(predicates, transaction.AuthorizedDateIn(i.AuthorizedDateIn...))
	}
	if len(i.AuthorizedDateNotIn) > 0 {
		predicates = append(predicates, transaction.AuthorizedDateNotIn(i.AuthorizedDateNotIn...))
	}
	if i.AuthorizedDateGT != nil {
		predicates = append(predicates, transaction.AuthorizedDateGT(*i.AuthorizedDateGT))
	}
	if i.AuthorizedDateGTE != nil {
		predicates = append(predicates, transaction.AuthorizedDateGTE(*i.AuthorizedDateGTE))
	}
	if i.AuthorizedDateLT != nil {
		predicates = append(predicates, transaction.AuthorizedDateLT(*i.AuthorizedDateLT))
	}
	if i.AuthorizedDateLTE != nil {
		predicates = append(predicates, transaction.AuthorizedDateLTE(*i.AuthorizedDateLTE))
	}
	if i.AuthorizedDateContains != nil {
		predicates = append(predicates, transaction.AuthorizedDateContains(*i.AuthorizedDateContains))
	}
	if i.AuthorizedDateHasPrefix != nil {
		predicates = append(predicates, transaction.AuthorizedDateHasPrefix(*i.AuthorizedDateHasPrefix))
	}
	if i.AuthorizedDateHasSuffix != nil {
		predicates = append(predicates, transaction.AuthorizedDateHasSuffix(*i.AuthorizedDateHasSuffix))
	}
	if i.AuthorizedDateIsNil {
		predicates = append(predicates, transaction.AuthorizedDateIsNil())
	}
	if i.AuthorizedDateNotNil {
		predicates = append(predicates, transaction.AuthorizedDateNotNil())
	}
	if i.AuthorizedDateEqualFold != nil {
		predicates = append(predicates, transaction.AuthorizedDateEqualFold(*i.AuthorizedDateEqualFold))
	}
	if i.AuthorizedDateContainsFold != nil {
		predicates = append(predicates, transaction.AuthorizedDateContainsFold(*i.AuthorizedDateContainsFold))
	}
	if i.AuthorizedDatetime != nil {
		predicates = append(predicates, transaction.AuthorizedDatetimeEQ(*i.AuthorizedDatetime))
	}
	if i.AuthorizedDatetimeNEQ != nil {
		predicates = append(predicates, transaction.AuthorizedDatetimeNEQ(*i.AuthorizedDatetimeNEQ))
	}
	if len(i.AuthorizedDatetimeIn) > 0 {
		predicates = append(predicates, transaction.AuthorizedDatetimeIn(i.AuthorizedDatetimeIn...))
	}
	if len(i.AuthorizedDatetimeNotIn) > 0 {
		predicates = append(predicates, transaction.AuthorizedDatetimeNotIn(i.AuthorizedDatetimeNotIn...))
	}
	if i.AuthorizedDatetimeGT != nil {
		predicates = append(predicates, transaction.AuthorizedDatetimeGT(*i.AuthorizedDatetimeGT))
	}
	if i.AuthorizedDatetimeGTE != nil {
		predicates = append(predicates, transaction.AuthorizedDatetimeGTE(*i.AuthorizedDatetimeGTE))
	}
	if i.AuthorizedDatetimeLT != nil {
		predicates = append(predicates, transaction.AuthorizedDatetimeLT(*i.AuthorizedDatetimeLT))
	}
	if i.AuthorizedDatetimeLTE != nil {
		predicates = append(predicates, transaction.AuthorizedDatetimeLTE(*i.AuthorizedDatetimeLTE))
	}
	if i.AuthorizedDatetimeIsNil {
		predicates = append(predicates, transaction.AuthorizedDatetimeIsNil())
	}
	if i.AuthorizedDatetimeNotNil {
		predicates = append(predicates, transaction.AuthorizedDatetimeNotNil())
	}
	if i.LocationAddress != nil {
		predicates = append(predicates, transaction.LocationAddressEQ(*i.LocationAddress))
	}
	if i.LocationAddressNEQ != nil {
		predicates = append(predicates, transaction.LocationAddressNEQ(*i.LocationAddressNEQ))
	}
	if len(i.LocationAddressIn) > 0 {
		predicates = append(predicates, transaction.LocationAddressIn(i.LocationAddressIn...))
	}
	if len(i.LocationAddressNotIn) > 0 {
		predicates = append(predicates, transaction.LocationAddressNotIn(i.LocationAddressNotIn...))
	}
	if i.LocationAddressGT != nil {
		predicates = append(predicates, transaction.LocationAddressGT(*i.LocationAddressGT))
	}
	if i.LocationAddressGTE != nil {
		predicates = append(predicates, transaction.LocationAddressGTE(*i.LocationAddressGTE))
	}
	if i.LocationAddressLT != nil {
		predicates = append(predicates, transaction.LocationAddressLT(*i.LocationAddressLT))
	}
	if i.LocationAddressLTE != nil {
		predicates = append(predicates, transaction.LocationAddressLTE(*i.LocationAddressLTE))
	}
	if i.LocationAddressContains != nil {
		predicates = append(predicates, transaction.LocationAddressContains(*i.LocationAddressContains))
	}
	if i.LocationAddressHasPrefix != nil {
		predicates = append(predicates, transaction.LocationAddressHasPrefix(*i.LocationAddressHasPrefix))
	}
	if i.LocationAddressHasSuffix != nil {
		predicates = append(predicates, transaction.LocationAddressHasSuffix(*i.LocationAddressHasSuffix))
	}
	if i.LocationAddressEqualFold != nil {
		predicates = append(predicates, transaction.LocationAddressEqualFold(*i.LocationAddressEqualFold))
	}
	if i.LocationAddressContainsFold != nil {
		predicates = append(predicates, transaction.LocationAddressContainsFold(*i.LocationAddressContainsFold))
	}
	if i.LocationCity != nil {
		predicates = append(predicates, transaction.LocationCityEQ(*i.LocationCity))
	}
	if i.LocationCityNEQ != nil {
		predicates = append(predicates, transaction.LocationCityNEQ(*i.LocationCityNEQ))
	}
	if len(i.LocationCityIn) > 0 {
		predicates = append(predicates, transaction.LocationCityIn(i.LocationCityIn...))
	}
	if len(i.LocationCityNotIn) > 0 {
		predicates = append(predicates, transaction.LocationCityNotIn(i.LocationCityNotIn...))
	}
	if i.LocationCityGT != nil {
		predicates = append(predicates, transaction.LocationCityGT(*i.LocationCityGT))
	}
	if i.LocationCityGTE != nil {
		predicates = append(predicates, transaction.LocationCityGTE(*i.LocationCityGTE))
	}
	if i.LocationCityLT != nil {
		predicates = append(predicates, transaction.LocationCityLT(*i.LocationCityLT))
	}
	if i.LocationCityLTE != nil {
		predicates = append(predicates, transaction.LocationCityLTE(*i.LocationCityLTE))
	}
	if i.LocationCityContains != nil {
		predicates = append(predicates, transaction.LocationCityContains(*i.LocationCityContains))
	}
	if i.LocationCityHasPrefix != nil {
		predicates = append(predicates, transaction.LocationCityHasPrefix(*i.LocationCityHasPrefix))
	}
	if i.LocationCityHasSuffix != nil {
		predicates = append(predicates, transaction.LocationCityHasSuffix(*i.LocationCityHasSuffix))
	}
	if i.LocationCityEqualFold != nil {
		predicates = append(predicates, transaction.LocationCityEqualFold(*i.LocationCityEqualFold))
	}
	if i.LocationCityContainsFold != nil {
		predicates = append(predicates, transaction.LocationCityContainsFold(*i.LocationCityContainsFold))
	}
	if i.LocationRegion != nil {
		predicates = append(predicates, transaction.LocationRegionEQ(*i.LocationRegion))
	}
	if i.LocationRegionNEQ != nil {
		predicates = append(predicates, transaction.LocationRegionNEQ(*i.LocationRegionNEQ))
	}
	if len(i.LocationRegionIn) > 0 {
		predicates = append(predicates, transaction.LocationRegionIn(i.LocationRegionIn...))
	}
	if len(i.LocationRegionNotIn) > 0 {
		predicates = append(predicates, transaction.LocationRegionNotIn(i.LocationRegionNotIn...))
	}
	if i.LocationRegionGT != nil {
		predicates = append(predicates, transaction.LocationRegionGT(*i.LocationRegionGT))
	}
	if i.LocationRegionGTE != nil {
		predicates = append(predicates, transaction.LocationRegionGTE(*i.LocationRegionGTE))
	}
	if i.LocationRegionLT != nil {
		predicates = append(predicates, transaction.LocationRegionLT(*i.LocationRegionLT))
	}
	if i.LocationRegionLTE != nil {
		predicates = append(predicates, transaction.LocationRegionLTE(*i.LocationRegionLTE))
	}
	if i.LocationRegionContains != nil {
		predicates = append(predicates, transaction.LocationRegionContains(*i.LocationRegionContains))
	}
	if i.LocationRegionHasPrefix != nil {
		predicates = append(predicates, transaction.LocationRegionHasPrefix(*i.LocationRegionHasPrefix))
	}
	if i.LocationRegionHasSuffix != nil {
		predicates = append(predicates, transaction.LocationRegionHasSuffix(*i.LocationRegionHasSuffix))
	}
	if i.LocationRegionEqualFold != nil {
		predicates = append(predicates, transaction.LocationRegionEqualFold(*i.LocationRegionEqualFold))
	}
	if i.LocationRegionContainsFold != nil {
		predicates = append(predicates, transaction.LocationRegionContainsFold(*i.LocationRegionContainsFold))
	}
	if i.LocationPostalCode != nil {
		predicates = append(predicates, transaction.LocationPostalCodeEQ(*i.LocationPostalCode))
	}
	if i.LocationPostalCodeNEQ != nil {
		predicates = append(predicates, transaction.LocationPostalCodeNEQ(*i.LocationPostalCodeNEQ))
	}
	if len(i.LocationPostalCodeIn) > 0 {
		predicates = append(predicates, transaction.LocationPostalCodeIn(i.LocationPostalCodeIn...))
	}
	if len(i.LocationPostalCodeNotIn) > 0 {
		predicates = append(predicates, transaction.LocationPostalCodeNotIn(i.LocationPostalCodeNotIn...))
	}
	if i.LocationPostalCodeGT != nil {
		predicates = append(predicates, transaction.LocationPostalCodeGT(*i.LocationPostalCodeGT))
	}
	if i.LocationPostalCodeGTE != nil {
		predicates = append(predicates, transaction.LocationPostalCodeGTE(*i.LocationPostalCodeGTE))
	}
	if i.LocationPostalCodeLT != nil {
		predicates = append(predicates, transaction.LocationPostalCodeLT(*i.LocationPostalCodeLT))
	}
	if i.LocationPostalCodeLTE != nil {
		predicates = append(predicates, transaction.LocationPostalCodeLTE(*i.LocationPostalCodeLTE))
	}
	if i.LocationPostalCodeContains != nil {
		predicates = append(predicates, transaction.LocationPostalCodeContains(*i.LocationPostalCodeContains))
	}
	if i.LocationPostalCodeHasPrefix != nil {
		predicates = append(predicates, transaction.LocationPostalCodeHasPrefix(*i.LocationPostalCodeHasPrefix))
	}
	if i.LocationPostalCodeHasSuffix != nil {
		predicates = append(predicates, transaction.LocationPostalCodeHasSuffix(*i.LocationPostalCodeHasSuffix))
	}
	if i.LocationPostalCodeEqualFold != nil {
		predicates = append(predicates, transaction.LocationPostalCodeEqualFold(*i.LocationPostalCodeEqualFold))
	}
	if i.LocationPostalCodeContainsFold != nil {
		predicates = append(predicates, transaction.LocationPostalCodeContainsFold(*i.LocationPostalCodeContainsFold))
	}
	if i.LocationLat != nil {
		predicates = append(predicates, transaction.LocationLatEQ(*i.LocationLat))
	}
	if i.LocationLatNEQ != nil {
		predicates = append(predicates, transaction.LocationLatNEQ(*i.LocationLatNEQ))
	}
	if len(i.LocationLatIn) > 0 {
		predicates = append(predicates, transaction.LocationLatIn(i.LocationLatIn...))
	}
	if len(i.LocationLatNotIn) > 0 {
		predicates = append(predicates, transaction.LocationLatNotIn(i.LocationLatNotIn...))
	}
	if i.LocationLatGT != nil {
		predicates = append(predicates, transaction.LocationLatGT(*i.LocationLatGT))
	}
	if i.LocationLatGTE != nil {
		predicates = append(predicates, transaction.LocationLatGTE(*i.LocationLatGTE))
	}
	if i.LocationLatLT != nil {
		predicates = append(predicates, transaction.LocationLatLT(*i.LocationLatLT))
	}
	if i.LocationLatLTE != nil {
		predicates = append(predicates, transaction.LocationLatLTE(*i.LocationLatLTE))
	}
	if i.LocationLon != nil {
		predicates = append(predicates, transaction.LocationLonEQ(*i.LocationLon))
	}
	if i.LocationLonNEQ != nil {
		predicates = append(predicates, transaction.LocationLonNEQ(*i.LocationLonNEQ))
	}
	if len(i.LocationLonIn) > 0 {
		predicates = append(predicates, transaction.LocationLonIn(i.LocationLonIn...))
	}
	if len(i.LocationLonNotIn) > 0 {
		predicates = append(predicates, transaction.LocationLonNotIn(i.LocationLonNotIn...))
	}
	if i.LocationLonGT != nil {
		predicates = append(predicates, transaction.LocationLonGT(*i.LocationLonGT))
	}
	if i.LocationLonGTE != nil {
		predicates = append(predicates, transaction.LocationLonGTE(*i.LocationLonGTE))
	}
	if i.LocationLonLT != nil {
		predicates = append(predicates, transaction.LocationLonLT(*i.LocationLonLT))
	}
	if i.LocationLonLTE != nil {
		predicates = append(predicates, transaction.LocationLonLTE(*i.LocationLonLTE))
	}
	if i.LocationStoreNumber != nil {
		predicates = append(predicates, transaction.LocationStoreNumberEQ(*i.LocationStoreNumber))
	}
	if i.LocationStoreNumberNEQ != nil {
		predicates = append(predicates, transaction.LocationStoreNumberNEQ(*i.LocationStoreNumberNEQ))
	}
	if len(i.LocationStoreNumberIn) > 0 {
		predicates = append(predicates, transaction.LocationStoreNumberIn(i.LocationStoreNumberIn...))
	}
	if len(i.LocationStoreNumberNotIn) > 0 {
		predicates = append(predicates, transaction.LocationStoreNumberNotIn(i.LocationStoreNumberNotIn...))
	}
	if i.LocationStoreNumberGT != nil {
		predicates = append(predicates, transaction.LocationStoreNumberGT(*i.LocationStoreNumberGT))
	}
	if i.LocationStoreNumberGTE != nil {
		predicates = append(predicates, transaction.LocationStoreNumberGTE(*i.LocationStoreNumberGTE))
	}
	if i.LocationStoreNumberLT != nil {
		predicates = append(predicates, transaction.LocationStoreNumberLT(*i.LocationStoreNumberLT))
	}
	if i.LocationStoreNumberLTE != nil {
		predicates = append(predicates, transaction.LocationStoreNumberLTE(*i.LocationStoreNumberLTE))
	}
	if i.LocationStoreNumberContains != nil {
		predicates = append(predicates, transaction.LocationStoreNumberContains(*i.LocationStoreNumberContains))
	}
	if i.LocationStoreNumberHasPrefix != nil {
		predicates = append(predicates, transaction.LocationStoreNumberHasPrefix(*i.LocationStoreNumberHasPrefix))
	}
	if i.LocationStoreNumberHasSuffix != nil {
		predicates = append(predicates, transaction.LocationStoreNumberHasSuffix(*i.LocationStoreNumberHasSuffix))
	}
	if i.LocationStoreNumberEqualFold != nil {
		predicates = append(predicates, transaction.LocationStoreNumberEqualFold(*i.LocationStoreNumberEqualFold))
	}
	if i.LocationStoreNumberContainsFold != nil {
		predicates = append(predicates, transaction.LocationStoreNumberContainsFold(*i.LocationStoreNumberContainsFold))
	}
	if i.Name != nil {
		predicates = append(predicates, transaction.NameEQ(*i.Name))
	}
	if i.NameNEQ != nil {
		predicates = append(predicates, transaction.NameNEQ(*i.NameNEQ))
	}
	if len(i.NameIn) > 0 {
		predicates = append(predicates, transaction.NameIn(i.NameIn...))
	}
	if len(i.NameNotIn) > 0 {
		predicates = append(predicates, transaction.NameNotIn(i.NameNotIn...))
	}
	if i.NameGT != nil {
		predicates = append(predicates, transaction.NameGT(*i.NameGT))
	}
	if i.NameGTE != nil {
		predicates = append(predicates, transaction.NameGTE(*i.NameGTE))
	}
	if i.NameLT != nil {
		predicates = append(predicates, transaction.NameLT(*i.NameLT))
	}
	if i.NameLTE != nil {
		predicates = append(predicates, transaction.NameLTE(*i.NameLTE))
	}
	if i.NameContains != nil {
		predicates = append(predicates, transaction.NameContains(*i.NameContains))
	}
	if i.NameHasPrefix != nil {
		predicates = append(predicates, transaction.NameHasPrefix(*i.NameHasPrefix))
	}
	if i.NameHasSuffix != nil {
		predicates = append(predicates, transaction.NameHasSuffix(*i.NameHasSuffix))
	}
	if i.NameEqualFold != nil {
		predicates = append(predicates, transaction.NameEqualFold(*i.NameEqualFold))
	}
	if i.NameContainsFold != nil {
		predicates = append(predicates, transaction.NameContainsFold(*i.NameContainsFold))
	}
	if i.MerchantName != nil {
		predicates = append(predicates, transaction.MerchantNameEQ(*i.MerchantName))
	}
	if i.MerchantNameNEQ != nil {
		predicates = append(predicates, transaction.MerchantNameNEQ(*i.MerchantNameNEQ))
	}
	if len(i.MerchantNameIn) > 0 {
		predicates = append(predicates, transaction.MerchantNameIn(i.MerchantNameIn...))
	}
	if len(i.MerchantNameNotIn) > 0 {
		predicates = append(predicates, transaction.MerchantNameNotIn(i.MerchantNameNotIn...))
	}
	if i.MerchantNameGT != nil {
		predicates = append(predicates, transaction.MerchantNameGT(*i.MerchantNameGT))
	}
	if i.MerchantNameGTE != nil {
		predicates = append(predicates, transaction.MerchantNameGTE(*i.MerchantNameGTE))
	}
	if i.MerchantNameLT != nil {
		predicates = append(predicates, transaction.MerchantNameLT(*i.MerchantNameLT))
	}
	if i.MerchantNameLTE != nil {
		predicates = append(predicates, transaction.MerchantNameLTE(*i.MerchantNameLTE))
	}
	if i.MerchantNameContains != nil {
		predicates = append(predicates, transaction.MerchantNameContains(*i.MerchantNameContains))
	}
	if i.MerchantNameHasPrefix != nil {
		predicates = append(predicates, transaction.MerchantNameHasPrefix(*i.MerchantNameHasPrefix))
	}
	if i.MerchantNameHasSuffix != nil {
		predicates = append(predicates, transaction.MerchantNameHasSuffix(*i.MerchantNameHasSuffix))
	}
	if i.MerchantNameEqualFold != nil {
		predicates = append(predicates, transaction.MerchantNameEqualFold(*i.MerchantNameEqualFold))
	}
	if i.MerchantNameContainsFold != nil {
		predicates = append(predicates, transaction.MerchantNameContainsFold(*i.MerchantNameContainsFold))
	}
	if i.PaymentChannel != nil {
		predicates = append(predicates, transaction.PaymentChannelEQ(*i.PaymentChannel))
	}
	if i.PaymentChannelNEQ != nil {
		predicates = append(predicates, transaction.PaymentChannelNEQ(*i.PaymentChannelNEQ))
	}
	if len(i.PaymentChannelIn) > 0 {
		predicates = append(predicates, transaction.PaymentChannelIn(i.PaymentChannelIn...))
	}
	if len(i.PaymentChannelNotIn) > 0 {
		predicates = append(predicates, transaction.PaymentChannelNotIn(i.PaymentChannelNotIn...))
	}
	if i.PaymentChannelGT != nil {
		predicates = append(predicates, transaction.PaymentChannelGT(*i.PaymentChannelGT))
	}
	if i.PaymentChannelGTE != nil {
		predicates = append(predicates, transaction.PaymentChannelGTE(*i.PaymentChannelGTE))
	}
	if i.PaymentChannelLT != nil {
		predicates = append(predicates, transaction.PaymentChannelLT(*i.PaymentChannelLT))
	}
	if i.PaymentChannelLTE != nil {
		predicates = append(predicates, transaction.PaymentChannelLTE(*i.PaymentChannelLTE))
	}
	if i.PaymentChannelContains != nil {
		predicates = append(predicates, transaction.PaymentChannelContains(*i.PaymentChannelContains))
	}
	if i.PaymentChannelHasPrefix != nil {
		predicates = append(predicates, transaction.PaymentChannelHasPrefix(*i.PaymentChannelHasPrefix))
	}
	if i.PaymentChannelHasSuffix != nil {
		predicates = append(predicates, transaction.PaymentChannelHasSuffix(*i.PaymentChannelHasSuffix))
	}
	if i.PaymentChannelEqualFold != nil {
		predicates = append(predicates, transaction.PaymentChannelEqualFold(*i.PaymentChannelEqualFold))
	}
	if i.PaymentChannelContainsFold != nil {
		predicates = append(predicates, transaction.PaymentChannelContainsFold(*i.PaymentChannelContainsFold))
	}
	if i.Pending != nil {
		predicates = append(predicates, transaction.PendingEQ(*i.Pending))
	}
	if i.PendingNEQ != nil {
		predicates = append(predicates, transaction.PendingNEQ(*i.PendingNEQ))
	}
	if i.PendingTransactionID != nil {
		predicates = append(predicates, transaction.PendingTransactionIDEQ(*i.PendingTransactionID))
	}
	if i.PendingTransactionIDNEQ != nil {
		predicates = append(predicates, transaction.PendingTransactionIDNEQ(*i.PendingTransactionIDNEQ))
	}
	if len(i.PendingTransactionIDIn) > 0 {
		predicates = append(predicates, transaction.PendingTransactionIDIn(i.PendingTransactionIDIn...))
	}
	if len(i.PendingTransactionIDNotIn) > 0 {
		predicates = append(predicates, transaction.PendingTransactionIDNotIn(i.PendingTransactionIDNotIn...))
	}
	if i.PendingTransactionIDGT != nil {
		predicates = append(predicates, transaction.PendingTransactionIDGT(*i.PendingTransactionIDGT))
	}
	if i.PendingTransactionIDGTE != nil {
		predicates = append(predicates, transaction.PendingTransactionIDGTE(*i.PendingTransactionIDGTE))
	}
	if i.PendingTransactionIDLT != nil {
		predicates = append(predicates, transaction.PendingTransactionIDLT(*i.PendingTransactionIDLT))
	}
	if i.PendingTransactionIDLTE != nil {
		predicates = append(predicates, transaction.PendingTransactionIDLTE(*i.PendingTransactionIDLTE))
	}
	if i.PendingTransactionIDContains != nil {
		predicates = append(predicates, transaction.PendingTransactionIDContains(*i.PendingTransactionIDContains))
	}
	if i.PendingTransactionIDHasPrefix != nil {
		predicates = append(predicates, transaction.PendingTransactionIDHasPrefix(*i.PendingTransactionIDHasPrefix))
	}
	if i.PendingTransactionIDHasSuffix != nil {
		predicates = append(predicates, transaction.PendingTransactionIDHasSuffix(*i.PendingTransactionIDHasSuffix))
	}
	if i.PendingTransactionIDEqualFold != nil {
		predicates = append(predicates, transaction.PendingTransactionIDEqualFold(*i.PendingTransactionIDEqualFold))
	}
	if i.PendingTransactionIDContainsFold != nil {
		predicates = append(predicates, transaction.PendingTransactionIDContainsFold(*i.PendingTransactionIDContainsFold))
	}
	if i.AccountOwner != nil {
		predicates = append(predicates, transaction.AccountOwnerEQ(*i.AccountOwner))
	}
	if i.AccountOwnerNEQ != nil {
		predicates = append(predicates, transaction.AccountOwnerNEQ(*i.AccountOwnerNEQ))
	}
	if len(i.AccountOwnerIn) > 0 {
		predicates = append(predicates, transaction.AccountOwnerIn(i.AccountOwnerIn...))
	}
	if len(i.AccountOwnerNotIn) > 0 {
		predicates = append(predicates, transaction.AccountOwnerNotIn(i.AccountOwnerNotIn...))
	}
	if i.AccountOwnerGT != nil {
		predicates = append(predicates, transaction.AccountOwnerGT(*i.AccountOwnerGT))
	}
	if i.AccountOwnerGTE != nil {
		predicates = append(predicates, transaction.AccountOwnerGTE(*i.AccountOwnerGTE))
	}
	if i.AccountOwnerLT != nil {
		predicates = append(predicates, transaction.AccountOwnerLT(*i.AccountOwnerLT))
	}
	if i.AccountOwnerLTE != nil {
		predicates = append(predicates, transaction.AccountOwnerLTE(*i.AccountOwnerLTE))
	}
	if i.AccountOwnerContains != nil {
		predicates = append(predicates, transaction.AccountOwnerContains(*i.AccountOwnerContains))
	}
	if i.AccountOwnerHasPrefix != nil {
		predicates = append(predicates, transaction.AccountOwnerHasPrefix(*i.AccountOwnerHasPrefix))
	}
	if i.AccountOwnerHasSuffix != nil {
		predicates = append(predicates, transaction.AccountOwnerHasSuffix(*i.AccountOwnerHasSuffix))
	}
	if i.AccountOwnerEqualFold != nil {
		predicates = append(predicates, transaction.AccountOwnerEqualFold(*i.AccountOwnerEqualFold))
	}
	if i.AccountOwnerContainsFold != nil {
		predicates = append(predicates, transaction.AccountOwnerContainsFold(*i.AccountOwnerContainsFold))
	}
	if i.TransactionID != nil {
		predicates = append(predicates, transaction.TransactionIDEQ(*i.TransactionID))
	}
	if i.TransactionIDNEQ != nil {
		predicates = append(predicates, transaction.TransactionIDNEQ(*i.TransactionIDNEQ))
	}
	if len(i.TransactionIDIn) > 0 {
		predicates = append(predicates, transaction.TransactionIDIn(i.TransactionIDIn...))
	}
	if len(i.TransactionIDNotIn) > 0 {
		predicates = append(predicates, transaction.TransactionIDNotIn(i.TransactionIDNotIn...))
	}
	if i.TransactionIDGT != nil {
		predicates = append(predicates, transaction.TransactionIDGT(*i.TransactionIDGT))
	}
	if i.TransactionIDGTE != nil {
		predicates = append(predicates, transaction.TransactionIDGTE(*i.TransactionIDGTE))
	}
	if i.TransactionIDLT != nil {
		predicates = append(predicates, transaction.TransactionIDLT(*i.TransactionIDLT))
	}
	if i.TransactionIDLTE != nil {
		predicates = append(predicates, transaction.TransactionIDLTE(*i.TransactionIDLTE))
	}
	if i.TransactionIDContains != nil {
		predicates = append(predicates, transaction.TransactionIDContains(*i.TransactionIDContains))
	}
	if i.TransactionIDHasPrefix != nil {
		predicates = append(predicates, transaction.TransactionIDHasPrefix(*i.TransactionIDHasPrefix))
	}
	if i.TransactionIDHasSuffix != nil {
		predicates = append(predicates, transaction.TransactionIDHasSuffix(*i.TransactionIDHasSuffix))
	}
	if i.TransactionIDEqualFold != nil {
		predicates = append(predicates, transaction.TransactionIDEqualFold(*i.TransactionIDEqualFold))
	}
	if i.TransactionIDContainsFold != nil {
		predicates = append(predicates, transaction.TransactionIDContainsFold(*i.TransactionIDContainsFold))
	}
	if i.TransactionCode != nil {
		predicates = append(predicates, transaction.TransactionCodeEQ(*i.TransactionCode))
	}
	if i.TransactionCodeNEQ != nil {
		predicates = append(predicates, transaction.TransactionCodeNEQ(*i.TransactionCodeNEQ))
	}
	if len(i.TransactionCodeIn) > 0 {
		predicates = append(predicates, transaction.TransactionCodeIn(i.TransactionCodeIn...))
	}
	if len(i.TransactionCodeNotIn) > 0 {
		predicates = append(predicates, transaction.TransactionCodeNotIn(i.TransactionCodeNotIn...))
	}
	if i.TransactionCodeGT != nil {
		predicates = append(predicates, transaction.TransactionCodeGT(*i.TransactionCodeGT))
	}
	if i.TransactionCodeGTE != nil {
		predicates = append(predicates, transaction.TransactionCodeGTE(*i.TransactionCodeGTE))
	}
	if i.TransactionCodeLT != nil {
		predicates = append(predicates, transaction.TransactionCodeLT(*i.TransactionCodeLT))
	}
	if i.TransactionCodeLTE != nil {
		predicates = append(predicates, transaction.TransactionCodeLTE(*i.TransactionCodeLTE))
	}
	if i.TransactionCodeContains != nil {
		predicates = append(predicates, transaction.TransactionCodeContains(*i.TransactionCodeContains))
	}
	if i.TransactionCodeHasPrefix != nil {
		predicates = append(predicates, transaction.TransactionCodeHasPrefix(*i.TransactionCodeHasPrefix))
	}
	if i.TransactionCodeHasSuffix != nil {
		predicates = append(predicates, transaction.TransactionCodeHasSuffix(*i.TransactionCodeHasSuffix))
	}
	if i.TransactionCodeEqualFold != nil {
		predicates = append(predicates, transaction.TransactionCodeEqualFold(*i.TransactionCodeEqualFold))
	}
	if i.TransactionCodeContainsFold != nil {
		predicates = append(predicates, transaction.TransactionCodeContainsFold(*i.TransactionCodeContainsFold))
	}
	if i.CreatedAt != nil {
		predicates = append(predicates, transaction.CreatedAtEQ(*i.CreatedAt))
	}
	if i.CreatedAtNEQ != nil {
		predicates = append(predicates, transaction.CreatedAtNEQ(*i.CreatedAtNEQ))
	}
	if len(i.CreatedAtIn) > 0 {
		predicates = append(predicates, transaction.CreatedAtIn(i.CreatedAtIn...))
	}
	if len(i.CreatedAtNotIn) > 0 {
		predicates = append(predicates, transaction.CreatedAtNotIn(i.CreatedAtNotIn...))
	}
	if i.CreatedAtGT != nil {
		predicates = append(predicates, transaction.CreatedAtGT(*i.CreatedAtGT))
	}
	if i.CreatedAtGTE != nil {
		predicates = append(predicates, transaction.CreatedAtGTE(*i.CreatedAtGTE))
	}
	if i.CreatedAtLT != nil {
		predicates = append(predicates, transaction.CreatedAtLT(*i.CreatedAtLT))
	}
	if i.CreatedAtLTE != nil {
		predicates = append(predicates, transaction.CreatedAtLTE(*i.CreatedAtLTE))
	}

	if i.HasInstitutionAccount != nil {
		p := transaction.HasInstitutionAccount()
		if !*i.HasInstitutionAccount {
			p = transaction.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasInstitutionAccountWith) > 0 {
		with := make([]predicate.PlaidInstitutionAccount, 0, len(i.HasInstitutionAccountWith))
		for _, w := range i.HasInstitutionAccountWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasInstitutionAccountWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, transaction.HasInstitutionAccountWith(with...))
	}
	if i.HasTransactionCategories != nil {
		p := transaction.HasTransactionCategories()
		if !*i.HasTransactionCategories {
			p = transaction.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasTransactionCategoriesWith) > 0 {
		with := make([]predicate.SpendingCategory, 0, len(i.HasTransactionCategoriesWith))
		for _, w := range i.HasTransactionCategoriesWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasTransactionCategoriesWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, transaction.HasTransactionCategoriesWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyTransactionWhereInput
	case 1:
		return predicates[0], nil
	default:
		return transaction.And(predicates...), nil
	}
}

// TransactionSyncWhereInput represents a where input for filtering TransactionSync queries.
type TransactionSyncWhereInput struct {
	Predicates []predicate.TransactionSync  `json:"-"`
	Not        *TransactionSyncWhereInput   `json:"not,omitempty"`
	Or         []*TransactionSyncWhereInput `json:"or,omitempty"`
	And        []*TransactionSyncWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *int  `json:"id,omitempty"`
	IDNEQ   *int  `json:"idNEQ,omitempty"`
	IDIn    []int `json:"idIn,omitempty"`
	IDNotIn []int `json:"idNotIn,omitempty"`
	IDGT    *int  `json:"idGT,omitempty"`
	IDGTE   *int  `json:"idGTE,omitempty"`
	IDLT    *int  `json:"idLT,omitempty"`
	IDLTE   *int  `json:"idLTE,omitempty"`

	// "created_at" field predicates.
	CreatedAt      *time.Time  `json:"createdAt,omitempty"`
	CreatedAtNEQ   *time.Time  `json:"createdAtNEQ,omitempty"`
	CreatedAtIn    []time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn []time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGT    *time.Time  `json:"createdAtGT,omitempty"`
	CreatedAtGTE   *time.Time  `json:"createdAtGTE,omitempty"`
	CreatedAtLT    *time.Time  `json:"createdAtLT,omitempty"`
	CreatedAtLTE   *time.Time  `json:"createdAtLTE,omitempty"`

	// "cursor" field predicates.
	Cursor             *string  `json:"cursor,omitempty"`
	CursorNEQ          *string  `json:"cursorNEQ,omitempty"`
	CursorIn           []string `json:"cursorIn,omitempty"`
	CursorNotIn        []string `json:"cursorNotIn,omitempty"`
	CursorGT           *string  `json:"cursorGT,omitempty"`
	CursorGTE          *string  `json:"cursorGTE,omitempty"`
	CursorLT           *string  `json:"cursorLT,omitempty"`
	CursorLTE          *string  `json:"cursorLTE,omitempty"`
	CursorContains     *string  `json:"cursorContains,omitempty"`
	CursorHasPrefix    *string  `json:"cursorHasPrefix,omitempty"`
	CursorHasSuffix    *string  `json:"cursorHasSuffix,omitempty"`
	CursorEqualFold    *string  `json:"cursorEqualFold,omitempty"`
	CursorContainsFold *string  `json:"cursorContainsFold,omitempty"`

	// "item" edge predicates.
	HasItem     *bool                  `json:"hasItem,omitempty"`
	HasItemWith []*PlaidItemWhereInput `json:"hasItemWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *TransactionSyncWhereInput) AddPredicates(predicates ...predicate.TransactionSync) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the TransactionSyncWhereInput filter on the TransactionSyncQuery builder.
func (i *TransactionSyncWhereInput) Filter(q *TransactionSyncQuery) (*TransactionSyncQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyTransactionSyncWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyTransactionSyncWhereInput is returned in case the TransactionSyncWhereInput is empty.
var ErrEmptyTransactionSyncWhereInput = errors.New("ent: empty predicate TransactionSyncWhereInput")

// P returns a predicate for filtering transactionsyncs.
// An error is returned if the input is empty or invalid.
func (i *TransactionSyncWhereInput) P() (predicate.TransactionSync, error) {
	var predicates []predicate.TransactionSync
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, transactionsync.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.TransactionSync, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, transactionsync.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.TransactionSync, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, transactionsync.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, transactionsync.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, transactionsync.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, transactionsync.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, transactionsync.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, transactionsync.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, transactionsync.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, transactionsync.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, transactionsync.IDLTE(*i.IDLTE))
	}
	if i.CreatedAt != nil {
		predicates = append(predicates, transactionsync.CreatedAtEQ(*i.CreatedAt))
	}
	if i.CreatedAtNEQ != nil {
		predicates = append(predicates, transactionsync.CreatedAtNEQ(*i.CreatedAtNEQ))
	}
	if len(i.CreatedAtIn) > 0 {
		predicates = append(predicates, transactionsync.CreatedAtIn(i.CreatedAtIn...))
	}
	if len(i.CreatedAtNotIn) > 0 {
		predicates = append(predicates, transactionsync.CreatedAtNotIn(i.CreatedAtNotIn...))
	}
	if i.CreatedAtGT != nil {
		predicates = append(predicates, transactionsync.CreatedAtGT(*i.CreatedAtGT))
	}
	if i.CreatedAtGTE != nil {
		predicates = append(predicates, transactionsync.CreatedAtGTE(*i.CreatedAtGTE))
	}
	if i.CreatedAtLT != nil {
		predicates = append(predicates, transactionsync.CreatedAtLT(*i.CreatedAtLT))
	}
	if i.CreatedAtLTE != nil {
		predicates = append(predicates, transactionsync.CreatedAtLTE(*i.CreatedAtLTE))
	}
	if i.Cursor != nil {
		predicates = append(predicates, transactionsync.CursorEQ(*i.Cursor))
	}
	if i.CursorNEQ != nil {
		predicates = append(predicates, transactionsync.CursorNEQ(*i.CursorNEQ))
	}
	if len(i.CursorIn) > 0 {
		predicates = append(predicates, transactionsync.CursorIn(i.CursorIn...))
	}
	if len(i.CursorNotIn) > 0 {
		predicates = append(predicates, transactionsync.CursorNotIn(i.CursorNotIn...))
	}
	if i.CursorGT != nil {
		predicates = append(predicates, transactionsync.CursorGT(*i.CursorGT))
	}
	if i.CursorGTE != nil {
		predicates = append(predicates, transactionsync.CursorGTE(*i.CursorGTE))
	}
	if i.CursorLT != nil {
		predicates = append(predicates, transactionsync.CursorLT(*i.CursorLT))
	}
	if i.CursorLTE != nil {
		predicates = append(predicates, transactionsync.CursorLTE(*i.CursorLTE))
	}
	if i.CursorContains != nil {
		predicates = append(predicates, transactionsync.CursorContains(*i.CursorContains))
	}
	if i.CursorHasPrefix != nil {
		predicates = append(predicates, transactionsync.CursorHasPrefix(*i.CursorHasPrefix))
	}
	if i.CursorHasSuffix != nil {
		predicates = append(predicates, transactionsync.CursorHasSuffix(*i.CursorHasSuffix))
	}
	if i.CursorEqualFold != nil {
		predicates = append(predicates, transactionsync.CursorEqualFold(*i.CursorEqualFold))
	}
	if i.CursorContainsFold != nil {
		predicates = append(predicates, transactionsync.CursorContainsFold(*i.CursorContainsFold))
	}

	if i.HasItem != nil {
		p := transactionsync.HasItem()
		if !*i.HasItem {
			p = transactionsync.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasItemWith) > 0 {
		with := make([]predicate.PlaidItem, 0, len(i.HasItemWith))
		for _, w := range i.HasItemWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasItemWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, transactionsync.HasItemWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyTransactionSyncWhereInput
	case 1:
		return predicates[0], nil
	default:
		return transactionsync.And(predicates...), nil
	}
}

// UserWhereInput represents a where input for filtering User queries.
type UserWhereInput struct {
	Predicates []predicate.User  `json:"-"`
	Not        *UserWhereInput   `json:"not,omitempty"`
	Or         []*UserWhereInput `json:"or,omitempty"`
	And        []*UserWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *int  `json:"id,omitempty"`
	IDNEQ   *int  `json:"idNEQ,omitempty"`
	IDIn    []int `json:"idIn,omitempty"`
	IDNotIn []int `json:"idNotIn,omitempty"`
	IDGT    *int  `json:"idGT,omitempty"`
	IDGTE   *int  `json:"idGTE,omitempty"`
	IDLT    *int  `json:"idLT,omitempty"`
	IDLTE   *int  `json:"idLTE,omitempty"`

	// "identity_provider_id" field predicates.
	IdentityProviderID             *string  `json:"identityProviderID,omitempty"`
	IdentityProviderIDNEQ          *string  `json:"identityProviderIDNEQ,omitempty"`
	IdentityProviderIDIn           []string `json:"identityProviderIDIn,omitempty"`
	IdentityProviderIDNotIn        []string `json:"identityProviderIDNotIn,omitempty"`
	IdentityProviderIDGT           *string  `json:"identityProviderIDGT,omitempty"`
	IdentityProviderIDGTE          *string  `json:"identityProviderIDGTE,omitempty"`
	IdentityProviderIDLT           *string  `json:"identityProviderIDLT,omitempty"`
	IdentityProviderIDLTE          *string  `json:"identityProviderIDLTE,omitempty"`
	IdentityProviderIDContains     *string  `json:"identityProviderIDContains,omitempty"`
	IdentityProviderIDHasPrefix    *string  `json:"identityProviderIDHasPrefix,omitempty"`
	IdentityProviderIDHasSuffix    *string  `json:"identityProviderIDHasSuffix,omitempty"`
	IdentityProviderIDIsNil        bool     `json:"identityProviderIDIsNil,omitempty"`
	IdentityProviderIDNotNil       bool     `json:"identityProviderIDNotNil,omitempty"`
	IdentityProviderIDEqualFold    *string  `json:"identityProviderIDEqualFold,omitempty"`
	IdentityProviderIDContainsFold *string  `json:"identityProviderIDContainsFold,omitempty"`

	// "offer_frequency" field predicates.
	OfferFrequency      *user.OfferFrequency  `json:"offerFrequency,omitempty"`
	OfferFrequencyNEQ   *user.OfferFrequency  `json:"offerFrequencyNEQ,omitempty"`
	OfferFrequencyIn    []user.OfferFrequency `json:"offerFrequencyIn,omitempty"`
	OfferFrequencyNotIn []user.OfferFrequency `json:"offerFrequencyNotIn,omitempty"`

	// "home_country" field predicates.
	HomeCountry             *string  `json:"homeCountry,omitempty"`
	HomeCountryNEQ          *string  `json:"homeCountryNEQ,omitempty"`
	HomeCountryIn           []string `json:"homeCountryIn,omitempty"`
	HomeCountryNotIn        []string `json:"homeCountryNotIn,omitempty"`
	HomeCountryGT           *string  `json:"homeCountryGT,omitempty"`
	HomeCountryGTE          *string  `json:"homeCountryGTE,omitempty"`
	HomeCountryLT           *string  `json:"homeCountryLT,omitempty"`
	HomeCountryLTE          *string  `json:"homeCountryLTE,omitempty"`
	HomeCountryContains     *string  `json:"homeCountryContains,omitempty"`
	HomeCountryHasPrefix    *string  `json:"homeCountryHasPrefix,omitempty"`
	HomeCountryHasSuffix    *string  `json:"homeCountryHasSuffix,omitempty"`
	HomeCountryIsNil        bool     `json:"homeCountryIsNil,omitempty"`
	HomeCountryNotNil       bool     `json:"homeCountryNotNil,omitempty"`
	HomeCountryEqualFold    *string  `json:"homeCountryEqualFold,omitempty"`
	HomeCountryContainsFold *string  `json:"homeCountryContainsFold,omitempty"`

	// "home_state" field predicates.
	HomeState             *string  `json:"homeState,omitempty"`
	HomeStateNEQ          *string  `json:"homeStateNEQ,omitempty"`
	HomeStateIn           []string `json:"homeStateIn,omitempty"`
	HomeStateNotIn        []string `json:"homeStateNotIn,omitempty"`
	HomeStateGT           *string  `json:"homeStateGT,omitempty"`
	HomeStateGTE          *string  `json:"homeStateGTE,omitempty"`
	HomeStateLT           *string  `json:"homeStateLT,omitempty"`
	HomeStateLTE          *string  `json:"homeStateLTE,omitempty"`
	HomeStateContains     *string  `json:"homeStateContains,omitempty"`
	HomeStateHasPrefix    *string  `json:"homeStateHasPrefix,omitempty"`
	HomeStateHasSuffix    *string  `json:"homeStateHasSuffix,omitempty"`
	HomeStateIsNil        bool     `json:"homeStateIsNil,omitempty"`
	HomeStateNotNil       bool     `json:"homeStateNotNil,omitempty"`
	HomeStateEqualFold    *string  `json:"homeStateEqualFold,omitempty"`
	HomeStateContainsFold *string  `json:"homeStateContainsFold,omitempty"`

	// "home_city" field predicates.
	HomeCity             *string  `json:"homeCity,omitempty"`
	HomeCityNEQ          *string  `json:"homeCityNEQ,omitempty"`
	HomeCityIn           []string `json:"homeCityIn,omitempty"`
	HomeCityNotIn        []string `json:"homeCityNotIn,omitempty"`
	HomeCityGT           *string  `json:"homeCityGT,omitempty"`
	HomeCityGTE          *string  `json:"homeCityGTE,omitempty"`
	HomeCityLT           *string  `json:"homeCityLT,omitempty"`
	HomeCityLTE          *string  `json:"homeCityLTE,omitempty"`
	HomeCityContains     *string  `json:"homeCityContains,omitempty"`
	HomeCityHasPrefix    *string  `json:"homeCityHasPrefix,omitempty"`
	HomeCityHasSuffix    *string  `json:"homeCityHasSuffix,omitempty"`
	HomeCityIsNil        bool     `json:"homeCityIsNil,omitempty"`
	HomeCityNotNil       bool     `json:"homeCityNotNil,omitempty"`
	HomeCityEqualFold    *string  `json:"homeCityEqualFold,omitempty"`
	HomeCityContainsFold *string  `json:"homeCityContainsFold,omitempty"`

	// "plaid_items" edge predicates.
	HasPlaidItems     *bool                  `json:"hasPlaidItems,omitempty"`
	HasPlaidItemsWith []*PlaidItemWhereInput `json:"hasPlaidItemsWith,omitempty"`

	// "spending_categories" edge predicates.
	HasSpendingCategories     *bool                         `json:"hasSpendingCategories,omitempty"`
	HasSpendingCategoriesWith []*SpendingCategoryWhereInput `json:"hasSpendingCategoriesWith,omitempty"`

	// "notification_channels" edge predicates.
	HasNotificationChannels     *bool                                           `json:"hasNotificationChannels,omitempty"`
	HasNotificationChannelsWith []*UserNotificationChannelPreferencesWhereInput `json:"hasNotificationChannelsWith,omitempty"`

	// "notifications" edge predicates.
	HasNotifications     *bool                     `json:"hasNotifications,omitempty"`
	HasNotificationsWith []*NotificationWhereInput `json:"hasNotificationsWith,omitempty"`

	// "available_discount_offers" edge predicates.
	HasAvailableDiscountOffers     *bool                      `json:"hasAvailableDiscountOffers,omitempty"`
	HasAvailableDiscountOffersWith []*DiscountOfferWhereInput `json:"hasAvailableDiscountOffersWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *UserWhereInput) AddPredicates(predicates ...predicate.User) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the UserWhereInput filter on the UserQuery builder.
func (i *UserWhereInput) Filter(q *UserQuery) (*UserQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyUserWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyUserWhereInput is returned in case the UserWhereInput is empty.
var ErrEmptyUserWhereInput = errors.New("ent: empty predicate UserWhereInput")

// P returns a predicate for filtering users.
// An error is returned if the input is empty or invalid.
func (i *UserWhereInput) P() (predicate.User, error) {
	var predicates []predicate.User
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, user.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.User, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, user.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.User, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, user.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, user.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, user.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, user.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, user.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, user.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, user.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, user.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, user.IDLTE(*i.IDLTE))
	}
	if i.IdentityProviderID != nil {
		predicates = append(predicates, user.IdentityProviderIDEQ(*i.IdentityProviderID))
	}
	if i.IdentityProviderIDNEQ != nil {
		predicates = append(predicates, user.IdentityProviderIDNEQ(*i.IdentityProviderIDNEQ))
	}
	if len(i.IdentityProviderIDIn) > 0 {
		predicates = append(predicates, user.IdentityProviderIDIn(i.IdentityProviderIDIn...))
	}
	if len(i.IdentityProviderIDNotIn) > 0 {
		predicates = append(predicates, user.IdentityProviderIDNotIn(i.IdentityProviderIDNotIn...))
	}
	if i.IdentityProviderIDGT != nil {
		predicates = append(predicates, user.IdentityProviderIDGT(*i.IdentityProviderIDGT))
	}
	if i.IdentityProviderIDGTE != nil {
		predicates = append(predicates, user.IdentityProviderIDGTE(*i.IdentityProviderIDGTE))
	}
	if i.IdentityProviderIDLT != nil {
		predicates = append(predicates, user.IdentityProviderIDLT(*i.IdentityProviderIDLT))
	}
	if i.IdentityProviderIDLTE != nil {
		predicates = append(predicates, user.IdentityProviderIDLTE(*i.IdentityProviderIDLTE))
	}
	if i.IdentityProviderIDContains != nil {
		predicates = append(predicates, user.IdentityProviderIDContains(*i.IdentityProviderIDContains))
	}
	if i.IdentityProviderIDHasPrefix != nil {
		predicates = append(predicates, user.IdentityProviderIDHasPrefix(*i.IdentityProviderIDHasPrefix))
	}
	if i.IdentityProviderIDHasSuffix != nil {
		predicates = append(predicates, user.IdentityProviderIDHasSuffix(*i.IdentityProviderIDHasSuffix))
	}
	if i.IdentityProviderIDIsNil {
		predicates = append(predicates, user.IdentityProviderIDIsNil())
	}
	if i.IdentityProviderIDNotNil {
		predicates = append(predicates, user.IdentityProviderIDNotNil())
	}
	if i.IdentityProviderIDEqualFold != nil {
		predicates = append(predicates, user.IdentityProviderIDEqualFold(*i.IdentityProviderIDEqualFold))
	}
	if i.IdentityProviderIDContainsFold != nil {
		predicates = append(predicates, user.IdentityProviderIDContainsFold(*i.IdentityProviderIDContainsFold))
	}
	if i.OfferFrequency != nil {
		predicates = append(predicates, user.OfferFrequencyEQ(*i.OfferFrequency))
	}
	if i.OfferFrequencyNEQ != nil {
		predicates = append(predicates, user.OfferFrequencyNEQ(*i.OfferFrequencyNEQ))
	}
	if len(i.OfferFrequencyIn) > 0 {
		predicates = append(predicates, user.OfferFrequencyIn(i.OfferFrequencyIn...))
	}
	if len(i.OfferFrequencyNotIn) > 0 {
		predicates = append(predicates, user.OfferFrequencyNotIn(i.OfferFrequencyNotIn...))
	}
	if i.HomeCountry != nil {
		predicates = append(predicates, user.HomeCountryEQ(*i.HomeCountry))
	}
	if i.HomeCountryNEQ != nil {
		predicates = append(predicates, user.HomeCountryNEQ(*i.HomeCountryNEQ))
	}
	if len(i.HomeCountryIn) > 0 {
		predicates = append(predicates, user.HomeCountryIn(i.HomeCountryIn...))
	}
	if len(i.HomeCountryNotIn) > 0 {
		predicates = append(predicates, user.HomeCountryNotIn(i.HomeCountryNotIn...))
	}
	if i.HomeCountryGT != nil {
		predicates = append(predicates, user.HomeCountryGT(*i.HomeCountryGT))
	}
	if i.HomeCountryGTE != nil {
		predicates = append(predicates, user.HomeCountryGTE(*i.HomeCountryGTE))
	}
	if i.HomeCountryLT != nil {
		predicates = append(predicates, user.HomeCountryLT(*i.HomeCountryLT))
	}
	if i.HomeCountryLTE != nil {
		predicates = append(predicates, user.HomeCountryLTE(*i.HomeCountryLTE))
	}
	if i.HomeCountryContains != nil {
		predicates = append(predicates, user.HomeCountryContains(*i.HomeCountryContains))
	}
	if i.HomeCountryHasPrefix != nil {
		predicates = append(predicates, user.HomeCountryHasPrefix(*i.HomeCountryHasPrefix))
	}
	if i.HomeCountryHasSuffix != nil {
		predicates = append(predicates, user.HomeCountryHasSuffix(*i.HomeCountryHasSuffix))
	}
	if i.HomeCountryIsNil {
		predicates = append(predicates, user.HomeCountryIsNil())
	}
	if i.HomeCountryNotNil {
		predicates = append(predicates, user.HomeCountryNotNil())
	}
	if i.HomeCountryEqualFold != nil {
		predicates = append(predicates, user.HomeCountryEqualFold(*i.HomeCountryEqualFold))
	}
	if i.HomeCountryContainsFold != nil {
		predicates = append(predicates, user.HomeCountryContainsFold(*i.HomeCountryContainsFold))
	}
	if i.HomeState != nil {
		predicates = append(predicates, user.HomeStateEQ(*i.HomeState))
	}
	if i.HomeStateNEQ != nil {
		predicates = append(predicates, user.HomeStateNEQ(*i.HomeStateNEQ))
	}
	if len(i.HomeStateIn) > 0 {
		predicates = append(predicates, user.HomeStateIn(i.HomeStateIn...))
	}
	if len(i.HomeStateNotIn) > 0 {
		predicates = append(predicates, user.HomeStateNotIn(i.HomeStateNotIn...))
	}
	if i.HomeStateGT != nil {
		predicates = append(predicates, user.HomeStateGT(*i.HomeStateGT))
	}
	if i.HomeStateGTE != nil {
		predicates = append(predicates, user.HomeStateGTE(*i.HomeStateGTE))
	}
	if i.HomeStateLT != nil {
		predicates = append(predicates, user.HomeStateLT(*i.HomeStateLT))
	}
	if i.HomeStateLTE != nil {
		predicates = append(predicates, user.HomeStateLTE(*i.HomeStateLTE))
	}
	if i.HomeStateContains != nil {
		predicates = append(predicates, user.HomeStateContains(*i.HomeStateContains))
	}
	if i.HomeStateHasPrefix != nil {
		predicates = append(predicates, user.HomeStateHasPrefix(*i.HomeStateHasPrefix))
	}
	if i.HomeStateHasSuffix != nil {
		predicates = append(predicates, user.HomeStateHasSuffix(*i.HomeStateHasSuffix))
	}
	if i.HomeStateIsNil {
		predicates = append(predicates, user.HomeStateIsNil())
	}
	if i.HomeStateNotNil {
		predicates = append(predicates, user.HomeStateNotNil())
	}
	if i.HomeStateEqualFold != nil {
		predicates = append(predicates, user.HomeStateEqualFold(*i.HomeStateEqualFold))
	}
	if i.HomeStateContainsFold != nil {
		predicates = append(predicates, user.HomeStateContainsFold(*i.HomeStateContainsFold))
	}
	if i.HomeCity != nil {
		predicates = append(predicates, user.HomeCityEQ(*i.HomeCity))
	}
	if i.HomeCityNEQ != nil {
		predicates = append(predicates, user.HomeCityNEQ(*i.HomeCityNEQ))
	}
	if len(i.HomeCityIn) > 0 {
		predicates = append(predicates, user.HomeCityIn(i.HomeCityIn...))
	}
	if len(i.HomeCityNotIn) > 0 {
		predicates = append(predicates, user.HomeCityNotIn(i.HomeCityNotIn...))
	}
	if i.HomeCityGT != nil {
		predicates = append(predicates, user.HomeCityGT(*i.HomeCityGT))
	}
	if i.HomeCityGTE != nil {
		predicates = append(predicates, user.HomeCityGTE(*i.HomeCityGTE))
	}
	if i.HomeCityLT != nil {
		predicates = append(predicates, user.HomeCityLT(*i.HomeCityLT))
	}
	if i.HomeCityLTE != nil {
		predicates = append(predicates, user.HomeCityLTE(*i.HomeCityLTE))
	}
	if i.HomeCityContains != nil {
		predicates = append(predicates, user.HomeCityContains(*i.HomeCityContains))
	}
	if i.HomeCityHasPrefix != nil {
		predicates = append(predicates, user.HomeCityHasPrefix(*i.HomeCityHasPrefix))
	}
	if i.HomeCityHasSuffix != nil {
		predicates = append(predicates, user.HomeCityHasSuffix(*i.HomeCityHasSuffix))
	}
	if i.HomeCityIsNil {
		predicates = append(predicates, user.HomeCityIsNil())
	}
	if i.HomeCityNotNil {
		predicates = append(predicates, user.HomeCityNotNil())
	}
	if i.HomeCityEqualFold != nil {
		predicates = append(predicates, user.HomeCityEqualFold(*i.HomeCityEqualFold))
	}
	if i.HomeCityContainsFold != nil {
		predicates = append(predicates, user.HomeCityContainsFold(*i.HomeCityContainsFold))
	}

	if i.HasPlaidItems != nil {
		p := user.HasPlaidItems()
		if !*i.HasPlaidItems {
			p = user.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasPlaidItemsWith) > 0 {
		with := make([]predicate.PlaidItem, 0, len(i.HasPlaidItemsWith))
		for _, w := range i.HasPlaidItemsWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasPlaidItemsWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, user.HasPlaidItemsWith(with...))
	}
	if i.HasSpendingCategories != nil {
		p := user.HasSpendingCategories()
		if !*i.HasSpendingCategories {
			p = user.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasSpendingCategoriesWith) > 0 {
		with := make([]predicate.SpendingCategory, 0, len(i.HasSpendingCategoriesWith))
		for _, w := range i.HasSpendingCategoriesWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasSpendingCategoriesWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, user.HasSpendingCategoriesWith(with...))
	}
	if i.HasNotificationChannels != nil {
		p := user.HasNotificationChannels()
		if !*i.HasNotificationChannels {
			p = user.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasNotificationChannelsWith) > 0 {
		with := make([]predicate.UserNotificationChannelPreferences, 0, len(i.HasNotificationChannelsWith))
		for _, w := range i.HasNotificationChannelsWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasNotificationChannelsWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, user.HasNotificationChannelsWith(with...))
	}
	if i.HasNotifications != nil {
		p := user.HasNotifications()
		if !*i.HasNotifications {
			p = user.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasNotificationsWith) > 0 {
		with := make([]predicate.Notification, 0, len(i.HasNotificationsWith))
		for _, w := range i.HasNotificationsWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasNotificationsWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, user.HasNotificationsWith(with...))
	}
	if i.HasAvailableDiscountOffers != nil {
		p := user.HasAvailableDiscountOffers()
		if !*i.HasAvailableDiscountOffers {
			p = user.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasAvailableDiscountOffersWith) > 0 {
		with := make([]predicate.DiscountOffer, 0, len(i.HasAvailableDiscountOffersWith))
		for _, w := range i.HasAvailableDiscountOffersWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasAvailableDiscountOffersWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, user.HasAvailableDiscountOffersWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyUserWhereInput
	case 1:
		return predicates[0], nil
	default:
		return user.And(predicates...), nil
	}
}

// UserNotificationChannelPreferencesWhereInput represents a where input for filtering UserNotificationChannelPreferences queries.
type UserNotificationChannelPreferencesWhereInput struct {
	Predicates []predicate.UserNotificationChannelPreferences  `json:"-"`
	Not        *UserNotificationChannelPreferencesWhereInput   `json:"not,omitempty"`
	Or         []*UserNotificationChannelPreferencesWhereInput `json:"or,omitempty"`
	And        []*UserNotificationChannelPreferencesWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *int  `json:"id,omitempty"`
	IDNEQ   *int  `json:"idNEQ,omitempty"`
	IDIn    []int `json:"idIn,omitempty"`
	IDNotIn []int `json:"idNotIn,omitempty"`
	IDGT    *int  `json:"idGT,omitempty"`
	IDGTE   *int  `json:"idGTE,omitempty"`
	IDLT    *int  `json:"idLT,omitempty"`
	IDLTE   *int  `json:"idLTE,omitempty"`

	// "chanel" field predicates.
	Chanel      *usernotificationchannelpreferences.Chanel  `json:"chanel,omitempty"`
	ChanelNEQ   *usernotificationchannelpreferences.Chanel  `json:"chanelNEQ,omitempty"`
	ChanelIn    []usernotificationchannelpreferences.Chanel `json:"chanelIn,omitempty"`
	ChanelNotIn []usernotificationchannelpreferences.Chanel `json:"chanelNotIn,omitempty"`

	// "chanel_users" edge predicates.
	HasChanelUsers     *bool             `json:"hasChanelUsers,omitempty"`
	HasChanelUsersWith []*UserWhereInput `json:"hasChanelUsersWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *UserNotificationChannelPreferencesWhereInput) AddPredicates(predicates ...predicate.UserNotificationChannelPreferences) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the UserNotificationChannelPreferencesWhereInput filter on the UserNotificationChannelPreferencesQuery builder.
func (i *UserNotificationChannelPreferencesWhereInput) Filter(q *UserNotificationChannelPreferencesQuery) (*UserNotificationChannelPreferencesQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyUserNotificationChannelPreferencesWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyUserNotificationChannelPreferencesWhereInput is returned in case the UserNotificationChannelPreferencesWhereInput is empty.
var ErrEmptyUserNotificationChannelPreferencesWhereInput = errors.New("ent: empty predicate UserNotificationChannelPreferencesWhereInput")

// P returns a predicate for filtering usernotificationchannelpreferencesslice.
// An error is returned if the input is empty or invalid.
func (i *UserNotificationChannelPreferencesWhereInput) P() (predicate.UserNotificationChannelPreferences, error) {
	var predicates []predicate.UserNotificationChannelPreferences
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, usernotificationchannelpreferences.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.UserNotificationChannelPreferences, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, usernotificationchannelpreferences.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.UserNotificationChannelPreferences, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, usernotificationchannelpreferences.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, usernotificationchannelpreferences.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, usernotificationchannelpreferences.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, usernotificationchannelpreferences.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, usernotificationchannelpreferences.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, usernotificationchannelpreferences.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, usernotificationchannelpreferences.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, usernotificationchannelpreferences.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, usernotificationchannelpreferences.IDLTE(*i.IDLTE))
	}
	if i.Chanel != nil {
		predicates = append(predicates, usernotificationchannelpreferences.ChanelEQ(*i.Chanel))
	}
	if i.ChanelNEQ != nil {
		predicates = append(predicates, usernotificationchannelpreferences.ChanelNEQ(*i.ChanelNEQ))
	}
	if len(i.ChanelIn) > 0 {
		predicates = append(predicates, usernotificationchannelpreferences.ChanelIn(i.ChanelIn...))
	}
	if len(i.ChanelNotIn) > 0 {
		predicates = append(predicates, usernotificationchannelpreferences.ChanelNotIn(i.ChanelNotIn...))
	}

	if i.HasChanelUsers != nil {
		p := usernotificationchannelpreferences.HasChanelUsers()
		if !*i.HasChanelUsers {
			p = usernotificationchannelpreferences.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasChanelUsersWith) > 0 {
		with := make([]predicate.User, 0, len(i.HasChanelUsersWith))
		for _, w := range i.HasChanelUsersWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasChanelUsersWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, usernotificationchannelpreferences.HasChanelUsersWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyUserNotificationChannelPreferencesWhereInput
	case 1:
		return predicates[0], nil
	default:
		return usernotificationchannelpreferences.And(predicates...), nil
	}
}
