// Code generated by ent, DO NOT EDIT.

package ent

import (
	"context"
	"errors"
	"fmt"
	"time"
	"wallit/ent/plaidinstitutionaccount"
	"wallit/ent/spendingcategory"
	"wallit/ent/transaction"

	"entgo.io/ent/dialect/sql/sqlgraph"
	"entgo.io/ent/schema/field"
)

// TransactionCreate is the builder for creating a Transaction entity.
type TransactionCreate struct {
	config
	mutation *TransactionMutation
	hooks    []Hook
}

// SetFinancialAccountID sets the "financial_account_id" field.
func (tc *TransactionCreate) SetFinancialAccountID(s string) *TransactionCreate {
	tc.mutation.SetFinancialAccountID(s)
	return tc
}

// SetAmount sets the "amount" field.
func (tc *TransactionCreate) SetAmount(f float64) *TransactionCreate {
	tc.mutation.SetAmount(f)
	return tc
}

// SetIsoCurrencyCode sets the "iso_currency_code" field.
func (tc *TransactionCreate) SetIsoCurrencyCode(s string) *TransactionCreate {
	tc.mutation.SetIsoCurrencyCode(s)
	return tc
}

// SetUnofficialCurrencyCode sets the "unofficial_currency_code" field.
func (tc *TransactionCreate) SetUnofficialCurrencyCode(s string) *TransactionCreate {
	tc.mutation.SetUnofficialCurrencyCode(s)
	return tc
}

// SetCategory sets the "category" field.
func (tc *TransactionCreate) SetCategory(s string) *TransactionCreate {
	tc.mutation.SetCategory(s)
	return tc
}

// SetNillableCategory sets the "category" field if the given value is not nil.
func (tc *TransactionCreate) SetNillableCategory(s *string) *TransactionCreate {
	if s != nil {
		tc.SetCategory(*s)
	}
	return tc
}

// SetCategoryID sets the "category_id" field.
func (tc *TransactionCreate) SetCategoryID(s string) *TransactionCreate {
	tc.mutation.SetCategoryID(s)
	return tc
}

// SetNillableCategoryID sets the "category_id" field if the given value is not nil.
func (tc *TransactionCreate) SetNillableCategoryID(s *string) *TransactionCreate {
	if s != nil {
		tc.SetCategoryID(*s)
	}
	return tc
}

// SetCheckNumber sets the "check_number" field.
func (tc *TransactionCreate) SetCheckNumber(s string) *TransactionCreate {
	tc.mutation.SetCheckNumber(s)
	return tc
}

// SetDate sets the "date" field.
func (tc *TransactionCreate) SetDate(s string) *TransactionCreate {
	tc.mutation.SetDate(s)
	return tc
}

// SetDatetime sets the "datetime" field.
func (tc *TransactionCreate) SetDatetime(t time.Time) *TransactionCreate {
	tc.mutation.SetDatetime(t)
	return tc
}

// SetNillableDatetime sets the "datetime" field if the given value is not nil.
func (tc *TransactionCreate) SetNillableDatetime(t *time.Time) *TransactionCreate {
	if t != nil {
		tc.SetDatetime(*t)
	}
	return tc
}

// SetAuthorizedDate sets the "authorized_date" field.
func (tc *TransactionCreate) SetAuthorizedDate(s string) *TransactionCreate {
	tc.mutation.SetAuthorizedDate(s)
	return tc
}

// SetNillableAuthorizedDate sets the "authorized_date" field if the given value is not nil.
func (tc *TransactionCreate) SetNillableAuthorizedDate(s *string) *TransactionCreate {
	if s != nil {
		tc.SetAuthorizedDate(*s)
	}
	return tc
}

// SetAuthorizedDatetime sets the "authorized_datetime" field.
func (tc *TransactionCreate) SetAuthorizedDatetime(t time.Time) *TransactionCreate {
	tc.mutation.SetAuthorizedDatetime(t)
	return tc
}

// SetNillableAuthorizedDatetime sets the "authorized_datetime" field if the given value is not nil.
func (tc *TransactionCreate) SetNillableAuthorizedDatetime(t *time.Time) *TransactionCreate {
	if t != nil {
		tc.SetAuthorizedDatetime(*t)
	}
	return tc
}

// SetLocationAddress sets the "location_address" field.
func (tc *TransactionCreate) SetLocationAddress(s string) *TransactionCreate {
	tc.mutation.SetLocationAddress(s)
	return tc
}

// SetLocationCity sets the "location_city" field.
func (tc *TransactionCreate) SetLocationCity(s string) *TransactionCreate {
	tc.mutation.SetLocationCity(s)
	return tc
}

// SetLocationRegion sets the "location_region" field.
func (tc *TransactionCreate) SetLocationRegion(s string) *TransactionCreate {
	tc.mutation.SetLocationRegion(s)
	return tc
}

// SetLocationPostalCode sets the "location_postal_code" field.
func (tc *TransactionCreate) SetLocationPostalCode(s string) *TransactionCreate {
	tc.mutation.SetLocationPostalCode(s)
	return tc
}

// SetLocationLat sets the "location_lat" field.
func (tc *TransactionCreate) SetLocationLat(f float64) *TransactionCreate {
	tc.mutation.SetLocationLat(f)
	return tc
}

// SetLocationLon sets the "location_lon" field.
func (tc *TransactionCreate) SetLocationLon(f float64) *TransactionCreate {
	tc.mutation.SetLocationLon(f)
	return tc
}

// SetLocationStoreNumber sets the "location_store_number" field.
func (tc *TransactionCreate) SetLocationStoreNumber(s string) *TransactionCreate {
	tc.mutation.SetLocationStoreNumber(s)
	return tc
}

// SetName sets the "name" field.
func (tc *TransactionCreate) SetName(s string) *TransactionCreate {
	tc.mutation.SetName(s)
	return tc
}

// SetMerchantName sets the "merchant_name" field.
func (tc *TransactionCreate) SetMerchantName(s string) *TransactionCreate {
	tc.mutation.SetMerchantName(s)
	return tc
}

// SetPaymentChannel sets the "payment_channel" field.
func (tc *TransactionCreate) SetPaymentChannel(s string) *TransactionCreate {
	tc.mutation.SetPaymentChannel(s)
	return tc
}

// SetPending sets the "pending" field.
func (tc *TransactionCreate) SetPending(b bool) *TransactionCreate {
	tc.mutation.SetPending(b)
	return tc
}

// SetPendingTransactionID sets the "pending_transaction_id" field.
func (tc *TransactionCreate) SetPendingTransactionID(s string) *TransactionCreate {
	tc.mutation.SetPendingTransactionID(s)
	return tc
}

// SetAccountOwner sets the "account_owner" field.
func (tc *TransactionCreate) SetAccountOwner(s string) *TransactionCreate {
	tc.mutation.SetAccountOwner(s)
	return tc
}

// SetTransactionID sets the "transaction_id" field.
func (tc *TransactionCreate) SetTransactionID(s string) *TransactionCreate {
	tc.mutation.SetTransactionID(s)
	return tc
}

// SetTransactionCode sets the "transaction_code" field.
func (tc *TransactionCreate) SetTransactionCode(s string) *TransactionCreate {
	tc.mutation.SetTransactionCode(s)
	return tc
}

// SetCreatedAt sets the "created_at" field.
func (tc *TransactionCreate) SetCreatedAt(t time.Time) *TransactionCreate {
	tc.mutation.SetCreatedAt(t)
	return tc
}

// SetNillableCreatedAt sets the "created_at" field if the given value is not nil.
func (tc *TransactionCreate) SetNillableCreatedAt(t *time.Time) *TransactionCreate {
	if t != nil {
		tc.SetCreatedAt(*t)
	}
	return tc
}

// SetInstitutionAccountID sets the "institution_account" edge to the PlaidInstitutionAccount entity by ID.
func (tc *TransactionCreate) SetInstitutionAccountID(id int) *TransactionCreate {
	tc.mutation.SetInstitutionAccountID(id)
	return tc
}

// SetNillableInstitutionAccountID sets the "institution_account" edge to the PlaidInstitutionAccount entity by ID if the given value is not nil.
func (tc *TransactionCreate) SetNillableInstitutionAccountID(id *int) *TransactionCreate {
	if id != nil {
		tc = tc.SetInstitutionAccountID(*id)
	}
	return tc
}

// SetInstitutionAccount sets the "institution_account" edge to the PlaidInstitutionAccount entity.
func (tc *TransactionCreate) SetInstitutionAccount(p *PlaidInstitutionAccount) *TransactionCreate {
	return tc.SetInstitutionAccountID(p.ID)
}

// AddTransactionCategoryIDs adds the "transaction_categories" edge to the SpendingCategory entity by IDs.
func (tc *TransactionCreate) AddTransactionCategoryIDs(ids ...int) *TransactionCreate {
	tc.mutation.AddTransactionCategoryIDs(ids...)
	return tc
}

// AddTransactionCategories adds the "transaction_categories" edges to the SpendingCategory entity.
func (tc *TransactionCreate) AddTransactionCategories(s ...*SpendingCategory) *TransactionCreate {
	ids := make([]int, len(s))
	for i := range s {
		ids[i] = s[i].ID
	}
	return tc.AddTransactionCategoryIDs(ids...)
}

// Mutation returns the TransactionMutation object of the builder.
func (tc *TransactionCreate) Mutation() *TransactionMutation {
	return tc.mutation
}

// Save creates the Transaction in the database.
func (tc *TransactionCreate) Save(ctx context.Context) (*Transaction, error) {
	tc.defaults()
	return withHooks[*Transaction, TransactionMutation](ctx, tc.sqlSave, tc.mutation, tc.hooks)
}

// SaveX calls Save and panics if Save returns an error.
func (tc *TransactionCreate) SaveX(ctx context.Context) *Transaction {
	v, err := tc.Save(ctx)
	if err != nil {
		panic(err)
	}
	return v
}

// Exec executes the query.
func (tc *TransactionCreate) Exec(ctx context.Context) error {
	_, err := tc.Save(ctx)
	return err
}

// ExecX is like Exec, but panics if an error occurs.
func (tc *TransactionCreate) ExecX(ctx context.Context) {
	if err := tc.Exec(ctx); err != nil {
		panic(err)
	}
}

// defaults sets the default values of the builder before save.
func (tc *TransactionCreate) defaults() {
	if _, ok := tc.mutation.CreatedAt(); !ok {
		v := transaction.DefaultCreatedAt()
		tc.mutation.SetCreatedAt(v)
	}
}

// check runs all checks and user-defined validators on the builder.
func (tc *TransactionCreate) check() error {
	if _, ok := tc.mutation.FinancialAccountID(); !ok {
		return &ValidationError{Name: "financial_account_id", err: errors.New(`ent: missing required field "Transaction.financial_account_id"`)}
	}
	if v, ok := tc.mutation.FinancialAccountID(); ok {
		if err := transaction.FinancialAccountIDValidator(v); err != nil {
			return &ValidationError{Name: "financial_account_id", err: fmt.Errorf(`ent: validator failed for field "Transaction.financial_account_id": %w`, err)}
		}
	}
	if _, ok := tc.mutation.Amount(); !ok {
		return &ValidationError{Name: "amount", err: errors.New(`ent: missing required field "Transaction.amount"`)}
	}
	if _, ok := tc.mutation.IsoCurrencyCode(); !ok {
		return &ValidationError{Name: "iso_currency_code", err: errors.New(`ent: missing required field "Transaction.iso_currency_code"`)}
	}
	if v, ok := tc.mutation.IsoCurrencyCode(); ok {
		if err := transaction.IsoCurrencyCodeValidator(v); err != nil {
			return &ValidationError{Name: "iso_currency_code", err: fmt.Errorf(`ent: validator failed for field "Transaction.iso_currency_code": %w`, err)}
		}
	}
	if _, ok := tc.mutation.UnofficialCurrencyCode(); !ok {
		return &ValidationError{Name: "unofficial_currency_code", err: errors.New(`ent: missing required field "Transaction.unofficial_currency_code"`)}
	}
	if _, ok := tc.mutation.CheckNumber(); !ok {
		return &ValidationError{Name: "check_number", err: errors.New(`ent: missing required field "Transaction.check_number"`)}
	}
	if _, ok := tc.mutation.Date(); !ok {
		return &ValidationError{Name: "date", err: errors.New(`ent: missing required field "Transaction.date"`)}
	}
	if v, ok := tc.mutation.Date(); ok {
		if err := transaction.DateValidator(v); err != nil {
			return &ValidationError{Name: "date", err: fmt.Errorf(`ent: validator failed for field "Transaction.date": %w`, err)}
		}
	}
	if _, ok := tc.mutation.LocationAddress(); !ok {
		return &ValidationError{Name: "location_address", err: errors.New(`ent: missing required field "Transaction.location_address"`)}
	}
	if _, ok := tc.mutation.LocationCity(); !ok {
		return &ValidationError{Name: "location_city", err: errors.New(`ent: missing required field "Transaction.location_city"`)}
	}
	if _, ok := tc.mutation.LocationRegion(); !ok {
		return &ValidationError{Name: "location_region", err: errors.New(`ent: missing required field "Transaction.location_region"`)}
	}
	if _, ok := tc.mutation.LocationPostalCode(); !ok {
		return &ValidationError{Name: "location_postal_code", err: errors.New(`ent: missing required field "Transaction.location_postal_code"`)}
	}
	if _, ok := tc.mutation.LocationLat(); !ok {
		return &ValidationError{Name: "location_lat", err: errors.New(`ent: missing required field "Transaction.location_lat"`)}
	}
	if _, ok := tc.mutation.LocationLon(); !ok {
		return &ValidationError{Name: "location_lon", err: errors.New(`ent: missing required field "Transaction.location_lon"`)}
	}
	if _, ok := tc.mutation.LocationStoreNumber(); !ok {
		return &ValidationError{Name: "location_store_number", err: errors.New(`ent: missing required field "Transaction.location_store_number"`)}
	}
	if _, ok := tc.mutation.Name(); !ok {
		return &ValidationError{Name: "name", err: errors.New(`ent: missing required field "Transaction.name"`)}
	}
	if _, ok := tc.mutation.MerchantName(); !ok {
		return &ValidationError{Name: "merchant_name", err: errors.New(`ent: missing required field "Transaction.merchant_name"`)}
	}
	if _, ok := tc.mutation.PaymentChannel(); !ok {
		return &ValidationError{Name: "payment_channel", err: errors.New(`ent: missing required field "Transaction.payment_channel"`)}
	}
	if _, ok := tc.mutation.Pending(); !ok {
		return &ValidationError{Name: "pending", err: errors.New(`ent: missing required field "Transaction.pending"`)}
	}
	if _, ok := tc.mutation.PendingTransactionID(); !ok {
		return &ValidationError{Name: "pending_transaction_id", err: errors.New(`ent: missing required field "Transaction.pending_transaction_id"`)}
	}
	if _, ok := tc.mutation.AccountOwner(); !ok {
		return &ValidationError{Name: "account_owner", err: errors.New(`ent: missing required field "Transaction.account_owner"`)}
	}
	if _, ok := tc.mutation.TransactionID(); !ok {
		return &ValidationError{Name: "transaction_id", err: errors.New(`ent: missing required field "Transaction.transaction_id"`)}
	}
	if _, ok := tc.mutation.TransactionCode(); !ok {
		return &ValidationError{Name: "transaction_code", err: errors.New(`ent: missing required field "Transaction.transaction_code"`)}
	}
	if _, ok := tc.mutation.CreatedAt(); !ok {
		return &ValidationError{Name: "created_at", err: errors.New(`ent: missing required field "Transaction.created_at"`)}
	}
	return nil
}

func (tc *TransactionCreate) sqlSave(ctx context.Context) (*Transaction, error) {
	if err := tc.check(); err != nil {
		return nil, err
	}
	_node, _spec := tc.createSpec()
	if err := sqlgraph.CreateNode(ctx, tc.driver, _spec); err != nil {
		if sqlgraph.IsConstraintError(err) {
			err = &ConstraintError{msg: err.Error(), wrap: err}
		}
		return nil, err
	}
	id := _spec.ID.Value.(int64)
	_node.ID = int(id)
	tc.mutation.id = &_node.ID
	tc.mutation.done = true
	return _node, nil
}

func (tc *TransactionCreate) createSpec() (*Transaction, *sqlgraph.CreateSpec) {
	var (
		_node = &Transaction{config: tc.config}
		_spec = &sqlgraph.CreateSpec{
			Table: transaction.Table,
			ID: &sqlgraph.FieldSpec{
				Type:   field.TypeInt,
				Column: transaction.FieldID,
			},
		}
	)
	if value, ok := tc.mutation.FinancialAccountID(); ok {
		_spec.SetField(transaction.FieldFinancialAccountID, field.TypeString, value)
		_node.FinancialAccountID = value
	}
	if value, ok := tc.mutation.Amount(); ok {
		_spec.SetField(transaction.FieldAmount, field.TypeFloat64, value)
		_node.Amount = value
	}
	if value, ok := tc.mutation.IsoCurrencyCode(); ok {
		_spec.SetField(transaction.FieldIsoCurrencyCode, field.TypeString, value)
		_node.IsoCurrencyCode = value
	}
	if value, ok := tc.mutation.UnofficialCurrencyCode(); ok {
		_spec.SetField(transaction.FieldUnofficialCurrencyCode, field.TypeString, value)
		_node.UnofficialCurrencyCode = &value
	}
	if value, ok := tc.mutation.Category(); ok {
		_spec.SetField(transaction.FieldCategory, field.TypeString, value)
		_node.Category = value
	}
	if value, ok := tc.mutation.CategoryID(); ok {
		_spec.SetField(transaction.FieldCategoryID, field.TypeString, value)
		_node.CategoryID = value
	}
	if value, ok := tc.mutation.CheckNumber(); ok {
		_spec.SetField(transaction.FieldCheckNumber, field.TypeString, value)
		_node.CheckNumber = &value
	}
	if value, ok := tc.mutation.Date(); ok {
		_spec.SetField(transaction.FieldDate, field.TypeString, value)
		_node.Date = value
	}
	if value, ok := tc.mutation.Datetime(); ok {
		_spec.SetField(transaction.FieldDatetime, field.TypeTime, value)
		_node.Datetime = value
	}
	if value, ok := tc.mutation.AuthorizedDate(); ok {
		_spec.SetField(transaction.FieldAuthorizedDate, field.TypeString, value)
		_node.AuthorizedDate = value
	}
	if value, ok := tc.mutation.AuthorizedDatetime(); ok {
		_spec.SetField(transaction.FieldAuthorizedDatetime, field.TypeTime, value)
		_node.AuthorizedDatetime = value
	}
	if value, ok := tc.mutation.LocationAddress(); ok {
		_spec.SetField(transaction.FieldLocationAddress, field.TypeString, value)
		_node.LocationAddress = value
	}
	if value, ok := tc.mutation.LocationCity(); ok {
		_spec.SetField(transaction.FieldLocationCity, field.TypeString, value)
		_node.LocationCity = value
	}
	if value, ok := tc.mutation.LocationRegion(); ok {
		_spec.SetField(transaction.FieldLocationRegion, field.TypeString, value)
		_node.LocationRegion = value
	}
	if value, ok := tc.mutation.LocationPostalCode(); ok {
		_spec.SetField(transaction.FieldLocationPostalCode, field.TypeString, value)
		_node.LocationPostalCode = value
	}
	if value, ok := tc.mutation.LocationLat(); ok {
		_spec.SetField(transaction.FieldLocationLat, field.TypeFloat64, value)
		_node.LocationLat = value
	}
	if value, ok := tc.mutation.LocationLon(); ok {
		_spec.SetField(transaction.FieldLocationLon, field.TypeFloat64, value)
		_node.LocationLon = value
	}
	if value, ok := tc.mutation.LocationStoreNumber(); ok {
		_spec.SetField(transaction.FieldLocationStoreNumber, field.TypeString, value)
		_node.LocationStoreNumber = value
	}
	if value, ok := tc.mutation.Name(); ok {
		_spec.SetField(transaction.FieldName, field.TypeString, value)
		_node.Name = value
	}
	if value, ok := tc.mutation.MerchantName(); ok {
		_spec.SetField(transaction.FieldMerchantName, field.TypeString, value)
		_node.MerchantName = value
	}
	if value, ok := tc.mutation.PaymentChannel(); ok {
		_spec.SetField(transaction.FieldPaymentChannel, field.TypeString, value)
		_node.PaymentChannel = value
	}
	if value, ok := tc.mutation.Pending(); ok {
		_spec.SetField(transaction.FieldPending, field.TypeBool, value)
		_node.Pending = value
	}
	if value, ok := tc.mutation.PendingTransactionID(); ok {
		_spec.SetField(transaction.FieldPendingTransactionID, field.TypeString, value)
		_node.PendingTransactionID = value
	}
	if value, ok := tc.mutation.AccountOwner(); ok {
		_spec.SetField(transaction.FieldAccountOwner, field.TypeString, value)
		_node.AccountOwner = value
	}
	if value, ok := tc.mutation.TransactionID(); ok {
		_spec.SetField(transaction.FieldTransactionID, field.TypeString, value)
		_node.TransactionID = value
	}
	if value, ok := tc.mutation.TransactionCode(); ok {
		_spec.SetField(transaction.FieldTransactionCode, field.TypeString, value)
		_node.TransactionCode = value
	}
	if value, ok := tc.mutation.CreatedAt(); ok {
		_spec.SetField(transaction.FieldCreatedAt, field.TypeTime, value)
		_node.CreatedAt = value
	}
	if nodes := tc.mutation.InstitutionAccountIDs(); len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2O,
			Inverse: true,
			Table:   transaction.InstitutionAccountTable,
			Columns: []string{transaction.InstitutionAccountColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: &sqlgraph.FieldSpec{
					Type:   field.TypeInt,
					Column: plaidinstitutionaccount.FieldID,
				},
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_node.plaid_institution_account_transactions = &nodes[0]
		_spec.Edges = append(_spec.Edges, edge)
	}
	if nodes := tc.mutation.TransactionCategoriesIDs(); len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2M,
			Inverse: false,
			Table:   transaction.TransactionCategoriesTable,
			Columns: transaction.TransactionCategoriesPrimaryKey,
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: &sqlgraph.FieldSpec{
					Type:   field.TypeInt,
					Column: spendingcategory.FieldID,
				},
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges = append(_spec.Edges, edge)
	}
	return _node, _spec
}

// TransactionCreateBulk is the builder for creating many Transaction entities in bulk.
type TransactionCreateBulk struct {
	config
	builders []*TransactionCreate
}

// Save creates the Transaction entities in the database.
func (tcb *TransactionCreateBulk) Save(ctx context.Context) ([]*Transaction, error) {
	specs := make([]*sqlgraph.CreateSpec, len(tcb.builders))
	nodes := make([]*Transaction, len(tcb.builders))
	mutators := make([]Mutator, len(tcb.builders))
	for i := range tcb.builders {
		func(i int, root context.Context) {
			builder := tcb.builders[i]
			builder.defaults()
			var mut Mutator = MutateFunc(func(ctx context.Context, m Mutation) (Value, error) {
				mutation, ok := m.(*TransactionMutation)
				if !ok {
					return nil, fmt.Errorf("unexpected mutation type %T", m)
				}
				if err := builder.check(); err != nil {
					return nil, err
				}
				builder.mutation = mutation
				nodes[i], specs[i] = builder.createSpec()
				var err error
				if i < len(mutators)-1 {
					_, err = mutators[i+1].Mutate(root, tcb.builders[i+1].mutation)
				} else {
					spec := &sqlgraph.BatchCreateSpec{Nodes: specs}
					// Invoke the actual operation on the latest mutation in the chain.
					if err = sqlgraph.BatchCreate(ctx, tcb.driver, spec); err != nil {
						if sqlgraph.IsConstraintError(err) {
							err = &ConstraintError{msg: err.Error(), wrap: err}
						}
					}
				}
				if err != nil {
					return nil, err
				}
				mutation.id = &nodes[i].ID
				if specs[i].ID.Value != nil {
					id := specs[i].ID.Value.(int64)
					nodes[i].ID = int(id)
				}
				mutation.done = true
				return nodes[i], nil
			})
			for i := len(builder.hooks) - 1; i >= 0; i-- {
				mut = builder.hooks[i](mut)
			}
			mutators[i] = mut
		}(i, ctx)
	}
	if len(mutators) > 0 {
		if _, err := mutators[0].Mutate(ctx, tcb.builders[0].mutation); err != nil {
			return nil, err
		}
	}
	return nodes, nil
}

// SaveX is like Save, but panics if an error occurs.
func (tcb *TransactionCreateBulk) SaveX(ctx context.Context) []*Transaction {
	v, err := tcb.Save(ctx)
	if err != nil {
		panic(err)
	}
	return v
}

// Exec executes the query.
func (tcb *TransactionCreateBulk) Exec(ctx context.Context) error {
	_, err := tcb.Save(ctx)
	return err
}

// ExecX is like Exec, but panics if an error occurs.
func (tcb *TransactionCreateBulk) ExecX(ctx context.Context) {
	if err := tcb.Exec(ctx); err != nil {
		panic(err)
	}
}
