// Code generated by ent, DO NOT EDIT.

package ent

import (
	"context"
	"errors"
	"fmt"
	"sync"
	"time"
	"wallit/ent/discountoffer"
	"wallit/ent/merchant"
	"wallit/ent/notification"
	"wallit/ent/plaidinstitution"
	"wallit/ent/plaidinstitutionaccount"
	"wallit/ent/plaiditem"
	"wallit/ent/predicate"
	"wallit/ent/spendingcategory"
	"wallit/ent/transaction"
	"wallit/ent/transactionsync"
	"wallit/ent/user"
	"wallit/ent/usernotificationchannelpreferences"

	"entgo.io/ent"
	"entgo.io/ent/dialect/sql"
)

const (
	// Operation types.
	OpCreate    = ent.OpCreate
	OpDelete    = ent.OpDelete
	OpDeleteOne = ent.OpDeleteOne
	OpUpdate    = ent.OpUpdate
	OpUpdateOne = ent.OpUpdateOne

	// Node types.
	TypeDiscountOffer                      = "DiscountOffer"
	TypeMerchant                           = "Merchant"
	TypeNotification                       = "Notification"
	TypePlaidInstitution                   = "PlaidInstitution"
	TypePlaidInstitutionAccount            = "PlaidInstitutionAccount"
	TypePlaidItem                          = "PlaidItem"
	TypeSpendingCategory                   = "SpendingCategory"
	TypeTransaction                        = "Transaction"
	TypeTransactionSync                    = "TransactionSync"
	TypeUser                               = "User"
	TypeUserNotificationChannelPreferences = "UserNotificationChannelPreferences"
)

// DiscountOfferMutation represents an operation that mutates the DiscountOffer nodes in the graph.
type DiscountOfferMutation struct {
	config
	op                                 Op
	typ                                string
	id                                 *int
	amount                             *int
	addamount                          *int
	_type                              *discountoffer.Type
	currency                           *string
	description                        *string
	merchant_specific_identification   *string
	created_at                         *time.Time
	expires_at                         *time.Time
	clearedFields                      map[string]struct{}
	owner_merchant                     *int
	clearedowner_merchant              bool
	discount_eligible_users            map[int]struct{}
	removeddiscount_eligible_users     map[int]struct{}
	cleareddiscount_eligible_users     bool
	discount_offer_notification        *int
	cleareddiscount_offer_notification bool
	done                               bool
	oldValue                           func(context.Context) (*DiscountOffer, error)
	predicates                         []predicate.DiscountOffer
}

var _ ent.Mutation = (*DiscountOfferMutation)(nil)

// discountofferOption allows management of the mutation configuration using functional options.
type discountofferOption func(*DiscountOfferMutation)

// newDiscountOfferMutation creates new mutation for the DiscountOffer entity.
func newDiscountOfferMutation(c config, op Op, opts ...discountofferOption) *DiscountOfferMutation {
	m := &DiscountOfferMutation{
		config:        c,
		op:            op,
		typ:           TypeDiscountOffer,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withDiscountOfferID sets the ID field of the mutation.
func withDiscountOfferID(id int) discountofferOption {
	return func(m *DiscountOfferMutation) {
		var (
			err   error
			once  sync.Once
			value *DiscountOffer
		)
		m.oldValue = func(ctx context.Context) (*DiscountOffer, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().DiscountOffer.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withDiscountOffer sets the old DiscountOffer of the mutation.
func withDiscountOffer(node *DiscountOffer) discountofferOption {
	return func(m *DiscountOfferMutation) {
		m.oldValue = func(context.Context) (*DiscountOffer, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m DiscountOfferMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m DiscountOfferMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *DiscountOfferMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *DiscountOfferMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().DiscountOffer.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetAmount sets the "amount" field.
func (m *DiscountOfferMutation) SetAmount(i int) {
	m.amount = &i
	m.addamount = nil
}

// Amount returns the value of the "amount" field in the mutation.
func (m *DiscountOfferMutation) Amount() (r int, exists bool) {
	v := m.amount
	if v == nil {
		return
	}
	return *v, true
}

// OldAmount returns the old "amount" field's value of the DiscountOffer entity.
// If the DiscountOffer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DiscountOfferMutation) OldAmount(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAmount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAmount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAmount: %w", err)
	}
	return oldValue.Amount, nil
}

// AddAmount adds i to the "amount" field.
func (m *DiscountOfferMutation) AddAmount(i int) {
	if m.addamount != nil {
		*m.addamount += i
	} else {
		m.addamount = &i
	}
}

// AddedAmount returns the value that was added to the "amount" field in this mutation.
func (m *DiscountOfferMutation) AddedAmount() (r int, exists bool) {
	v := m.addamount
	if v == nil {
		return
	}
	return *v, true
}

// ResetAmount resets all changes to the "amount" field.
func (m *DiscountOfferMutation) ResetAmount() {
	m.amount = nil
	m.addamount = nil
}

// SetType sets the "type" field.
func (m *DiscountOfferMutation) SetType(d discountoffer.Type) {
	m._type = &d
}

// GetType returns the value of the "type" field in the mutation.
func (m *DiscountOfferMutation) GetType() (r discountoffer.Type, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the DiscountOffer entity.
// If the DiscountOffer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DiscountOfferMutation) OldType(ctx context.Context) (v discountoffer.Type, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// ResetType resets all changes to the "type" field.
func (m *DiscountOfferMutation) ResetType() {
	m._type = nil
}

// SetCurrency sets the "currency" field.
func (m *DiscountOfferMutation) SetCurrency(s string) {
	m.currency = &s
}

// Currency returns the value of the "currency" field in the mutation.
func (m *DiscountOfferMutation) Currency() (r string, exists bool) {
	v := m.currency
	if v == nil {
		return
	}
	return *v, true
}

// OldCurrency returns the old "currency" field's value of the DiscountOffer entity.
// If the DiscountOffer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DiscountOfferMutation) OldCurrency(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCurrency is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCurrency requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCurrency: %w", err)
	}
	return oldValue.Currency, nil
}

// ClearCurrency clears the value of the "currency" field.
func (m *DiscountOfferMutation) ClearCurrency() {
	m.currency = nil
	m.clearedFields[discountoffer.FieldCurrency] = struct{}{}
}

// CurrencyCleared returns if the "currency" field was cleared in this mutation.
func (m *DiscountOfferMutation) CurrencyCleared() bool {
	_, ok := m.clearedFields[discountoffer.FieldCurrency]
	return ok
}

// ResetCurrency resets all changes to the "currency" field.
func (m *DiscountOfferMutation) ResetCurrency() {
	m.currency = nil
	delete(m.clearedFields, discountoffer.FieldCurrency)
}

// SetDescription sets the "description" field.
func (m *DiscountOfferMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *DiscountOfferMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the DiscountOffer entity.
// If the DiscountOffer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DiscountOfferMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ResetDescription resets all changes to the "description" field.
func (m *DiscountOfferMutation) ResetDescription() {
	m.description = nil
}

// SetMerchantSpecificIdentification sets the "merchant_specific_identification" field.
func (m *DiscountOfferMutation) SetMerchantSpecificIdentification(s string) {
	m.merchant_specific_identification = &s
}

// MerchantSpecificIdentification returns the value of the "merchant_specific_identification" field in the mutation.
func (m *DiscountOfferMutation) MerchantSpecificIdentification() (r string, exists bool) {
	v := m.merchant_specific_identification
	if v == nil {
		return
	}
	return *v, true
}

// OldMerchantSpecificIdentification returns the old "merchant_specific_identification" field's value of the DiscountOffer entity.
// If the DiscountOffer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DiscountOfferMutation) OldMerchantSpecificIdentification(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMerchantSpecificIdentification is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMerchantSpecificIdentification requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMerchantSpecificIdentification: %w", err)
	}
	return oldValue.MerchantSpecificIdentification, nil
}

// ResetMerchantSpecificIdentification resets all changes to the "merchant_specific_identification" field.
func (m *DiscountOfferMutation) ResetMerchantSpecificIdentification() {
	m.merchant_specific_identification = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *DiscountOfferMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *DiscountOfferMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the DiscountOffer entity.
// If the DiscountOffer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DiscountOfferMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *DiscountOfferMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetExpiresAt sets the "expires_at" field.
func (m *DiscountOfferMutation) SetExpiresAt(t time.Time) {
	m.expires_at = &t
}

// ExpiresAt returns the value of the "expires_at" field in the mutation.
func (m *DiscountOfferMutation) ExpiresAt() (r time.Time, exists bool) {
	v := m.expires_at
	if v == nil {
		return
	}
	return *v, true
}

// OldExpiresAt returns the old "expires_at" field's value of the DiscountOffer entity.
// If the DiscountOffer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DiscountOfferMutation) OldExpiresAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExpiresAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExpiresAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExpiresAt: %w", err)
	}
	return oldValue.ExpiresAt, nil
}

// ResetExpiresAt resets all changes to the "expires_at" field.
func (m *DiscountOfferMutation) ResetExpiresAt() {
	m.expires_at = nil
}

// SetOwnerMerchantID sets the "owner_merchant" edge to the Merchant entity by id.
func (m *DiscountOfferMutation) SetOwnerMerchantID(id int) {
	m.owner_merchant = &id
}

// ClearOwnerMerchant clears the "owner_merchant" edge to the Merchant entity.
func (m *DiscountOfferMutation) ClearOwnerMerchant() {
	m.clearedowner_merchant = true
}

// OwnerMerchantCleared reports if the "owner_merchant" edge to the Merchant entity was cleared.
func (m *DiscountOfferMutation) OwnerMerchantCleared() bool {
	return m.clearedowner_merchant
}

// OwnerMerchantID returns the "owner_merchant" edge ID in the mutation.
func (m *DiscountOfferMutation) OwnerMerchantID() (id int, exists bool) {
	if m.owner_merchant != nil {
		return *m.owner_merchant, true
	}
	return
}

// OwnerMerchantIDs returns the "owner_merchant" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// OwnerMerchantID instead. It exists only for internal usage by the builders.
func (m *DiscountOfferMutation) OwnerMerchantIDs() (ids []int) {
	if id := m.owner_merchant; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetOwnerMerchant resets all changes to the "owner_merchant" edge.
func (m *DiscountOfferMutation) ResetOwnerMerchant() {
	m.owner_merchant = nil
	m.clearedowner_merchant = false
}

// AddDiscountEligibleUserIDs adds the "discount_eligible_users" edge to the User entity by ids.
func (m *DiscountOfferMutation) AddDiscountEligibleUserIDs(ids ...int) {
	if m.discount_eligible_users == nil {
		m.discount_eligible_users = make(map[int]struct{})
	}
	for i := range ids {
		m.discount_eligible_users[ids[i]] = struct{}{}
	}
}

// ClearDiscountEligibleUsers clears the "discount_eligible_users" edge to the User entity.
func (m *DiscountOfferMutation) ClearDiscountEligibleUsers() {
	m.cleareddiscount_eligible_users = true
}

// DiscountEligibleUsersCleared reports if the "discount_eligible_users" edge to the User entity was cleared.
func (m *DiscountOfferMutation) DiscountEligibleUsersCleared() bool {
	return m.cleareddiscount_eligible_users
}

// RemoveDiscountEligibleUserIDs removes the "discount_eligible_users" edge to the User entity by IDs.
func (m *DiscountOfferMutation) RemoveDiscountEligibleUserIDs(ids ...int) {
	if m.removeddiscount_eligible_users == nil {
		m.removeddiscount_eligible_users = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.discount_eligible_users, ids[i])
		m.removeddiscount_eligible_users[ids[i]] = struct{}{}
	}
}

// RemovedDiscountEligibleUsers returns the removed IDs of the "discount_eligible_users" edge to the User entity.
func (m *DiscountOfferMutation) RemovedDiscountEligibleUsersIDs() (ids []int) {
	for id := range m.removeddiscount_eligible_users {
		ids = append(ids, id)
	}
	return
}

// DiscountEligibleUsersIDs returns the "discount_eligible_users" edge IDs in the mutation.
func (m *DiscountOfferMutation) DiscountEligibleUsersIDs() (ids []int) {
	for id := range m.discount_eligible_users {
		ids = append(ids, id)
	}
	return
}

// ResetDiscountEligibleUsers resets all changes to the "discount_eligible_users" edge.
func (m *DiscountOfferMutation) ResetDiscountEligibleUsers() {
	m.discount_eligible_users = nil
	m.cleareddiscount_eligible_users = false
	m.removeddiscount_eligible_users = nil
}

// SetDiscountOfferNotificationID sets the "discount_offer_notification" edge to the Notification entity by id.
func (m *DiscountOfferMutation) SetDiscountOfferNotificationID(id int) {
	m.discount_offer_notification = &id
}

// ClearDiscountOfferNotification clears the "discount_offer_notification" edge to the Notification entity.
func (m *DiscountOfferMutation) ClearDiscountOfferNotification() {
	m.cleareddiscount_offer_notification = true
}

// DiscountOfferNotificationCleared reports if the "discount_offer_notification" edge to the Notification entity was cleared.
func (m *DiscountOfferMutation) DiscountOfferNotificationCleared() bool {
	return m.cleareddiscount_offer_notification
}

// DiscountOfferNotificationID returns the "discount_offer_notification" edge ID in the mutation.
func (m *DiscountOfferMutation) DiscountOfferNotificationID() (id int, exists bool) {
	if m.discount_offer_notification != nil {
		return *m.discount_offer_notification, true
	}
	return
}

// DiscountOfferNotificationIDs returns the "discount_offer_notification" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// DiscountOfferNotificationID instead. It exists only for internal usage by the builders.
func (m *DiscountOfferMutation) DiscountOfferNotificationIDs() (ids []int) {
	if id := m.discount_offer_notification; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetDiscountOfferNotification resets all changes to the "discount_offer_notification" edge.
func (m *DiscountOfferMutation) ResetDiscountOfferNotification() {
	m.discount_offer_notification = nil
	m.cleareddiscount_offer_notification = false
}

// Where appends a list predicates to the DiscountOfferMutation builder.
func (m *DiscountOfferMutation) Where(ps ...predicate.DiscountOffer) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the DiscountOfferMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *DiscountOfferMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.DiscountOffer, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *DiscountOfferMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *DiscountOfferMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (DiscountOffer).
func (m *DiscountOfferMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *DiscountOfferMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.amount != nil {
		fields = append(fields, discountoffer.FieldAmount)
	}
	if m._type != nil {
		fields = append(fields, discountoffer.FieldType)
	}
	if m.currency != nil {
		fields = append(fields, discountoffer.FieldCurrency)
	}
	if m.description != nil {
		fields = append(fields, discountoffer.FieldDescription)
	}
	if m.merchant_specific_identification != nil {
		fields = append(fields, discountoffer.FieldMerchantSpecificIdentification)
	}
	if m.created_at != nil {
		fields = append(fields, discountoffer.FieldCreatedAt)
	}
	if m.expires_at != nil {
		fields = append(fields, discountoffer.FieldExpiresAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *DiscountOfferMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case discountoffer.FieldAmount:
		return m.Amount()
	case discountoffer.FieldType:
		return m.GetType()
	case discountoffer.FieldCurrency:
		return m.Currency()
	case discountoffer.FieldDescription:
		return m.Description()
	case discountoffer.FieldMerchantSpecificIdentification:
		return m.MerchantSpecificIdentification()
	case discountoffer.FieldCreatedAt:
		return m.CreatedAt()
	case discountoffer.FieldExpiresAt:
		return m.ExpiresAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *DiscountOfferMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case discountoffer.FieldAmount:
		return m.OldAmount(ctx)
	case discountoffer.FieldType:
		return m.OldType(ctx)
	case discountoffer.FieldCurrency:
		return m.OldCurrency(ctx)
	case discountoffer.FieldDescription:
		return m.OldDescription(ctx)
	case discountoffer.FieldMerchantSpecificIdentification:
		return m.OldMerchantSpecificIdentification(ctx)
	case discountoffer.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case discountoffer.FieldExpiresAt:
		return m.OldExpiresAt(ctx)
	}
	return nil, fmt.Errorf("unknown DiscountOffer field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *DiscountOfferMutation) SetField(name string, value ent.Value) error {
	switch name {
	case discountoffer.FieldAmount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAmount(v)
		return nil
	case discountoffer.FieldType:
		v, ok := value.(discountoffer.Type)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	case discountoffer.FieldCurrency:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCurrency(v)
		return nil
	case discountoffer.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case discountoffer.FieldMerchantSpecificIdentification:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMerchantSpecificIdentification(v)
		return nil
	case discountoffer.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case discountoffer.FieldExpiresAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExpiresAt(v)
		return nil
	}
	return fmt.Errorf("unknown DiscountOffer field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *DiscountOfferMutation) AddedFields() []string {
	var fields []string
	if m.addamount != nil {
		fields = append(fields, discountoffer.FieldAmount)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *DiscountOfferMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case discountoffer.FieldAmount:
		return m.AddedAmount()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *DiscountOfferMutation) AddField(name string, value ent.Value) error {
	switch name {
	case discountoffer.FieldAmount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddAmount(v)
		return nil
	}
	return fmt.Errorf("unknown DiscountOffer numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *DiscountOfferMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(discountoffer.FieldCurrency) {
		fields = append(fields, discountoffer.FieldCurrency)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *DiscountOfferMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *DiscountOfferMutation) ClearField(name string) error {
	switch name {
	case discountoffer.FieldCurrency:
		m.ClearCurrency()
		return nil
	}
	return fmt.Errorf("unknown DiscountOffer nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *DiscountOfferMutation) ResetField(name string) error {
	switch name {
	case discountoffer.FieldAmount:
		m.ResetAmount()
		return nil
	case discountoffer.FieldType:
		m.ResetType()
		return nil
	case discountoffer.FieldCurrency:
		m.ResetCurrency()
		return nil
	case discountoffer.FieldDescription:
		m.ResetDescription()
		return nil
	case discountoffer.FieldMerchantSpecificIdentification:
		m.ResetMerchantSpecificIdentification()
		return nil
	case discountoffer.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case discountoffer.FieldExpiresAt:
		m.ResetExpiresAt()
		return nil
	}
	return fmt.Errorf("unknown DiscountOffer field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *DiscountOfferMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.owner_merchant != nil {
		edges = append(edges, discountoffer.EdgeOwnerMerchant)
	}
	if m.discount_eligible_users != nil {
		edges = append(edges, discountoffer.EdgeDiscountEligibleUsers)
	}
	if m.discount_offer_notification != nil {
		edges = append(edges, discountoffer.EdgeDiscountOfferNotification)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *DiscountOfferMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case discountoffer.EdgeOwnerMerchant:
		if id := m.owner_merchant; id != nil {
			return []ent.Value{*id}
		}
	case discountoffer.EdgeDiscountEligibleUsers:
		ids := make([]ent.Value, 0, len(m.discount_eligible_users))
		for id := range m.discount_eligible_users {
			ids = append(ids, id)
		}
		return ids
	case discountoffer.EdgeDiscountOfferNotification:
		if id := m.discount_offer_notification; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *DiscountOfferMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	if m.removeddiscount_eligible_users != nil {
		edges = append(edges, discountoffer.EdgeDiscountEligibleUsers)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *DiscountOfferMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case discountoffer.EdgeDiscountEligibleUsers:
		ids := make([]ent.Value, 0, len(m.removeddiscount_eligible_users))
		for id := range m.removeddiscount_eligible_users {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *DiscountOfferMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedowner_merchant {
		edges = append(edges, discountoffer.EdgeOwnerMerchant)
	}
	if m.cleareddiscount_eligible_users {
		edges = append(edges, discountoffer.EdgeDiscountEligibleUsers)
	}
	if m.cleareddiscount_offer_notification {
		edges = append(edges, discountoffer.EdgeDiscountOfferNotification)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *DiscountOfferMutation) EdgeCleared(name string) bool {
	switch name {
	case discountoffer.EdgeOwnerMerchant:
		return m.clearedowner_merchant
	case discountoffer.EdgeDiscountEligibleUsers:
		return m.cleareddiscount_eligible_users
	case discountoffer.EdgeDiscountOfferNotification:
		return m.cleareddiscount_offer_notification
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *DiscountOfferMutation) ClearEdge(name string) error {
	switch name {
	case discountoffer.EdgeOwnerMerchant:
		m.ClearOwnerMerchant()
		return nil
	case discountoffer.EdgeDiscountOfferNotification:
		m.ClearDiscountOfferNotification()
		return nil
	}
	return fmt.Errorf("unknown DiscountOffer unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *DiscountOfferMutation) ResetEdge(name string) error {
	switch name {
	case discountoffer.EdgeOwnerMerchant:
		m.ResetOwnerMerchant()
		return nil
	case discountoffer.EdgeDiscountEligibleUsers:
		m.ResetDiscountEligibleUsers()
		return nil
	case discountoffer.EdgeDiscountOfferNotification:
		m.ResetDiscountOfferNotification()
		return nil
	}
	return fmt.Errorf("unknown DiscountOffer edge %s", name)
}

// MerchantMutation represents an operation that mutates the Merchant nodes in the graph.
type MerchantMutation struct {
	config
	op                     Op
	typ                    string
	id                     *int
	name                   *string
	clearedFields          map[string]struct{}
	discount_offers        map[int]struct{}
	removeddiscount_offers map[int]struct{}
	cleareddiscount_offers bool
	done                   bool
	oldValue               func(context.Context) (*Merchant, error)
	predicates             []predicate.Merchant
}

var _ ent.Mutation = (*MerchantMutation)(nil)

// merchantOption allows management of the mutation configuration using functional options.
type merchantOption func(*MerchantMutation)

// newMerchantMutation creates new mutation for the Merchant entity.
func newMerchantMutation(c config, op Op, opts ...merchantOption) *MerchantMutation {
	m := &MerchantMutation{
		config:        c,
		op:            op,
		typ:           TypeMerchant,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withMerchantID sets the ID field of the mutation.
func withMerchantID(id int) merchantOption {
	return func(m *MerchantMutation) {
		var (
			err   error
			once  sync.Once
			value *Merchant
		)
		m.oldValue = func(ctx context.Context) (*Merchant, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Merchant.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withMerchant sets the old Merchant of the mutation.
func withMerchant(node *Merchant) merchantOption {
	return func(m *MerchantMutation) {
		m.oldValue = func(context.Context) (*Merchant, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m MerchantMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m MerchantMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *MerchantMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *MerchantMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Merchant.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "name" field.
func (m *MerchantMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *MerchantMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Merchant entity.
// If the Merchant object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MerchantMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *MerchantMutation) ResetName() {
	m.name = nil
}

// AddDiscountOfferIDs adds the "discount_offers" edge to the DiscountOffer entity by ids.
func (m *MerchantMutation) AddDiscountOfferIDs(ids ...int) {
	if m.discount_offers == nil {
		m.discount_offers = make(map[int]struct{})
	}
	for i := range ids {
		m.discount_offers[ids[i]] = struct{}{}
	}
}

// ClearDiscountOffers clears the "discount_offers" edge to the DiscountOffer entity.
func (m *MerchantMutation) ClearDiscountOffers() {
	m.cleareddiscount_offers = true
}

// DiscountOffersCleared reports if the "discount_offers" edge to the DiscountOffer entity was cleared.
func (m *MerchantMutation) DiscountOffersCleared() bool {
	return m.cleareddiscount_offers
}

// RemoveDiscountOfferIDs removes the "discount_offers" edge to the DiscountOffer entity by IDs.
func (m *MerchantMutation) RemoveDiscountOfferIDs(ids ...int) {
	if m.removeddiscount_offers == nil {
		m.removeddiscount_offers = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.discount_offers, ids[i])
		m.removeddiscount_offers[ids[i]] = struct{}{}
	}
}

// RemovedDiscountOffers returns the removed IDs of the "discount_offers" edge to the DiscountOffer entity.
func (m *MerchantMutation) RemovedDiscountOffersIDs() (ids []int) {
	for id := range m.removeddiscount_offers {
		ids = append(ids, id)
	}
	return
}

// DiscountOffersIDs returns the "discount_offers" edge IDs in the mutation.
func (m *MerchantMutation) DiscountOffersIDs() (ids []int) {
	for id := range m.discount_offers {
		ids = append(ids, id)
	}
	return
}

// ResetDiscountOffers resets all changes to the "discount_offers" edge.
func (m *MerchantMutation) ResetDiscountOffers() {
	m.discount_offers = nil
	m.cleareddiscount_offers = false
	m.removeddiscount_offers = nil
}

// Where appends a list predicates to the MerchantMutation builder.
func (m *MerchantMutation) Where(ps ...predicate.Merchant) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the MerchantMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *MerchantMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Merchant, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *MerchantMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *MerchantMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Merchant).
func (m *MerchantMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *MerchantMutation) Fields() []string {
	fields := make([]string, 0, 1)
	if m.name != nil {
		fields = append(fields, merchant.FieldName)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *MerchantMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case merchant.FieldName:
		return m.Name()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *MerchantMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case merchant.FieldName:
		return m.OldName(ctx)
	}
	return nil, fmt.Errorf("unknown Merchant field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *MerchantMutation) SetField(name string, value ent.Value) error {
	switch name {
	case merchant.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	}
	return fmt.Errorf("unknown Merchant field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *MerchantMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *MerchantMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *MerchantMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Merchant numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *MerchantMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *MerchantMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *MerchantMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Merchant nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *MerchantMutation) ResetField(name string) error {
	switch name {
	case merchant.FieldName:
		m.ResetName()
		return nil
	}
	return fmt.Errorf("unknown Merchant field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *MerchantMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.discount_offers != nil {
		edges = append(edges, merchant.EdgeDiscountOffers)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *MerchantMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case merchant.EdgeDiscountOffers:
		ids := make([]ent.Value, 0, len(m.discount_offers))
		for id := range m.discount_offers {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *MerchantMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removeddiscount_offers != nil {
		edges = append(edges, merchant.EdgeDiscountOffers)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *MerchantMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case merchant.EdgeDiscountOffers:
		ids := make([]ent.Value, 0, len(m.removeddiscount_offers))
		for id := range m.removeddiscount_offers {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *MerchantMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.cleareddiscount_offers {
		edges = append(edges, merchant.EdgeDiscountOffers)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *MerchantMutation) EdgeCleared(name string) bool {
	switch name {
	case merchant.EdgeDiscountOffers:
		return m.cleareddiscount_offers
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *MerchantMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Merchant unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *MerchantMutation) ResetEdge(name string) error {
	switch name {
	case merchant.EdgeDiscountOffers:
		m.ResetDiscountOffers()
		return nil
	}
	return fmt.Errorf("unknown Merchant edge %s", name)
}

// NotificationMutation represents an operation that mutates the Notification nodes in the graph.
type NotificationMutation struct {
	config
	op                                 Op
	typ                                string
	id                                 *int
	checked_in_app                     *bool
	_type                              *notification.Type
	created_at                         *time.Time
	included_in_aggregated_offer_at    *time.Time
	clearedFields                      map[string]struct{}
	notification_recipient             *int
	clearednotification_recipient      bool
	notification_discount_offer        *int
	clearednotification_discount_offer bool
	done                               bool
	oldValue                           func(context.Context) (*Notification, error)
	predicates                         []predicate.Notification
}

var _ ent.Mutation = (*NotificationMutation)(nil)

// notificationOption allows management of the mutation configuration using functional options.
type notificationOption func(*NotificationMutation)

// newNotificationMutation creates new mutation for the Notification entity.
func newNotificationMutation(c config, op Op, opts ...notificationOption) *NotificationMutation {
	m := &NotificationMutation{
		config:        c,
		op:            op,
		typ:           TypeNotification,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withNotificationID sets the ID field of the mutation.
func withNotificationID(id int) notificationOption {
	return func(m *NotificationMutation) {
		var (
			err   error
			once  sync.Once
			value *Notification
		)
		m.oldValue = func(ctx context.Context) (*Notification, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Notification.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withNotification sets the old Notification of the mutation.
func withNotification(node *Notification) notificationOption {
	return func(m *NotificationMutation) {
		m.oldValue = func(context.Context) (*Notification, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m NotificationMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m NotificationMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *NotificationMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *NotificationMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Notification.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCheckedInApp sets the "checked_in_app" field.
func (m *NotificationMutation) SetCheckedInApp(b bool) {
	m.checked_in_app = &b
}

// CheckedInApp returns the value of the "checked_in_app" field in the mutation.
func (m *NotificationMutation) CheckedInApp() (r bool, exists bool) {
	v := m.checked_in_app
	if v == nil {
		return
	}
	return *v, true
}

// OldCheckedInApp returns the old "checked_in_app" field's value of the Notification entity.
// If the Notification object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NotificationMutation) OldCheckedInApp(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCheckedInApp is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCheckedInApp requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCheckedInApp: %w", err)
	}
	return oldValue.CheckedInApp, nil
}

// ResetCheckedInApp resets all changes to the "checked_in_app" field.
func (m *NotificationMutation) ResetCheckedInApp() {
	m.checked_in_app = nil
}

// SetType sets the "type" field.
func (m *NotificationMutation) SetType(n notification.Type) {
	m._type = &n
}

// GetType returns the value of the "type" field in the mutation.
func (m *NotificationMutation) GetType() (r notification.Type, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the Notification entity.
// If the Notification object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NotificationMutation) OldType(ctx context.Context) (v notification.Type, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// ResetType resets all changes to the "type" field.
func (m *NotificationMutation) ResetType() {
	m._type = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *NotificationMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *NotificationMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Notification entity.
// If the Notification object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NotificationMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *NotificationMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetIncludedInAggregatedOfferAt sets the "included_in_aggregated_offer_at" field.
func (m *NotificationMutation) SetIncludedInAggregatedOfferAt(t time.Time) {
	m.included_in_aggregated_offer_at = &t
}

// IncludedInAggregatedOfferAt returns the value of the "included_in_aggregated_offer_at" field in the mutation.
func (m *NotificationMutation) IncludedInAggregatedOfferAt() (r time.Time, exists bool) {
	v := m.included_in_aggregated_offer_at
	if v == nil {
		return
	}
	return *v, true
}

// OldIncludedInAggregatedOfferAt returns the old "included_in_aggregated_offer_at" field's value of the Notification entity.
// If the Notification object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NotificationMutation) OldIncludedInAggregatedOfferAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIncludedInAggregatedOfferAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIncludedInAggregatedOfferAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIncludedInAggregatedOfferAt: %w", err)
	}
	return oldValue.IncludedInAggregatedOfferAt, nil
}

// ClearIncludedInAggregatedOfferAt clears the value of the "included_in_aggregated_offer_at" field.
func (m *NotificationMutation) ClearIncludedInAggregatedOfferAt() {
	m.included_in_aggregated_offer_at = nil
	m.clearedFields[notification.FieldIncludedInAggregatedOfferAt] = struct{}{}
}

// IncludedInAggregatedOfferAtCleared returns if the "included_in_aggregated_offer_at" field was cleared in this mutation.
func (m *NotificationMutation) IncludedInAggregatedOfferAtCleared() bool {
	_, ok := m.clearedFields[notification.FieldIncludedInAggregatedOfferAt]
	return ok
}

// ResetIncludedInAggregatedOfferAt resets all changes to the "included_in_aggregated_offer_at" field.
func (m *NotificationMutation) ResetIncludedInAggregatedOfferAt() {
	m.included_in_aggregated_offer_at = nil
	delete(m.clearedFields, notification.FieldIncludedInAggregatedOfferAt)
}

// SetNotificationRecipientID sets the "notification_recipient" edge to the User entity by id.
func (m *NotificationMutation) SetNotificationRecipientID(id int) {
	m.notification_recipient = &id
}

// ClearNotificationRecipient clears the "notification_recipient" edge to the User entity.
func (m *NotificationMutation) ClearNotificationRecipient() {
	m.clearednotification_recipient = true
}

// NotificationRecipientCleared reports if the "notification_recipient" edge to the User entity was cleared.
func (m *NotificationMutation) NotificationRecipientCleared() bool {
	return m.clearednotification_recipient
}

// NotificationRecipientID returns the "notification_recipient" edge ID in the mutation.
func (m *NotificationMutation) NotificationRecipientID() (id int, exists bool) {
	if m.notification_recipient != nil {
		return *m.notification_recipient, true
	}
	return
}

// NotificationRecipientIDs returns the "notification_recipient" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// NotificationRecipientID instead. It exists only for internal usage by the builders.
func (m *NotificationMutation) NotificationRecipientIDs() (ids []int) {
	if id := m.notification_recipient; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetNotificationRecipient resets all changes to the "notification_recipient" edge.
func (m *NotificationMutation) ResetNotificationRecipient() {
	m.notification_recipient = nil
	m.clearednotification_recipient = false
}

// SetNotificationDiscountOfferID sets the "notification_discount_offer" edge to the DiscountOffer entity by id.
func (m *NotificationMutation) SetNotificationDiscountOfferID(id int) {
	m.notification_discount_offer = &id
}

// ClearNotificationDiscountOffer clears the "notification_discount_offer" edge to the DiscountOffer entity.
func (m *NotificationMutation) ClearNotificationDiscountOffer() {
	m.clearednotification_discount_offer = true
}

// NotificationDiscountOfferCleared reports if the "notification_discount_offer" edge to the DiscountOffer entity was cleared.
func (m *NotificationMutation) NotificationDiscountOfferCleared() bool {
	return m.clearednotification_discount_offer
}

// NotificationDiscountOfferID returns the "notification_discount_offer" edge ID in the mutation.
func (m *NotificationMutation) NotificationDiscountOfferID() (id int, exists bool) {
	if m.notification_discount_offer != nil {
		return *m.notification_discount_offer, true
	}
	return
}

// NotificationDiscountOfferIDs returns the "notification_discount_offer" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// NotificationDiscountOfferID instead. It exists only for internal usage by the builders.
func (m *NotificationMutation) NotificationDiscountOfferIDs() (ids []int) {
	if id := m.notification_discount_offer; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetNotificationDiscountOffer resets all changes to the "notification_discount_offer" edge.
func (m *NotificationMutation) ResetNotificationDiscountOffer() {
	m.notification_discount_offer = nil
	m.clearednotification_discount_offer = false
}

// Where appends a list predicates to the NotificationMutation builder.
func (m *NotificationMutation) Where(ps ...predicate.Notification) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the NotificationMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *NotificationMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Notification, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *NotificationMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *NotificationMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Notification).
func (m *NotificationMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *NotificationMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m.checked_in_app != nil {
		fields = append(fields, notification.FieldCheckedInApp)
	}
	if m._type != nil {
		fields = append(fields, notification.FieldType)
	}
	if m.created_at != nil {
		fields = append(fields, notification.FieldCreatedAt)
	}
	if m.included_in_aggregated_offer_at != nil {
		fields = append(fields, notification.FieldIncludedInAggregatedOfferAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *NotificationMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case notification.FieldCheckedInApp:
		return m.CheckedInApp()
	case notification.FieldType:
		return m.GetType()
	case notification.FieldCreatedAt:
		return m.CreatedAt()
	case notification.FieldIncludedInAggregatedOfferAt:
		return m.IncludedInAggregatedOfferAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *NotificationMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case notification.FieldCheckedInApp:
		return m.OldCheckedInApp(ctx)
	case notification.FieldType:
		return m.OldType(ctx)
	case notification.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case notification.FieldIncludedInAggregatedOfferAt:
		return m.OldIncludedInAggregatedOfferAt(ctx)
	}
	return nil, fmt.Errorf("unknown Notification field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *NotificationMutation) SetField(name string, value ent.Value) error {
	switch name {
	case notification.FieldCheckedInApp:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCheckedInApp(v)
		return nil
	case notification.FieldType:
		v, ok := value.(notification.Type)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	case notification.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case notification.FieldIncludedInAggregatedOfferAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIncludedInAggregatedOfferAt(v)
		return nil
	}
	return fmt.Errorf("unknown Notification field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *NotificationMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *NotificationMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *NotificationMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Notification numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *NotificationMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(notification.FieldIncludedInAggregatedOfferAt) {
		fields = append(fields, notification.FieldIncludedInAggregatedOfferAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *NotificationMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *NotificationMutation) ClearField(name string) error {
	switch name {
	case notification.FieldIncludedInAggregatedOfferAt:
		m.ClearIncludedInAggregatedOfferAt()
		return nil
	}
	return fmt.Errorf("unknown Notification nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *NotificationMutation) ResetField(name string) error {
	switch name {
	case notification.FieldCheckedInApp:
		m.ResetCheckedInApp()
		return nil
	case notification.FieldType:
		m.ResetType()
		return nil
	case notification.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case notification.FieldIncludedInAggregatedOfferAt:
		m.ResetIncludedInAggregatedOfferAt()
		return nil
	}
	return fmt.Errorf("unknown Notification field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *NotificationMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.notification_recipient != nil {
		edges = append(edges, notification.EdgeNotificationRecipient)
	}
	if m.notification_discount_offer != nil {
		edges = append(edges, notification.EdgeNotificationDiscountOffer)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *NotificationMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case notification.EdgeNotificationRecipient:
		if id := m.notification_recipient; id != nil {
			return []ent.Value{*id}
		}
	case notification.EdgeNotificationDiscountOffer:
		if id := m.notification_discount_offer; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *NotificationMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *NotificationMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *NotificationMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearednotification_recipient {
		edges = append(edges, notification.EdgeNotificationRecipient)
	}
	if m.clearednotification_discount_offer {
		edges = append(edges, notification.EdgeNotificationDiscountOffer)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *NotificationMutation) EdgeCleared(name string) bool {
	switch name {
	case notification.EdgeNotificationRecipient:
		return m.clearednotification_recipient
	case notification.EdgeNotificationDiscountOffer:
		return m.clearednotification_discount_offer
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *NotificationMutation) ClearEdge(name string) error {
	switch name {
	case notification.EdgeNotificationRecipient:
		m.ClearNotificationRecipient()
		return nil
	case notification.EdgeNotificationDiscountOffer:
		m.ClearNotificationDiscountOffer()
		return nil
	}
	return fmt.Errorf("unknown Notification unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *NotificationMutation) ResetEdge(name string) error {
	switch name {
	case notification.EdgeNotificationRecipient:
		m.ResetNotificationRecipient()
		return nil
	case notification.EdgeNotificationDiscountOffer:
		m.ResetNotificationDiscountOffer()
		return nil
	}
	return fmt.Errorf("unknown Notification edge %s", name)
}

// PlaidInstitutionMutation represents an operation that mutates the PlaidInstitution nodes in the graph.
type PlaidInstitutionMutation struct {
	config
	op                Op
	typ               string
	id                *int
	institution_id    *string
	name              *string
	clearedFields     map[string]struct{}
	plaid_item        *int
	clearedplaid_item bool
	accounts          map[int]struct{}
	removedaccounts   map[int]struct{}
	clearedaccounts   bool
	done              bool
	oldValue          func(context.Context) (*PlaidInstitution, error)
	predicates        []predicate.PlaidInstitution
}

var _ ent.Mutation = (*PlaidInstitutionMutation)(nil)

// plaidinstitutionOption allows management of the mutation configuration using functional options.
type plaidinstitutionOption func(*PlaidInstitutionMutation)

// newPlaidInstitutionMutation creates new mutation for the PlaidInstitution entity.
func newPlaidInstitutionMutation(c config, op Op, opts ...plaidinstitutionOption) *PlaidInstitutionMutation {
	m := &PlaidInstitutionMutation{
		config:        c,
		op:            op,
		typ:           TypePlaidInstitution,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withPlaidInstitutionID sets the ID field of the mutation.
func withPlaidInstitutionID(id int) plaidinstitutionOption {
	return func(m *PlaidInstitutionMutation) {
		var (
			err   error
			once  sync.Once
			value *PlaidInstitution
		)
		m.oldValue = func(ctx context.Context) (*PlaidInstitution, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().PlaidInstitution.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withPlaidInstitution sets the old PlaidInstitution of the mutation.
func withPlaidInstitution(node *PlaidInstitution) plaidinstitutionOption {
	return func(m *PlaidInstitutionMutation) {
		m.oldValue = func(context.Context) (*PlaidInstitution, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m PlaidInstitutionMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m PlaidInstitutionMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *PlaidInstitutionMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *PlaidInstitutionMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().PlaidInstitution.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetInstitutionID sets the "institution_id" field.
func (m *PlaidInstitutionMutation) SetInstitutionID(s string) {
	m.institution_id = &s
}

// InstitutionID returns the value of the "institution_id" field in the mutation.
func (m *PlaidInstitutionMutation) InstitutionID() (r string, exists bool) {
	v := m.institution_id
	if v == nil {
		return
	}
	return *v, true
}

// OldInstitutionID returns the old "institution_id" field's value of the PlaidInstitution entity.
// If the PlaidInstitution object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PlaidInstitutionMutation) OldInstitutionID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldInstitutionID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldInstitutionID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldInstitutionID: %w", err)
	}
	return oldValue.InstitutionID, nil
}

// ResetInstitutionID resets all changes to the "institution_id" field.
func (m *PlaidInstitutionMutation) ResetInstitutionID() {
	m.institution_id = nil
}

// SetName sets the "name" field.
func (m *PlaidInstitutionMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *PlaidInstitutionMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the PlaidInstitution entity.
// If the PlaidInstitution object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PlaidInstitutionMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *PlaidInstitutionMutation) ResetName() {
	m.name = nil
}

// SetPlaidItemID sets the "plaid_item" edge to the PlaidItem entity by id.
func (m *PlaidInstitutionMutation) SetPlaidItemID(id int) {
	m.plaid_item = &id
}

// ClearPlaidItem clears the "plaid_item" edge to the PlaidItem entity.
func (m *PlaidInstitutionMutation) ClearPlaidItem() {
	m.clearedplaid_item = true
}

// PlaidItemCleared reports if the "plaid_item" edge to the PlaidItem entity was cleared.
func (m *PlaidInstitutionMutation) PlaidItemCleared() bool {
	return m.clearedplaid_item
}

// PlaidItemID returns the "plaid_item" edge ID in the mutation.
func (m *PlaidInstitutionMutation) PlaidItemID() (id int, exists bool) {
	if m.plaid_item != nil {
		return *m.plaid_item, true
	}
	return
}

// PlaidItemIDs returns the "plaid_item" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// PlaidItemID instead. It exists only for internal usage by the builders.
func (m *PlaidInstitutionMutation) PlaidItemIDs() (ids []int) {
	if id := m.plaid_item; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetPlaidItem resets all changes to the "plaid_item" edge.
func (m *PlaidInstitutionMutation) ResetPlaidItem() {
	m.plaid_item = nil
	m.clearedplaid_item = false
}

// AddAccountIDs adds the "accounts" edge to the PlaidInstitutionAccount entity by ids.
func (m *PlaidInstitutionMutation) AddAccountIDs(ids ...int) {
	if m.accounts == nil {
		m.accounts = make(map[int]struct{})
	}
	for i := range ids {
		m.accounts[ids[i]] = struct{}{}
	}
}

// ClearAccounts clears the "accounts" edge to the PlaidInstitutionAccount entity.
func (m *PlaidInstitutionMutation) ClearAccounts() {
	m.clearedaccounts = true
}

// AccountsCleared reports if the "accounts" edge to the PlaidInstitutionAccount entity was cleared.
func (m *PlaidInstitutionMutation) AccountsCleared() bool {
	return m.clearedaccounts
}

// RemoveAccountIDs removes the "accounts" edge to the PlaidInstitutionAccount entity by IDs.
func (m *PlaidInstitutionMutation) RemoveAccountIDs(ids ...int) {
	if m.removedaccounts == nil {
		m.removedaccounts = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.accounts, ids[i])
		m.removedaccounts[ids[i]] = struct{}{}
	}
}

// RemovedAccounts returns the removed IDs of the "accounts" edge to the PlaidInstitutionAccount entity.
func (m *PlaidInstitutionMutation) RemovedAccountsIDs() (ids []int) {
	for id := range m.removedaccounts {
		ids = append(ids, id)
	}
	return
}

// AccountsIDs returns the "accounts" edge IDs in the mutation.
func (m *PlaidInstitutionMutation) AccountsIDs() (ids []int) {
	for id := range m.accounts {
		ids = append(ids, id)
	}
	return
}

// ResetAccounts resets all changes to the "accounts" edge.
func (m *PlaidInstitutionMutation) ResetAccounts() {
	m.accounts = nil
	m.clearedaccounts = false
	m.removedaccounts = nil
}

// Where appends a list predicates to the PlaidInstitutionMutation builder.
func (m *PlaidInstitutionMutation) Where(ps ...predicate.PlaidInstitution) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the PlaidInstitutionMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *PlaidInstitutionMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.PlaidInstitution, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *PlaidInstitutionMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *PlaidInstitutionMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (PlaidInstitution).
func (m *PlaidInstitutionMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *PlaidInstitutionMutation) Fields() []string {
	fields := make([]string, 0, 2)
	if m.institution_id != nil {
		fields = append(fields, plaidinstitution.FieldInstitutionID)
	}
	if m.name != nil {
		fields = append(fields, plaidinstitution.FieldName)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *PlaidInstitutionMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case plaidinstitution.FieldInstitutionID:
		return m.InstitutionID()
	case plaidinstitution.FieldName:
		return m.Name()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *PlaidInstitutionMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case plaidinstitution.FieldInstitutionID:
		return m.OldInstitutionID(ctx)
	case plaidinstitution.FieldName:
		return m.OldName(ctx)
	}
	return nil, fmt.Errorf("unknown PlaidInstitution field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PlaidInstitutionMutation) SetField(name string, value ent.Value) error {
	switch name {
	case plaidinstitution.FieldInstitutionID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetInstitutionID(v)
		return nil
	case plaidinstitution.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	}
	return fmt.Errorf("unknown PlaidInstitution field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *PlaidInstitutionMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *PlaidInstitutionMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PlaidInstitutionMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown PlaidInstitution numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *PlaidInstitutionMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *PlaidInstitutionMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *PlaidInstitutionMutation) ClearField(name string) error {
	return fmt.Errorf("unknown PlaidInstitution nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *PlaidInstitutionMutation) ResetField(name string) error {
	switch name {
	case plaidinstitution.FieldInstitutionID:
		m.ResetInstitutionID()
		return nil
	case plaidinstitution.FieldName:
		m.ResetName()
		return nil
	}
	return fmt.Errorf("unknown PlaidInstitution field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *PlaidInstitutionMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.plaid_item != nil {
		edges = append(edges, plaidinstitution.EdgePlaidItem)
	}
	if m.accounts != nil {
		edges = append(edges, plaidinstitution.EdgeAccounts)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *PlaidInstitutionMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case plaidinstitution.EdgePlaidItem:
		if id := m.plaid_item; id != nil {
			return []ent.Value{*id}
		}
	case plaidinstitution.EdgeAccounts:
		ids := make([]ent.Value, 0, len(m.accounts))
		for id := range m.accounts {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *PlaidInstitutionMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedaccounts != nil {
		edges = append(edges, plaidinstitution.EdgeAccounts)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *PlaidInstitutionMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case plaidinstitution.EdgeAccounts:
		ids := make([]ent.Value, 0, len(m.removedaccounts))
		for id := range m.removedaccounts {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *PlaidInstitutionMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedplaid_item {
		edges = append(edges, plaidinstitution.EdgePlaidItem)
	}
	if m.clearedaccounts {
		edges = append(edges, plaidinstitution.EdgeAccounts)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *PlaidInstitutionMutation) EdgeCleared(name string) bool {
	switch name {
	case plaidinstitution.EdgePlaidItem:
		return m.clearedplaid_item
	case plaidinstitution.EdgeAccounts:
		return m.clearedaccounts
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *PlaidInstitutionMutation) ClearEdge(name string) error {
	switch name {
	case plaidinstitution.EdgePlaidItem:
		m.ClearPlaidItem()
		return nil
	}
	return fmt.Errorf("unknown PlaidInstitution unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *PlaidInstitutionMutation) ResetEdge(name string) error {
	switch name {
	case plaidinstitution.EdgePlaidItem:
		m.ResetPlaidItem()
		return nil
	case plaidinstitution.EdgeAccounts:
		m.ResetAccounts()
		return nil
	}
	return fmt.Errorf("unknown PlaidInstitution edge %s", name)
}

// PlaidInstitutionAccountMutation represents an operation that mutates the PlaidInstitutionAccount nodes in the graph.
type PlaidInstitutionAccountMutation struct {
	config
	op                        Op
	typ                       string
	id                        *int
	account_id                *string
	balance_available         *float64
	addbalance_available      *float64
	balance_current           *float64
	addbalance_current        *float64
	balance_iso_currency_code *string
	mask                      *string
	name                      *string
	official_name             *string
	_type                     *string
	clearedFields             map[string]struct{}
	parent_institution        *int
	clearedparent_institution bool
	transactions              map[int]struct{}
	removedtransactions       map[int]struct{}
	clearedtransactions       bool
	done                      bool
	oldValue                  func(context.Context) (*PlaidInstitutionAccount, error)
	predicates                []predicate.PlaidInstitutionAccount
}

var _ ent.Mutation = (*PlaidInstitutionAccountMutation)(nil)

// plaidinstitutionaccountOption allows management of the mutation configuration using functional options.
type plaidinstitutionaccountOption func(*PlaidInstitutionAccountMutation)

// newPlaidInstitutionAccountMutation creates new mutation for the PlaidInstitutionAccount entity.
func newPlaidInstitutionAccountMutation(c config, op Op, opts ...plaidinstitutionaccountOption) *PlaidInstitutionAccountMutation {
	m := &PlaidInstitutionAccountMutation{
		config:        c,
		op:            op,
		typ:           TypePlaidInstitutionAccount,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withPlaidInstitutionAccountID sets the ID field of the mutation.
func withPlaidInstitutionAccountID(id int) plaidinstitutionaccountOption {
	return func(m *PlaidInstitutionAccountMutation) {
		var (
			err   error
			once  sync.Once
			value *PlaidInstitutionAccount
		)
		m.oldValue = func(ctx context.Context) (*PlaidInstitutionAccount, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().PlaidInstitutionAccount.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withPlaidInstitutionAccount sets the old PlaidInstitutionAccount of the mutation.
func withPlaidInstitutionAccount(node *PlaidInstitutionAccount) plaidinstitutionaccountOption {
	return func(m *PlaidInstitutionAccountMutation) {
		m.oldValue = func(context.Context) (*PlaidInstitutionAccount, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m PlaidInstitutionAccountMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m PlaidInstitutionAccountMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *PlaidInstitutionAccountMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *PlaidInstitutionAccountMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().PlaidInstitutionAccount.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetAccountID sets the "account_id" field.
func (m *PlaidInstitutionAccountMutation) SetAccountID(s string) {
	m.account_id = &s
}

// AccountID returns the value of the "account_id" field in the mutation.
func (m *PlaidInstitutionAccountMutation) AccountID() (r string, exists bool) {
	v := m.account_id
	if v == nil {
		return
	}
	return *v, true
}

// OldAccountID returns the old "account_id" field's value of the PlaidInstitutionAccount entity.
// If the PlaidInstitutionAccount object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PlaidInstitutionAccountMutation) OldAccountID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAccountID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAccountID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAccountID: %w", err)
	}
	return oldValue.AccountID, nil
}

// ResetAccountID resets all changes to the "account_id" field.
func (m *PlaidInstitutionAccountMutation) ResetAccountID() {
	m.account_id = nil
}

// SetBalanceAvailable sets the "balance_available" field.
func (m *PlaidInstitutionAccountMutation) SetBalanceAvailable(f float64) {
	m.balance_available = &f
	m.addbalance_available = nil
}

// BalanceAvailable returns the value of the "balance_available" field in the mutation.
func (m *PlaidInstitutionAccountMutation) BalanceAvailable() (r float64, exists bool) {
	v := m.balance_available
	if v == nil {
		return
	}
	return *v, true
}

// OldBalanceAvailable returns the old "balance_available" field's value of the PlaidInstitutionAccount entity.
// If the PlaidInstitutionAccount object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PlaidInstitutionAccountMutation) OldBalanceAvailable(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBalanceAvailable is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBalanceAvailable requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBalanceAvailable: %w", err)
	}
	return oldValue.BalanceAvailable, nil
}

// AddBalanceAvailable adds f to the "balance_available" field.
func (m *PlaidInstitutionAccountMutation) AddBalanceAvailable(f float64) {
	if m.addbalance_available != nil {
		*m.addbalance_available += f
	} else {
		m.addbalance_available = &f
	}
}

// AddedBalanceAvailable returns the value that was added to the "balance_available" field in this mutation.
func (m *PlaidInstitutionAccountMutation) AddedBalanceAvailable() (r float64, exists bool) {
	v := m.addbalance_available
	if v == nil {
		return
	}
	return *v, true
}

// ResetBalanceAvailable resets all changes to the "balance_available" field.
func (m *PlaidInstitutionAccountMutation) ResetBalanceAvailable() {
	m.balance_available = nil
	m.addbalance_available = nil
}

// SetBalanceCurrent sets the "balance_current" field.
func (m *PlaidInstitutionAccountMutation) SetBalanceCurrent(f float64) {
	m.balance_current = &f
	m.addbalance_current = nil
}

// BalanceCurrent returns the value of the "balance_current" field in the mutation.
func (m *PlaidInstitutionAccountMutation) BalanceCurrent() (r float64, exists bool) {
	v := m.balance_current
	if v == nil {
		return
	}
	return *v, true
}

// OldBalanceCurrent returns the old "balance_current" field's value of the PlaidInstitutionAccount entity.
// If the PlaidInstitutionAccount object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PlaidInstitutionAccountMutation) OldBalanceCurrent(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBalanceCurrent is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBalanceCurrent requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBalanceCurrent: %w", err)
	}
	return oldValue.BalanceCurrent, nil
}

// AddBalanceCurrent adds f to the "balance_current" field.
func (m *PlaidInstitutionAccountMutation) AddBalanceCurrent(f float64) {
	if m.addbalance_current != nil {
		*m.addbalance_current += f
	} else {
		m.addbalance_current = &f
	}
}

// AddedBalanceCurrent returns the value that was added to the "balance_current" field in this mutation.
func (m *PlaidInstitutionAccountMutation) AddedBalanceCurrent() (r float64, exists bool) {
	v := m.addbalance_current
	if v == nil {
		return
	}
	return *v, true
}

// ResetBalanceCurrent resets all changes to the "balance_current" field.
func (m *PlaidInstitutionAccountMutation) ResetBalanceCurrent() {
	m.balance_current = nil
	m.addbalance_current = nil
}

// SetBalanceIsoCurrencyCode sets the "balance_iso_currency_code" field.
func (m *PlaidInstitutionAccountMutation) SetBalanceIsoCurrencyCode(s string) {
	m.balance_iso_currency_code = &s
}

// BalanceIsoCurrencyCode returns the value of the "balance_iso_currency_code" field in the mutation.
func (m *PlaidInstitutionAccountMutation) BalanceIsoCurrencyCode() (r string, exists bool) {
	v := m.balance_iso_currency_code
	if v == nil {
		return
	}
	return *v, true
}

// OldBalanceIsoCurrencyCode returns the old "balance_iso_currency_code" field's value of the PlaidInstitutionAccount entity.
// If the PlaidInstitutionAccount object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PlaidInstitutionAccountMutation) OldBalanceIsoCurrencyCode(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBalanceIsoCurrencyCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBalanceIsoCurrencyCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBalanceIsoCurrencyCode: %w", err)
	}
	return oldValue.BalanceIsoCurrencyCode, nil
}

// ResetBalanceIsoCurrencyCode resets all changes to the "balance_iso_currency_code" field.
func (m *PlaidInstitutionAccountMutation) ResetBalanceIsoCurrencyCode() {
	m.balance_iso_currency_code = nil
}

// SetMask sets the "mask" field.
func (m *PlaidInstitutionAccountMutation) SetMask(s string) {
	m.mask = &s
}

// Mask returns the value of the "mask" field in the mutation.
func (m *PlaidInstitutionAccountMutation) Mask() (r string, exists bool) {
	v := m.mask
	if v == nil {
		return
	}
	return *v, true
}

// OldMask returns the old "mask" field's value of the PlaidInstitutionAccount entity.
// If the PlaidInstitutionAccount object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PlaidInstitutionAccountMutation) OldMask(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMask is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMask requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMask: %w", err)
	}
	return oldValue.Mask, nil
}

// ResetMask resets all changes to the "mask" field.
func (m *PlaidInstitutionAccountMutation) ResetMask() {
	m.mask = nil
}

// SetName sets the "name" field.
func (m *PlaidInstitutionAccountMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *PlaidInstitutionAccountMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the PlaidInstitutionAccount entity.
// If the PlaidInstitutionAccount object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PlaidInstitutionAccountMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *PlaidInstitutionAccountMutation) ResetName() {
	m.name = nil
}

// SetOfficialName sets the "official_name" field.
func (m *PlaidInstitutionAccountMutation) SetOfficialName(s string) {
	m.official_name = &s
}

// OfficialName returns the value of the "official_name" field in the mutation.
func (m *PlaidInstitutionAccountMutation) OfficialName() (r string, exists bool) {
	v := m.official_name
	if v == nil {
		return
	}
	return *v, true
}

// OldOfficialName returns the old "official_name" field's value of the PlaidInstitutionAccount entity.
// If the PlaidInstitutionAccount object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PlaidInstitutionAccountMutation) OldOfficialName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOfficialName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOfficialName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOfficialName: %w", err)
	}
	return oldValue.OfficialName, nil
}

// ClearOfficialName clears the value of the "official_name" field.
func (m *PlaidInstitutionAccountMutation) ClearOfficialName() {
	m.official_name = nil
	m.clearedFields[plaidinstitutionaccount.FieldOfficialName] = struct{}{}
}

// OfficialNameCleared returns if the "official_name" field was cleared in this mutation.
func (m *PlaidInstitutionAccountMutation) OfficialNameCleared() bool {
	_, ok := m.clearedFields[plaidinstitutionaccount.FieldOfficialName]
	return ok
}

// ResetOfficialName resets all changes to the "official_name" field.
func (m *PlaidInstitutionAccountMutation) ResetOfficialName() {
	m.official_name = nil
	delete(m.clearedFields, plaidinstitutionaccount.FieldOfficialName)
}

// SetType sets the "type" field.
func (m *PlaidInstitutionAccountMutation) SetType(s string) {
	m._type = &s
}

// GetType returns the value of the "type" field in the mutation.
func (m *PlaidInstitutionAccountMutation) GetType() (r string, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the PlaidInstitutionAccount entity.
// If the PlaidInstitutionAccount object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PlaidInstitutionAccountMutation) OldType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// ResetType resets all changes to the "type" field.
func (m *PlaidInstitutionAccountMutation) ResetType() {
	m._type = nil
}

// SetParentInstitutionID sets the "parent_institution" edge to the PlaidInstitution entity by id.
func (m *PlaidInstitutionAccountMutation) SetParentInstitutionID(id int) {
	m.parent_institution = &id
}

// ClearParentInstitution clears the "parent_institution" edge to the PlaidInstitution entity.
func (m *PlaidInstitutionAccountMutation) ClearParentInstitution() {
	m.clearedparent_institution = true
}

// ParentInstitutionCleared reports if the "parent_institution" edge to the PlaidInstitution entity was cleared.
func (m *PlaidInstitutionAccountMutation) ParentInstitutionCleared() bool {
	return m.clearedparent_institution
}

// ParentInstitutionID returns the "parent_institution" edge ID in the mutation.
func (m *PlaidInstitutionAccountMutation) ParentInstitutionID() (id int, exists bool) {
	if m.parent_institution != nil {
		return *m.parent_institution, true
	}
	return
}

// ParentInstitutionIDs returns the "parent_institution" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ParentInstitutionID instead. It exists only for internal usage by the builders.
func (m *PlaidInstitutionAccountMutation) ParentInstitutionIDs() (ids []int) {
	if id := m.parent_institution; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetParentInstitution resets all changes to the "parent_institution" edge.
func (m *PlaidInstitutionAccountMutation) ResetParentInstitution() {
	m.parent_institution = nil
	m.clearedparent_institution = false
}

// AddTransactionIDs adds the "transactions" edge to the Transaction entity by ids.
func (m *PlaidInstitutionAccountMutation) AddTransactionIDs(ids ...int) {
	if m.transactions == nil {
		m.transactions = make(map[int]struct{})
	}
	for i := range ids {
		m.transactions[ids[i]] = struct{}{}
	}
}

// ClearTransactions clears the "transactions" edge to the Transaction entity.
func (m *PlaidInstitutionAccountMutation) ClearTransactions() {
	m.clearedtransactions = true
}

// TransactionsCleared reports if the "transactions" edge to the Transaction entity was cleared.
func (m *PlaidInstitutionAccountMutation) TransactionsCleared() bool {
	return m.clearedtransactions
}

// RemoveTransactionIDs removes the "transactions" edge to the Transaction entity by IDs.
func (m *PlaidInstitutionAccountMutation) RemoveTransactionIDs(ids ...int) {
	if m.removedtransactions == nil {
		m.removedtransactions = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.transactions, ids[i])
		m.removedtransactions[ids[i]] = struct{}{}
	}
}

// RemovedTransactions returns the removed IDs of the "transactions" edge to the Transaction entity.
func (m *PlaidInstitutionAccountMutation) RemovedTransactionsIDs() (ids []int) {
	for id := range m.removedtransactions {
		ids = append(ids, id)
	}
	return
}

// TransactionsIDs returns the "transactions" edge IDs in the mutation.
func (m *PlaidInstitutionAccountMutation) TransactionsIDs() (ids []int) {
	for id := range m.transactions {
		ids = append(ids, id)
	}
	return
}

// ResetTransactions resets all changes to the "transactions" edge.
func (m *PlaidInstitutionAccountMutation) ResetTransactions() {
	m.transactions = nil
	m.clearedtransactions = false
	m.removedtransactions = nil
}

// Where appends a list predicates to the PlaidInstitutionAccountMutation builder.
func (m *PlaidInstitutionAccountMutation) Where(ps ...predicate.PlaidInstitutionAccount) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the PlaidInstitutionAccountMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *PlaidInstitutionAccountMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.PlaidInstitutionAccount, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *PlaidInstitutionAccountMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *PlaidInstitutionAccountMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (PlaidInstitutionAccount).
func (m *PlaidInstitutionAccountMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *PlaidInstitutionAccountMutation) Fields() []string {
	fields := make([]string, 0, 8)
	if m.account_id != nil {
		fields = append(fields, plaidinstitutionaccount.FieldAccountID)
	}
	if m.balance_available != nil {
		fields = append(fields, plaidinstitutionaccount.FieldBalanceAvailable)
	}
	if m.balance_current != nil {
		fields = append(fields, plaidinstitutionaccount.FieldBalanceCurrent)
	}
	if m.balance_iso_currency_code != nil {
		fields = append(fields, plaidinstitutionaccount.FieldBalanceIsoCurrencyCode)
	}
	if m.mask != nil {
		fields = append(fields, plaidinstitutionaccount.FieldMask)
	}
	if m.name != nil {
		fields = append(fields, plaidinstitutionaccount.FieldName)
	}
	if m.official_name != nil {
		fields = append(fields, plaidinstitutionaccount.FieldOfficialName)
	}
	if m._type != nil {
		fields = append(fields, plaidinstitutionaccount.FieldType)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *PlaidInstitutionAccountMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case plaidinstitutionaccount.FieldAccountID:
		return m.AccountID()
	case plaidinstitutionaccount.FieldBalanceAvailable:
		return m.BalanceAvailable()
	case plaidinstitutionaccount.FieldBalanceCurrent:
		return m.BalanceCurrent()
	case plaidinstitutionaccount.FieldBalanceIsoCurrencyCode:
		return m.BalanceIsoCurrencyCode()
	case plaidinstitutionaccount.FieldMask:
		return m.Mask()
	case plaidinstitutionaccount.FieldName:
		return m.Name()
	case plaidinstitutionaccount.FieldOfficialName:
		return m.OfficialName()
	case plaidinstitutionaccount.FieldType:
		return m.GetType()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *PlaidInstitutionAccountMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case plaidinstitutionaccount.FieldAccountID:
		return m.OldAccountID(ctx)
	case plaidinstitutionaccount.FieldBalanceAvailable:
		return m.OldBalanceAvailable(ctx)
	case plaidinstitutionaccount.FieldBalanceCurrent:
		return m.OldBalanceCurrent(ctx)
	case plaidinstitutionaccount.FieldBalanceIsoCurrencyCode:
		return m.OldBalanceIsoCurrencyCode(ctx)
	case plaidinstitutionaccount.FieldMask:
		return m.OldMask(ctx)
	case plaidinstitutionaccount.FieldName:
		return m.OldName(ctx)
	case plaidinstitutionaccount.FieldOfficialName:
		return m.OldOfficialName(ctx)
	case plaidinstitutionaccount.FieldType:
		return m.OldType(ctx)
	}
	return nil, fmt.Errorf("unknown PlaidInstitutionAccount field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PlaidInstitutionAccountMutation) SetField(name string, value ent.Value) error {
	switch name {
	case plaidinstitutionaccount.FieldAccountID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAccountID(v)
		return nil
	case plaidinstitutionaccount.FieldBalanceAvailable:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBalanceAvailable(v)
		return nil
	case plaidinstitutionaccount.FieldBalanceCurrent:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBalanceCurrent(v)
		return nil
	case plaidinstitutionaccount.FieldBalanceIsoCurrencyCode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBalanceIsoCurrencyCode(v)
		return nil
	case plaidinstitutionaccount.FieldMask:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMask(v)
		return nil
	case plaidinstitutionaccount.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case plaidinstitutionaccount.FieldOfficialName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOfficialName(v)
		return nil
	case plaidinstitutionaccount.FieldType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	}
	return fmt.Errorf("unknown PlaidInstitutionAccount field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *PlaidInstitutionAccountMutation) AddedFields() []string {
	var fields []string
	if m.addbalance_available != nil {
		fields = append(fields, plaidinstitutionaccount.FieldBalanceAvailable)
	}
	if m.addbalance_current != nil {
		fields = append(fields, plaidinstitutionaccount.FieldBalanceCurrent)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *PlaidInstitutionAccountMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case plaidinstitutionaccount.FieldBalanceAvailable:
		return m.AddedBalanceAvailable()
	case plaidinstitutionaccount.FieldBalanceCurrent:
		return m.AddedBalanceCurrent()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PlaidInstitutionAccountMutation) AddField(name string, value ent.Value) error {
	switch name {
	case plaidinstitutionaccount.FieldBalanceAvailable:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddBalanceAvailable(v)
		return nil
	case plaidinstitutionaccount.FieldBalanceCurrent:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddBalanceCurrent(v)
		return nil
	}
	return fmt.Errorf("unknown PlaidInstitutionAccount numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *PlaidInstitutionAccountMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(plaidinstitutionaccount.FieldOfficialName) {
		fields = append(fields, plaidinstitutionaccount.FieldOfficialName)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *PlaidInstitutionAccountMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *PlaidInstitutionAccountMutation) ClearField(name string) error {
	switch name {
	case plaidinstitutionaccount.FieldOfficialName:
		m.ClearOfficialName()
		return nil
	}
	return fmt.Errorf("unknown PlaidInstitutionAccount nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *PlaidInstitutionAccountMutation) ResetField(name string) error {
	switch name {
	case plaidinstitutionaccount.FieldAccountID:
		m.ResetAccountID()
		return nil
	case plaidinstitutionaccount.FieldBalanceAvailable:
		m.ResetBalanceAvailable()
		return nil
	case plaidinstitutionaccount.FieldBalanceCurrent:
		m.ResetBalanceCurrent()
		return nil
	case plaidinstitutionaccount.FieldBalanceIsoCurrencyCode:
		m.ResetBalanceIsoCurrencyCode()
		return nil
	case plaidinstitutionaccount.FieldMask:
		m.ResetMask()
		return nil
	case plaidinstitutionaccount.FieldName:
		m.ResetName()
		return nil
	case plaidinstitutionaccount.FieldOfficialName:
		m.ResetOfficialName()
		return nil
	case plaidinstitutionaccount.FieldType:
		m.ResetType()
		return nil
	}
	return fmt.Errorf("unknown PlaidInstitutionAccount field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *PlaidInstitutionAccountMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.parent_institution != nil {
		edges = append(edges, plaidinstitutionaccount.EdgeParentInstitution)
	}
	if m.transactions != nil {
		edges = append(edges, plaidinstitutionaccount.EdgeTransactions)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *PlaidInstitutionAccountMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case plaidinstitutionaccount.EdgeParentInstitution:
		if id := m.parent_institution; id != nil {
			return []ent.Value{*id}
		}
	case plaidinstitutionaccount.EdgeTransactions:
		ids := make([]ent.Value, 0, len(m.transactions))
		for id := range m.transactions {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *PlaidInstitutionAccountMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedtransactions != nil {
		edges = append(edges, plaidinstitutionaccount.EdgeTransactions)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *PlaidInstitutionAccountMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case plaidinstitutionaccount.EdgeTransactions:
		ids := make([]ent.Value, 0, len(m.removedtransactions))
		for id := range m.removedtransactions {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *PlaidInstitutionAccountMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedparent_institution {
		edges = append(edges, plaidinstitutionaccount.EdgeParentInstitution)
	}
	if m.clearedtransactions {
		edges = append(edges, plaidinstitutionaccount.EdgeTransactions)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *PlaidInstitutionAccountMutation) EdgeCleared(name string) bool {
	switch name {
	case plaidinstitutionaccount.EdgeParentInstitution:
		return m.clearedparent_institution
	case plaidinstitutionaccount.EdgeTransactions:
		return m.clearedtransactions
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *PlaidInstitutionAccountMutation) ClearEdge(name string) error {
	switch name {
	case plaidinstitutionaccount.EdgeParentInstitution:
		m.ClearParentInstitution()
		return nil
	}
	return fmt.Errorf("unknown PlaidInstitutionAccount unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *PlaidInstitutionAccountMutation) ResetEdge(name string) error {
	switch name {
	case plaidinstitutionaccount.EdgeParentInstitution:
		m.ResetParentInstitution()
		return nil
	case plaidinstitutionaccount.EdgeTransactions:
		m.ResetTransactions()
		return nil
	}
	return fmt.Errorf("unknown PlaidInstitutionAccount edge %s", name)
}

// PlaidItemMutation represents an operation that mutates the PlaidItem nodes in the graph.
type PlaidItemMutation struct {
	config
	op                       Op
	typ                      string
	id                       *int
	item_id                  *string
	access_token             *string
	created_at               *time.Time
	updated_at               *time.Time
	clearedFields            map[string]struct{}
	owner                    *int
	clearedowner             bool
	transaction_syncs        map[int]struct{}
	removedtransaction_syncs map[int]struct{}
	clearedtransaction_syncs bool
	institution              *int
	clearedinstitution       bool
	done                     bool
	oldValue                 func(context.Context) (*PlaidItem, error)
	predicates               []predicate.PlaidItem
}

var _ ent.Mutation = (*PlaidItemMutation)(nil)

// plaiditemOption allows management of the mutation configuration using functional options.
type plaiditemOption func(*PlaidItemMutation)

// newPlaidItemMutation creates new mutation for the PlaidItem entity.
func newPlaidItemMutation(c config, op Op, opts ...plaiditemOption) *PlaidItemMutation {
	m := &PlaidItemMutation{
		config:        c,
		op:            op,
		typ:           TypePlaidItem,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withPlaidItemID sets the ID field of the mutation.
func withPlaidItemID(id int) plaiditemOption {
	return func(m *PlaidItemMutation) {
		var (
			err   error
			once  sync.Once
			value *PlaidItem
		)
		m.oldValue = func(ctx context.Context) (*PlaidItem, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().PlaidItem.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withPlaidItem sets the old PlaidItem of the mutation.
func withPlaidItem(node *PlaidItem) plaiditemOption {
	return func(m *PlaidItemMutation) {
		m.oldValue = func(context.Context) (*PlaidItem, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m PlaidItemMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m PlaidItemMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *PlaidItemMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *PlaidItemMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().PlaidItem.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetItemID sets the "item_id" field.
func (m *PlaidItemMutation) SetItemID(s string) {
	m.item_id = &s
}

// ItemID returns the value of the "item_id" field in the mutation.
func (m *PlaidItemMutation) ItemID() (r string, exists bool) {
	v := m.item_id
	if v == nil {
		return
	}
	return *v, true
}

// OldItemID returns the old "item_id" field's value of the PlaidItem entity.
// If the PlaidItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PlaidItemMutation) OldItemID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldItemID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldItemID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldItemID: %w", err)
	}
	return oldValue.ItemID, nil
}

// ResetItemID resets all changes to the "item_id" field.
func (m *PlaidItemMutation) ResetItemID() {
	m.item_id = nil
}

// SetAccessToken sets the "access_token" field.
func (m *PlaidItemMutation) SetAccessToken(s string) {
	m.access_token = &s
}

// AccessToken returns the value of the "access_token" field in the mutation.
func (m *PlaidItemMutation) AccessToken() (r string, exists bool) {
	v := m.access_token
	if v == nil {
		return
	}
	return *v, true
}

// OldAccessToken returns the old "access_token" field's value of the PlaidItem entity.
// If the PlaidItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PlaidItemMutation) OldAccessToken(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAccessToken is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAccessToken requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAccessToken: %w", err)
	}
	return oldValue.AccessToken, nil
}

// ResetAccessToken resets all changes to the "access_token" field.
func (m *PlaidItemMutation) ResetAccessToken() {
	m.access_token = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *PlaidItemMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *PlaidItemMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the PlaidItem entity.
// If the PlaidItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PlaidItemMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *PlaidItemMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *PlaidItemMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *PlaidItemMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the PlaidItem entity.
// If the PlaidItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PlaidItemMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *PlaidItemMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetOwnerID sets the "owner" edge to the User entity by id.
func (m *PlaidItemMutation) SetOwnerID(id int) {
	m.owner = &id
}

// ClearOwner clears the "owner" edge to the User entity.
func (m *PlaidItemMutation) ClearOwner() {
	m.clearedowner = true
}

// OwnerCleared reports if the "owner" edge to the User entity was cleared.
func (m *PlaidItemMutation) OwnerCleared() bool {
	return m.clearedowner
}

// OwnerID returns the "owner" edge ID in the mutation.
func (m *PlaidItemMutation) OwnerID() (id int, exists bool) {
	if m.owner != nil {
		return *m.owner, true
	}
	return
}

// OwnerIDs returns the "owner" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// OwnerID instead. It exists only for internal usage by the builders.
func (m *PlaidItemMutation) OwnerIDs() (ids []int) {
	if id := m.owner; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetOwner resets all changes to the "owner" edge.
func (m *PlaidItemMutation) ResetOwner() {
	m.owner = nil
	m.clearedowner = false
}

// AddTransactionSyncIDs adds the "transaction_syncs" edge to the TransactionSync entity by ids.
func (m *PlaidItemMutation) AddTransactionSyncIDs(ids ...int) {
	if m.transaction_syncs == nil {
		m.transaction_syncs = make(map[int]struct{})
	}
	for i := range ids {
		m.transaction_syncs[ids[i]] = struct{}{}
	}
}

// ClearTransactionSyncs clears the "transaction_syncs" edge to the TransactionSync entity.
func (m *PlaidItemMutation) ClearTransactionSyncs() {
	m.clearedtransaction_syncs = true
}

// TransactionSyncsCleared reports if the "transaction_syncs" edge to the TransactionSync entity was cleared.
func (m *PlaidItemMutation) TransactionSyncsCleared() bool {
	return m.clearedtransaction_syncs
}

// RemoveTransactionSyncIDs removes the "transaction_syncs" edge to the TransactionSync entity by IDs.
func (m *PlaidItemMutation) RemoveTransactionSyncIDs(ids ...int) {
	if m.removedtransaction_syncs == nil {
		m.removedtransaction_syncs = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.transaction_syncs, ids[i])
		m.removedtransaction_syncs[ids[i]] = struct{}{}
	}
}

// RemovedTransactionSyncs returns the removed IDs of the "transaction_syncs" edge to the TransactionSync entity.
func (m *PlaidItemMutation) RemovedTransactionSyncsIDs() (ids []int) {
	for id := range m.removedtransaction_syncs {
		ids = append(ids, id)
	}
	return
}

// TransactionSyncsIDs returns the "transaction_syncs" edge IDs in the mutation.
func (m *PlaidItemMutation) TransactionSyncsIDs() (ids []int) {
	for id := range m.transaction_syncs {
		ids = append(ids, id)
	}
	return
}

// ResetTransactionSyncs resets all changes to the "transaction_syncs" edge.
func (m *PlaidItemMutation) ResetTransactionSyncs() {
	m.transaction_syncs = nil
	m.clearedtransaction_syncs = false
	m.removedtransaction_syncs = nil
}

// SetInstitutionID sets the "institution" edge to the PlaidInstitution entity by id.
func (m *PlaidItemMutation) SetInstitutionID(id int) {
	m.institution = &id
}

// ClearInstitution clears the "institution" edge to the PlaidInstitution entity.
func (m *PlaidItemMutation) ClearInstitution() {
	m.clearedinstitution = true
}

// InstitutionCleared reports if the "institution" edge to the PlaidInstitution entity was cleared.
func (m *PlaidItemMutation) InstitutionCleared() bool {
	return m.clearedinstitution
}

// InstitutionID returns the "institution" edge ID in the mutation.
func (m *PlaidItemMutation) InstitutionID() (id int, exists bool) {
	if m.institution != nil {
		return *m.institution, true
	}
	return
}

// InstitutionIDs returns the "institution" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// InstitutionID instead. It exists only for internal usage by the builders.
func (m *PlaidItemMutation) InstitutionIDs() (ids []int) {
	if id := m.institution; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetInstitution resets all changes to the "institution" edge.
func (m *PlaidItemMutation) ResetInstitution() {
	m.institution = nil
	m.clearedinstitution = false
}

// Where appends a list predicates to the PlaidItemMutation builder.
func (m *PlaidItemMutation) Where(ps ...predicate.PlaidItem) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the PlaidItemMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *PlaidItemMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.PlaidItem, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *PlaidItemMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *PlaidItemMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (PlaidItem).
func (m *PlaidItemMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *PlaidItemMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m.item_id != nil {
		fields = append(fields, plaiditem.FieldItemID)
	}
	if m.access_token != nil {
		fields = append(fields, plaiditem.FieldAccessToken)
	}
	if m.created_at != nil {
		fields = append(fields, plaiditem.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, plaiditem.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *PlaidItemMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case plaiditem.FieldItemID:
		return m.ItemID()
	case plaiditem.FieldAccessToken:
		return m.AccessToken()
	case plaiditem.FieldCreatedAt:
		return m.CreatedAt()
	case plaiditem.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *PlaidItemMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case plaiditem.FieldItemID:
		return m.OldItemID(ctx)
	case plaiditem.FieldAccessToken:
		return m.OldAccessToken(ctx)
	case plaiditem.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case plaiditem.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown PlaidItem field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PlaidItemMutation) SetField(name string, value ent.Value) error {
	switch name {
	case plaiditem.FieldItemID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetItemID(v)
		return nil
	case plaiditem.FieldAccessToken:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAccessToken(v)
		return nil
	case plaiditem.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case plaiditem.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown PlaidItem field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *PlaidItemMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *PlaidItemMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PlaidItemMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown PlaidItem numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *PlaidItemMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *PlaidItemMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *PlaidItemMutation) ClearField(name string) error {
	return fmt.Errorf("unknown PlaidItem nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *PlaidItemMutation) ResetField(name string) error {
	switch name {
	case plaiditem.FieldItemID:
		m.ResetItemID()
		return nil
	case plaiditem.FieldAccessToken:
		m.ResetAccessToken()
		return nil
	case plaiditem.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case plaiditem.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown PlaidItem field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *PlaidItemMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.owner != nil {
		edges = append(edges, plaiditem.EdgeOwner)
	}
	if m.transaction_syncs != nil {
		edges = append(edges, plaiditem.EdgeTransactionSyncs)
	}
	if m.institution != nil {
		edges = append(edges, plaiditem.EdgeInstitution)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *PlaidItemMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case plaiditem.EdgeOwner:
		if id := m.owner; id != nil {
			return []ent.Value{*id}
		}
	case plaiditem.EdgeTransactionSyncs:
		ids := make([]ent.Value, 0, len(m.transaction_syncs))
		for id := range m.transaction_syncs {
			ids = append(ids, id)
		}
		return ids
	case plaiditem.EdgeInstitution:
		if id := m.institution; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *PlaidItemMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	if m.removedtransaction_syncs != nil {
		edges = append(edges, plaiditem.EdgeTransactionSyncs)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *PlaidItemMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case plaiditem.EdgeTransactionSyncs:
		ids := make([]ent.Value, 0, len(m.removedtransaction_syncs))
		for id := range m.removedtransaction_syncs {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *PlaidItemMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedowner {
		edges = append(edges, plaiditem.EdgeOwner)
	}
	if m.clearedtransaction_syncs {
		edges = append(edges, plaiditem.EdgeTransactionSyncs)
	}
	if m.clearedinstitution {
		edges = append(edges, plaiditem.EdgeInstitution)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *PlaidItemMutation) EdgeCleared(name string) bool {
	switch name {
	case plaiditem.EdgeOwner:
		return m.clearedowner
	case plaiditem.EdgeTransactionSyncs:
		return m.clearedtransaction_syncs
	case plaiditem.EdgeInstitution:
		return m.clearedinstitution
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *PlaidItemMutation) ClearEdge(name string) error {
	switch name {
	case plaiditem.EdgeOwner:
		m.ClearOwner()
		return nil
	case plaiditem.EdgeInstitution:
		m.ClearInstitution()
		return nil
	}
	return fmt.Errorf("unknown PlaidItem unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *PlaidItemMutation) ResetEdge(name string) error {
	switch name {
	case plaiditem.EdgeOwner:
		m.ResetOwner()
		return nil
	case plaiditem.EdgeTransactionSyncs:
		m.ResetTransactionSyncs()
		return nil
	case plaiditem.EdgeInstitution:
		m.ResetInstitution()
		return nil
	}
	return fmt.Errorf("unknown PlaidItem edge %s", name)
}

// SpendingCategoryMutation represents an operation that mutates the SpendingCategory nodes in the graph.
type SpendingCategoryMutation struct {
	config
	op                           Op
	typ                          string
	id                           *int
	name                         *string
	category_id                  *string
	created_at                   *time.Time
	clearedFields                map[string]struct{}
	category_transactions        map[int]struct{}
	removedcategory_transactions map[int]struct{}
	clearedcategory_transactions bool
	interested_users             map[int]struct{}
	removedinterested_users      map[int]struct{}
	clearedinterested_users      bool
	done                         bool
	oldValue                     func(context.Context) (*SpendingCategory, error)
	predicates                   []predicate.SpendingCategory
}

var _ ent.Mutation = (*SpendingCategoryMutation)(nil)

// spendingcategoryOption allows management of the mutation configuration using functional options.
type spendingcategoryOption func(*SpendingCategoryMutation)

// newSpendingCategoryMutation creates new mutation for the SpendingCategory entity.
func newSpendingCategoryMutation(c config, op Op, opts ...spendingcategoryOption) *SpendingCategoryMutation {
	m := &SpendingCategoryMutation{
		config:        c,
		op:            op,
		typ:           TypeSpendingCategory,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withSpendingCategoryID sets the ID field of the mutation.
func withSpendingCategoryID(id int) spendingcategoryOption {
	return func(m *SpendingCategoryMutation) {
		var (
			err   error
			once  sync.Once
			value *SpendingCategory
		)
		m.oldValue = func(ctx context.Context) (*SpendingCategory, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().SpendingCategory.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withSpendingCategory sets the old SpendingCategory of the mutation.
func withSpendingCategory(node *SpendingCategory) spendingcategoryOption {
	return func(m *SpendingCategoryMutation) {
		m.oldValue = func(context.Context) (*SpendingCategory, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m SpendingCategoryMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m SpendingCategoryMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *SpendingCategoryMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *SpendingCategoryMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().SpendingCategory.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "name" field.
func (m *SpendingCategoryMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *SpendingCategoryMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the SpendingCategory entity.
// If the SpendingCategory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SpendingCategoryMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *SpendingCategoryMutation) ResetName() {
	m.name = nil
}

// SetCategoryID sets the "category_id" field.
func (m *SpendingCategoryMutation) SetCategoryID(s string) {
	m.category_id = &s
}

// CategoryID returns the value of the "category_id" field in the mutation.
func (m *SpendingCategoryMutation) CategoryID() (r string, exists bool) {
	v := m.category_id
	if v == nil {
		return
	}
	return *v, true
}

// OldCategoryID returns the old "category_id" field's value of the SpendingCategory entity.
// If the SpendingCategory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SpendingCategoryMutation) OldCategoryID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCategoryID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCategoryID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCategoryID: %w", err)
	}
	return oldValue.CategoryID, nil
}

// ResetCategoryID resets all changes to the "category_id" field.
func (m *SpendingCategoryMutation) ResetCategoryID() {
	m.category_id = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *SpendingCategoryMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *SpendingCategoryMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the SpendingCategory entity.
// If the SpendingCategory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SpendingCategoryMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *SpendingCategoryMutation) ResetCreatedAt() {
	m.created_at = nil
}

// AddCategoryTransactionIDs adds the "category_transactions" edge to the Transaction entity by ids.
func (m *SpendingCategoryMutation) AddCategoryTransactionIDs(ids ...int) {
	if m.category_transactions == nil {
		m.category_transactions = make(map[int]struct{})
	}
	for i := range ids {
		m.category_transactions[ids[i]] = struct{}{}
	}
}

// ClearCategoryTransactions clears the "category_transactions" edge to the Transaction entity.
func (m *SpendingCategoryMutation) ClearCategoryTransactions() {
	m.clearedcategory_transactions = true
}

// CategoryTransactionsCleared reports if the "category_transactions" edge to the Transaction entity was cleared.
func (m *SpendingCategoryMutation) CategoryTransactionsCleared() bool {
	return m.clearedcategory_transactions
}

// RemoveCategoryTransactionIDs removes the "category_transactions" edge to the Transaction entity by IDs.
func (m *SpendingCategoryMutation) RemoveCategoryTransactionIDs(ids ...int) {
	if m.removedcategory_transactions == nil {
		m.removedcategory_transactions = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.category_transactions, ids[i])
		m.removedcategory_transactions[ids[i]] = struct{}{}
	}
}

// RemovedCategoryTransactions returns the removed IDs of the "category_transactions" edge to the Transaction entity.
func (m *SpendingCategoryMutation) RemovedCategoryTransactionsIDs() (ids []int) {
	for id := range m.removedcategory_transactions {
		ids = append(ids, id)
	}
	return
}

// CategoryTransactionsIDs returns the "category_transactions" edge IDs in the mutation.
func (m *SpendingCategoryMutation) CategoryTransactionsIDs() (ids []int) {
	for id := range m.category_transactions {
		ids = append(ids, id)
	}
	return
}

// ResetCategoryTransactions resets all changes to the "category_transactions" edge.
func (m *SpendingCategoryMutation) ResetCategoryTransactions() {
	m.category_transactions = nil
	m.clearedcategory_transactions = false
	m.removedcategory_transactions = nil
}

// AddInterestedUserIDs adds the "interested_users" edge to the User entity by ids.
func (m *SpendingCategoryMutation) AddInterestedUserIDs(ids ...int) {
	if m.interested_users == nil {
		m.interested_users = make(map[int]struct{})
	}
	for i := range ids {
		m.interested_users[ids[i]] = struct{}{}
	}
}

// ClearInterestedUsers clears the "interested_users" edge to the User entity.
func (m *SpendingCategoryMutation) ClearInterestedUsers() {
	m.clearedinterested_users = true
}

// InterestedUsersCleared reports if the "interested_users" edge to the User entity was cleared.
func (m *SpendingCategoryMutation) InterestedUsersCleared() bool {
	return m.clearedinterested_users
}

// RemoveInterestedUserIDs removes the "interested_users" edge to the User entity by IDs.
func (m *SpendingCategoryMutation) RemoveInterestedUserIDs(ids ...int) {
	if m.removedinterested_users == nil {
		m.removedinterested_users = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.interested_users, ids[i])
		m.removedinterested_users[ids[i]] = struct{}{}
	}
}

// RemovedInterestedUsers returns the removed IDs of the "interested_users" edge to the User entity.
func (m *SpendingCategoryMutation) RemovedInterestedUsersIDs() (ids []int) {
	for id := range m.removedinterested_users {
		ids = append(ids, id)
	}
	return
}

// InterestedUsersIDs returns the "interested_users" edge IDs in the mutation.
func (m *SpendingCategoryMutation) InterestedUsersIDs() (ids []int) {
	for id := range m.interested_users {
		ids = append(ids, id)
	}
	return
}

// ResetInterestedUsers resets all changes to the "interested_users" edge.
func (m *SpendingCategoryMutation) ResetInterestedUsers() {
	m.interested_users = nil
	m.clearedinterested_users = false
	m.removedinterested_users = nil
}

// Where appends a list predicates to the SpendingCategoryMutation builder.
func (m *SpendingCategoryMutation) Where(ps ...predicate.SpendingCategory) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the SpendingCategoryMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *SpendingCategoryMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.SpendingCategory, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *SpendingCategoryMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *SpendingCategoryMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (SpendingCategory).
func (m *SpendingCategoryMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *SpendingCategoryMutation) Fields() []string {
	fields := make([]string, 0, 3)
	if m.name != nil {
		fields = append(fields, spendingcategory.FieldName)
	}
	if m.category_id != nil {
		fields = append(fields, spendingcategory.FieldCategoryID)
	}
	if m.created_at != nil {
		fields = append(fields, spendingcategory.FieldCreatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *SpendingCategoryMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case spendingcategory.FieldName:
		return m.Name()
	case spendingcategory.FieldCategoryID:
		return m.CategoryID()
	case spendingcategory.FieldCreatedAt:
		return m.CreatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *SpendingCategoryMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case spendingcategory.FieldName:
		return m.OldName(ctx)
	case spendingcategory.FieldCategoryID:
		return m.OldCategoryID(ctx)
	case spendingcategory.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown SpendingCategory field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SpendingCategoryMutation) SetField(name string, value ent.Value) error {
	switch name {
	case spendingcategory.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case spendingcategory.FieldCategoryID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCategoryID(v)
		return nil
	case spendingcategory.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown SpendingCategory field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *SpendingCategoryMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *SpendingCategoryMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SpendingCategoryMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown SpendingCategory numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *SpendingCategoryMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *SpendingCategoryMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *SpendingCategoryMutation) ClearField(name string) error {
	return fmt.Errorf("unknown SpendingCategory nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *SpendingCategoryMutation) ResetField(name string) error {
	switch name {
	case spendingcategory.FieldName:
		m.ResetName()
		return nil
	case spendingcategory.FieldCategoryID:
		m.ResetCategoryID()
		return nil
	case spendingcategory.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	}
	return fmt.Errorf("unknown SpendingCategory field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *SpendingCategoryMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.category_transactions != nil {
		edges = append(edges, spendingcategory.EdgeCategoryTransactions)
	}
	if m.interested_users != nil {
		edges = append(edges, spendingcategory.EdgeInterestedUsers)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *SpendingCategoryMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case spendingcategory.EdgeCategoryTransactions:
		ids := make([]ent.Value, 0, len(m.category_transactions))
		for id := range m.category_transactions {
			ids = append(ids, id)
		}
		return ids
	case spendingcategory.EdgeInterestedUsers:
		ids := make([]ent.Value, 0, len(m.interested_users))
		for id := range m.interested_users {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *SpendingCategoryMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedcategory_transactions != nil {
		edges = append(edges, spendingcategory.EdgeCategoryTransactions)
	}
	if m.removedinterested_users != nil {
		edges = append(edges, spendingcategory.EdgeInterestedUsers)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *SpendingCategoryMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case spendingcategory.EdgeCategoryTransactions:
		ids := make([]ent.Value, 0, len(m.removedcategory_transactions))
		for id := range m.removedcategory_transactions {
			ids = append(ids, id)
		}
		return ids
	case spendingcategory.EdgeInterestedUsers:
		ids := make([]ent.Value, 0, len(m.removedinterested_users))
		for id := range m.removedinterested_users {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *SpendingCategoryMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedcategory_transactions {
		edges = append(edges, spendingcategory.EdgeCategoryTransactions)
	}
	if m.clearedinterested_users {
		edges = append(edges, spendingcategory.EdgeInterestedUsers)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *SpendingCategoryMutation) EdgeCleared(name string) bool {
	switch name {
	case spendingcategory.EdgeCategoryTransactions:
		return m.clearedcategory_transactions
	case spendingcategory.EdgeInterestedUsers:
		return m.clearedinterested_users
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *SpendingCategoryMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown SpendingCategory unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *SpendingCategoryMutation) ResetEdge(name string) error {
	switch name {
	case spendingcategory.EdgeCategoryTransactions:
		m.ResetCategoryTransactions()
		return nil
	case spendingcategory.EdgeInterestedUsers:
		m.ResetInterestedUsers()
		return nil
	}
	return fmt.Errorf("unknown SpendingCategory edge %s", name)
}

// TransactionMutation represents an operation that mutates the Transaction nodes in the graph.
type TransactionMutation struct {
	config
	op                            Op
	typ                           string
	id                            *int
	financial_account_id          *string
	amount                        *float64
	addamount                     *float64
	iso_currency_code             *string
	unofficial_currency_code      *string
	category                      *string
	category_id                   *string
	check_number                  *string
	date                          *string
	datetime                      *time.Time
	authorized_date               *string
	authorized_datetime           *time.Time
	location_address              *string
	location_city                 *string
	location_region               *string
	location_postal_code          *string
	location_lat                  *float64
	addlocation_lat               *float64
	location_lon                  *float64
	addlocation_lon               *float64
	location_store_number         *string
	name                          *string
	merchant_name                 *string
	payment_channel               *string
	pending                       *bool
	pending_transaction_id        *string
	account_owner                 *string
	transaction_id                *string
	transaction_code              *string
	created_at                    *time.Time
	clearedFields                 map[string]struct{}
	institution_account           *int
	clearedinstitution_account    bool
	transaction_categories        map[int]struct{}
	removedtransaction_categories map[int]struct{}
	clearedtransaction_categories bool
	done                          bool
	oldValue                      func(context.Context) (*Transaction, error)
	predicates                    []predicate.Transaction
}

var _ ent.Mutation = (*TransactionMutation)(nil)

// transactionOption allows management of the mutation configuration using functional options.
type transactionOption func(*TransactionMutation)

// newTransactionMutation creates new mutation for the Transaction entity.
func newTransactionMutation(c config, op Op, opts ...transactionOption) *TransactionMutation {
	m := &TransactionMutation{
		config:        c,
		op:            op,
		typ:           TypeTransaction,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withTransactionID sets the ID field of the mutation.
func withTransactionID(id int) transactionOption {
	return func(m *TransactionMutation) {
		var (
			err   error
			once  sync.Once
			value *Transaction
		)
		m.oldValue = func(ctx context.Context) (*Transaction, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Transaction.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withTransaction sets the old Transaction of the mutation.
func withTransaction(node *Transaction) transactionOption {
	return func(m *TransactionMutation) {
		m.oldValue = func(context.Context) (*Transaction, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m TransactionMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m TransactionMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *TransactionMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *TransactionMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Transaction.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetFinancialAccountID sets the "financial_account_id" field.
func (m *TransactionMutation) SetFinancialAccountID(s string) {
	m.financial_account_id = &s
}

// FinancialAccountID returns the value of the "financial_account_id" field in the mutation.
func (m *TransactionMutation) FinancialAccountID() (r string, exists bool) {
	v := m.financial_account_id
	if v == nil {
		return
	}
	return *v, true
}

// OldFinancialAccountID returns the old "financial_account_id" field's value of the Transaction entity.
// If the Transaction object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TransactionMutation) OldFinancialAccountID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFinancialAccountID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFinancialAccountID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFinancialAccountID: %w", err)
	}
	return oldValue.FinancialAccountID, nil
}

// ResetFinancialAccountID resets all changes to the "financial_account_id" field.
func (m *TransactionMutation) ResetFinancialAccountID() {
	m.financial_account_id = nil
}

// SetAmount sets the "amount" field.
func (m *TransactionMutation) SetAmount(f float64) {
	m.amount = &f
	m.addamount = nil
}

// Amount returns the value of the "amount" field in the mutation.
func (m *TransactionMutation) Amount() (r float64, exists bool) {
	v := m.amount
	if v == nil {
		return
	}
	return *v, true
}

// OldAmount returns the old "amount" field's value of the Transaction entity.
// If the Transaction object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TransactionMutation) OldAmount(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAmount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAmount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAmount: %w", err)
	}
	return oldValue.Amount, nil
}

// AddAmount adds f to the "amount" field.
func (m *TransactionMutation) AddAmount(f float64) {
	if m.addamount != nil {
		*m.addamount += f
	} else {
		m.addamount = &f
	}
}

// AddedAmount returns the value that was added to the "amount" field in this mutation.
func (m *TransactionMutation) AddedAmount() (r float64, exists bool) {
	v := m.addamount
	if v == nil {
		return
	}
	return *v, true
}

// ResetAmount resets all changes to the "amount" field.
func (m *TransactionMutation) ResetAmount() {
	m.amount = nil
	m.addamount = nil
}

// SetIsoCurrencyCode sets the "iso_currency_code" field.
func (m *TransactionMutation) SetIsoCurrencyCode(s string) {
	m.iso_currency_code = &s
}

// IsoCurrencyCode returns the value of the "iso_currency_code" field in the mutation.
func (m *TransactionMutation) IsoCurrencyCode() (r string, exists bool) {
	v := m.iso_currency_code
	if v == nil {
		return
	}
	return *v, true
}

// OldIsoCurrencyCode returns the old "iso_currency_code" field's value of the Transaction entity.
// If the Transaction object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TransactionMutation) OldIsoCurrencyCode(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsoCurrencyCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsoCurrencyCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsoCurrencyCode: %w", err)
	}
	return oldValue.IsoCurrencyCode, nil
}

// ResetIsoCurrencyCode resets all changes to the "iso_currency_code" field.
func (m *TransactionMutation) ResetIsoCurrencyCode() {
	m.iso_currency_code = nil
}

// SetUnofficialCurrencyCode sets the "unofficial_currency_code" field.
func (m *TransactionMutation) SetUnofficialCurrencyCode(s string) {
	m.unofficial_currency_code = &s
}

// UnofficialCurrencyCode returns the value of the "unofficial_currency_code" field in the mutation.
func (m *TransactionMutation) UnofficialCurrencyCode() (r string, exists bool) {
	v := m.unofficial_currency_code
	if v == nil {
		return
	}
	return *v, true
}

// OldUnofficialCurrencyCode returns the old "unofficial_currency_code" field's value of the Transaction entity.
// If the Transaction object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TransactionMutation) OldUnofficialCurrencyCode(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUnofficialCurrencyCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUnofficialCurrencyCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUnofficialCurrencyCode: %w", err)
	}
	return oldValue.UnofficialCurrencyCode, nil
}

// ResetUnofficialCurrencyCode resets all changes to the "unofficial_currency_code" field.
func (m *TransactionMutation) ResetUnofficialCurrencyCode() {
	m.unofficial_currency_code = nil
}

// SetCategory sets the "category" field.
func (m *TransactionMutation) SetCategory(s string) {
	m.category = &s
}

// Category returns the value of the "category" field in the mutation.
func (m *TransactionMutation) Category() (r string, exists bool) {
	v := m.category
	if v == nil {
		return
	}
	return *v, true
}

// OldCategory returns the old "category" field's value of the Transaction entity.
// If the Transaction object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TransactionMutation) OldCategory(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCategory is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCategory requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCategory: %w", err)
	}
	return oldValue.Category, nil
}

// ClearCategory clears the value of the "category" field.
func (m *TransactionMutation) ClearCategory() {
	m.category = nil
	m.clearedFields[transaction.FieldCategory] = struct{}{}
}

// CategoryCleared returns if the "category" field was cleared in this mutation.
func (m *TransactionMutation) CategoryCleared() bool {
	_, ok := m.clearedFields[transaction.FieldCategory]
	return ok
}

// ResetCategory resets all changes to the "category" field.
func (m *TransactionMutation) ResetCategory() {
	m.category = nil
	delete(m.clearedFields, transaction.FieldCategory)
}

// SetCategoryID sets the "category_id" field.
func (m *TransactionMutation) SetCategoryID(s string) {
	m.category_id = &s
}

// CategoryID returns the value of the "category_id" field in the mutation.
func (m *TransactionMutation) CategoryID() (r string, exists bool) {
	v := m.category_id
	if v == nil {
		return
	}
	return *v, true
}

// OldCategoryID returns the old "category_id" field's value of the Transaction entity.
// If the Transaction object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TransactionMutation) OldCategoryID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCategoryID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCategoryID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCategoryID: %w", err)
	}
	return oldValue.CategoryID, nil
}

// ClearCategoryID clears the value of the "category_id" field.
func (m *TransactionMutation) ClearCategoryID() {
	m.category_id = nil
	m.clearedFields[transaction.FieldCategoryID] = struct{}{}
}

// CategoryIDCleared returns if the "category_id" field was cleared in this mutation.
func (m *TransactionMutation) CategoryIDCleared() bool {
	_, ok := m.clearedFields[transaction.FieldCategoryID]
	return ok
}

// ResetCategoryID resets all changes to the "category_id" field.
func (m *TransactionMutation) ResetCategoryID() {
	m.category_id = nil
	delete(m.clearedFields, transaction.FieldCategoryID)
}

// SetCheckNumber sets the "check_number" field.
func (m *TransactionMutation) SetCheckNumber(s string) {
	m.check_number = &s
}

// CheckNumber returns the value of the "check_number" field in the mutation.
func (m *TransactionMutation) CheckNumber() (r string, exists bool) {
	v := m.check_number
	if v == nil {
		return
	}
	return *v, true
}

// OldCheckNumber returns the old "check_number" field's value of the Transaction entity.
// If the Transaction object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TransactionMutation) OldCheckNumber(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCheckNumber is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCheckNumber requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCheckNumber: %w", err)
	}
	return oldValue.CheckNumber, nil
}

// ResetCheckNumber resets all changes to the "check_number" field.
func (m *TransactionMutation) ResetCheckNumber() {
	m.check_number = nil
}

// SetDate sets the "date" field.
func (m *TransactionMutation) SetDate(s string) {
	m.date = &s
}

// Date returns the value of the "date" field in the mutation.
func (m *TransactionMutation) Date() (r string, exists bool) {
	v := m.date
	if v == nil {
		return
	}
	return *v, true
}

// OldDate returns the old "date" field's value of the Transaction entity.
// If the Transaction object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TransactionMutation) OldDate(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDate: %w", err)
	}
	return oldValue.Date, nil
}

// ResetDate resets all changes to the "date" field.
func (m *TransactionMutation) ResetDate() {
	m.date = nil
}

// SetDatetime sets the "datetime" field.
func (m *TransactionMutation) SetDatetime(t time.Time) {
	m.datetime = &t
}

// Datetime returns the value of the "datetime" field in the mutation.
func (m *TransactionMutation) Datetime() (r time.Time, exists bool) {
	v := m.datetime
	if v == nil {
		return
	}
	return *v, true
}

// OldDatetime returns the old "datetime" field's value of the Transaction entity.
// If the Transaction object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TransactionMutation) OldDatetime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDatetime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDatetime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDatetime: %w", err)
	}
	return oldValue.Datetime, nil
}

// ClearDatetime clears the value of the "datetime" field.
func (m *TransactionMutation) ClearDatetime() {
	m.datetime = nil
	m.clearedFields[transaction.FieldDatetime] = struct{}{}
}

// DatetimeCleared returns if the "datetime" field was cleared in this mutation.
func (m *TransactionMutation) DatetimeCleared() bool {
	_, ok := m.clearedFields[transaction.FieldDatetime]
	return ok
}

// ResetDatetime resets all changes to the "datetime" field.
func (m *TransactionMutation) ResetDatetime() {
	m.datetime = nil
	delete(m.clearedFields, transaction.FieldDatetime)
}

// SetAuthorizedDate sets the "authorized_date" field.
func (m *TransactionMutation) SetAuthorizedDate(s string) {
	m.authorized_date = &s
}

// AuthorizedDate returns the value of the "authorized_date" field in the mutation.
func (m *TransactionMutation) AuthorizedDate() (r string, exists bool) {
	v := m.authorized_date
	if v == nil {
		return
	}
	return *v, true
}

// OldAuthorizedDate returns the old "authorized_date" field's value of the Transaction entity.
// If the Transaction object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TransactionMutation) OldAuthorizedDate(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAuthorizedDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAuthorizedDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAuthorizedDate: %w", err)
	}
	return oldValue.AuthorizedDate, nil
}

// ClearAuthorizedDate clears the value of the "authorized_date" field.
func (m *TransactionMutation) ClearAuthorizedDate() {
	m.authorized_date = nil
	m.clearedFields[transaction.FieldAuthorizedDate] = struct{}{}
}

// AuthorizedDateCleared returns if the "authorized_date" field was cleared in this mutation.
func (m *TransactionMutation) AuthorizedDateCleared() bool {
	_, ok := m.clearedFields[transaction.FieldAuthorizedDate]
	return ok
}

// ResetAuthorizedDate resets all changes to the "authorized_date" field.
func (m *TransactionMutation) ResetAuthorizedDate() {
	m.authorized_date = nil
	delete(m.clearedFields, transaction.FieldAuthorizedDate)
}

// SetAuthorizedDatetime sets the "authorized_datetime" field.
func (m *TransactionMutation) SetAuthorizedDatetime(t time.Time) {
	m.authorized_datetime = &t
}

// AuthorizedDatetime returns the value of the "authorized_datetime" field in the mutation.
func (m *TransactionMutation) AuthorizedDatetime() (r time.Time, exists bool) {
	v := m.authorized_datetime
	if v == nil {
		return
	}
	return *v, true
}

// OldAuthorizedDatetime returns the old "authorized_datetime" field's value of the Transaction entity.
// If the Transaction object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TransactionMutation) OldAuthorizedDatetime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAuthorizedDatetime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAuthorizedDatetime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAuthorizedDatetime: %w", err)
	}
	return oldValue.AuthorizedDatetime, nil
}

// ClearAuthorizedDatetime clears the value of the "authorized_datetime" field.
func (m *TransactionMutation) ClearAuthorizedDatetime() {
	m.authorized_datetime = nil
	m.clearedFields[transaction.FieldAuthorizedDatetime] = struct{}{}
}

// AuthorizedDatetimeCleared returns if the "authorized_datetime" field was cleared in this mutation.
func (m *TransactionMutation) AuthorizedDatetimeCleared() bool {
	_, ok := m.clearedFields[transaction.FieldAuthorizedDatetime]
	return ok
}

// ResetAuthorizedDatetime resets all changes to the "authorized_datetime" field.
func (m *TransactionMutation) ResetAuthorizedDatetime() {
	m.authorized_datetime = nil
	delete(m.clearedFields, transaction.FieldAuthorizedDatetime)
}

// SetLocationAddress sets the "location_address" field.
func (m *TransactionMutation) SetLocationAddress(s string) {
	m.location_address = &s
}

// LocationAddress returns the value of the "location_address" field in the mutation.
func (m *TransactionMutation) LocationAddress() (r string, exists bool) {
	v := m.location_address
	if v == nil {
		return
	}
	return *v, true
}

// OldLocationAddress returns the old "location_address" field's value of the Transaction entity.
// If the Transaction object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TransactionMutation) OldLocationAddress(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLocationAddress is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLocationAddress requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLocationAddress: %w", err)
	}
	return oldValue.LocationAddress, nil
}

// ResetLocationAddress resets all changes to the "location_address" field.
func (m *TransactionMutation) ResetLocationAddress() {
	m.location_address = nil
}

// SetLocationCity sets the "location_city" field.
func (m *TransactionMutation) SetLocationCity(s string) {
	m.location_city = &s
}

// LocationCity returns the value of the "location_city" field in the mutation.
func (m *TransactionMutation) LocationCity() (r string, exists bool) {
	v := m.location_city
	if v == nil {
		return
	}
	return *v, true
}

// OldLocationCity returns the old "location_city" field's value of the Transaction entity.
// If the Transaction object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TransactionMutation) OldLocationCity(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLocationCity is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLocationCity requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLocationCity: %w", err)
	}
	return oldValue.LocationCity, nil
}

// ResetLocationCity resets all changes to the "location_city" field.
func (m *TransactionMutation) ResetLocationCity() {
	m.location_city = nil
}

// SetLocationRegion sets the "location_region" field.
func (m *TransactionMutation) SetLocationRegion(s string) {
	m.location_region = &s
}

// LocationRegion returns the value of the "location_region" field in the mutation.
func (m *TransactionMutation) LocationRegion() (r string, exists bool) {
	v := m.location_region
	if v == nil {
		return
	}
	return *v, true
}

// OldLocationRegion returns the old "location_region" field's value of the Transaction entity.
// If the Transaction object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TransactionMutation) OldLocationRegion(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLocationRegion is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLocationRegion requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLocationRegion: %w", err)
	}
	return oldValue.LocationRegion, nil
}

// ResetLocationRegion resets all changes to the "location_region" field.
func (m *TransactionMutation) ResetLocationRegion() {
	m.location_region = nil
}

// SetLocationPostalCode sets the "location_postal_code" field.
func (m *TransactionMutation) SetLocationPostalCode(s string) {
	m.location_postal_code = &s
}

// LocationPostalCode returns the value of the "location_postal_code" field in the mutation.
func (m *TransactionMutation) LocationPostalCode() (r string, exists bool) {
	v := m.location_postal_code
	if v == nil {
		return
	}
	return *v, true
}

// OldLocationPostalCode returns the old "location_postal_code" field's value of the Transaction entity.
// If the Transaction object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TransactionMutation) OldLocationPostalCode(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLocationPostalCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLocationPostalCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLocationPostalCode: %w", err)
	}
	return oldValue.LocationPostalCode, nil
}

// ResetLocationPostalCode resets all changes to the "location_postal_code" field.
func (m *TransactionMutation) ResetLocationPostalCode() {
	m.location_postal_code = nil
}

// SetLocationLat sets the "location_lat" field.
func (m *TransactionMutation) SetLocationLat(f float64) {
	m.location_lat = &f
	m.addlocation_lat = nil
}

// LocationLat returns the value of the "location_lat" field in the mutation.
func (m *TransactionMutation) LocationLat() (r float64, exists bool) {
	v := m.location_lat
	if v == nil {
		return
	}
	return *v, true
}

// OldLocationLat returns the old "location_lat" field's value of the Transaction entity.
// If the Transaction object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TransactionMutation) OldLocationLat(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLocationLat is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLocationLat requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLocationLat: %w", err)
	}
	return oldValue.LocationLat, nil
}

// AddLocationLat adds f to the "location_lat" field.
func (m *TransactionMutation) AddLocationLat(f float64) {
	if m.addlocation_lat != nil {
		*m.addlocation_lat += f
	} else {
		m.addlocation_lat = &f
	}
}

// AddedLocationLat returns the value that was added to the "location_lat" field in this mutation.
func (m *TransactionMutation) AddedLocationLat() (r float64, exists bool) {
	v := m.addlocation_lat
	if v == nil {
		return
	}
	return *v, true
}

// ResetLocationLat resets all changes to the "location_lat" field.
func (m *TransactionMutation) ResetLocationLat() {
	m.location_lat = nil
	m.addlocation_lat = nil
}

// SetLocationLon sets the "location_lon" field.
func (m *TransactionMutation) SetLocationLon(f float64) {
	m.location_lon = &f
	m.addlocation_lon = nil
}

// LocationLon returns the value of the "location_lon" field in the mutation.
func (m *TransactionMutation) LocationLon() (r float64, exists bool) {
	v := m.location_lon
	if v == nil {
		return
	}
	return *v, true
}

// OldLocationLon returns the old "location_lon" field's value of the Transaction entity.
// If the Transaction object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TransactionMutation) OldLocationLon(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLocationLon is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLocationLon requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLocationLon: %w", err)
	}
	return oldValue.LocationLon, nil
}

// AddLocationLon adds f to the "location_lon" field.
func (m *TransactionMutation) AddLocationLon(f float64) {
	if m.addlocation_lon != nil {
		*m.addlocation_lon += f
	} else {
		m.addlocation_lon = &f
	}
}

// AddedLocationLon returns the value that was added to the "location_lon" field in this mutation.
func (m *TransactionMutation) AddedLocationLon() (r float64, exists bool) {
	v := m.addlocation_lon
	if v == nil {
		return
	}
	return *v, true
}

// ResetLocationLon resets all changes to the "location_lon" field.
func (m *TransactionMutation) ResetLocationLon() {
	m.location_lon = nil
	m.addlocation_lon = nil
}

// SetLocationStoreNumber sets the "location_store_number" field.
func (m *TransactionMutation) SetLocationStoreNumber(s string) {
	m.location_store_number = &s
}

// LocationStoreNumber returns the value of the "location_store_number" field in the mutation.
func (m *TransactionMutation) LocationStoreNumber() (r string, exists bool) {
	v := m.location_store_number
	if v == nil {
		return
	}
	return *v, true
}

// OldLocationStoreNumber returns the old "location_store_number" field's value of the Transaction entity.
// If the Transaction object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TransactionMutation) OldLocationStoreNumber(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLocationStoreNumber is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLocationStoreNumber requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLocationStoreNumber: %w", err)
	}
	return oldValue.LocationStoreNumber, nil
}

// ResetLocationStoreNumber resets all changes to the "location_store_number" field.
func (m *TransactionMutation) ResetLocationStoreNumber() {
	m.location_store_number = nil
}

// SetName sets the "name" field.
func (m *TransactionMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *TransactionMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Transaction entity.
// If the Transaction object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TransactionMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *TransactionMutation) ResetName() {
	m.name = nil
}

// SetMerchantName sets the "merchant_name" field.
func (m *TransactionMutation) SetMerchantName(s string) {
	m.merchant_name = &s
}

// MerchantName returns the value of the "merchant_name" field in the mutation.
func (m *TransactionMutation) MerchantName() (r string, exists bool) {
	v := m.merchant_name
	if v == nil {
		return
	}
	return *v, true
}

// OldMerchantName returns the old "merchant_name" field's value of the Transaction entity.
// If the Transaction object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TransactionMutation) OldMerchantName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMerchantName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMerchantName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMerchantName: %w", err)
	}
	return oldValue.MerchantName, nil
}

// ResetMerchantName resets all changes to the "merchant_name" field.
func (m *TransactionMutation) ResetMerchantName() {
	m.merchant_name = nil
}

// SetPaymentChannel sets the "payment_channel" field.
func (m *TransactionMutation) SetPaymentChannel(s string) {
	m.payment_channel = &s
}

// PaymentChannel returns the value of the "payment_channel" field in the mutation.
func (m *TransactionMutation) PaymentChannel() (r string, exists bool) {
	v := m.payment_channel
	if v == nil {
		return
	}
	return *v, true
}

// OldPaymentChannel returns the old "payment_channel" field's value of the Transaction entity.
// If the Transaction object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TransactionMutation) OldPaymentChannel(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPaymentChannel is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPaymentChannel requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPaymentChannel: %w", err)
	}
	return oldValue.PaymentChannel, nil
}

// ResetPaymentChannel resets all changes to the "payment_channel" field.
func (m *TransactionMutation) ResetPaymentChannel() {
	m.payment_channel = nil
}

// SetPending sets the "pending" field.
func (m *TransactionMutation) SetPending(b bool) {
	m.pending = &b
}

// Pending returns the value of the "pending" field in the mutation.
func (m *TransactionMutation) Pending() (r bool, exists bool) {
	v := m.pending
	if v == nil {
		return
	}
	return *v, true
}

// OldPending returns the old "pending" field's value of the Transaction entity.
// If the Transaction object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TransactionMutation) OldPending(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPending is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPending requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPending: %w", err)
	}
	return oldValue.Pending, nil
}

// ResetPending resets all changes to the "pending" field.
func (m *TransactionMutation) ResetPending() {
	m.pending = nil
}

// SetPendingTransactionID sets the "pending_transaction_id" field.
func (m *TransactionMutation) SetPendingTransactionID(s string) {
	m.pending_transaction_id = &s
}

// PendingTransactionID returns the value of the "pending_transaction_id" field in the mutation.
func (m *TransactionMutation) PendingTransactionID() (r string, exists bool) {
	v := m.pending_transaction_id
	if v == nil {
		return
	}
	return *v, true
}

// OldPendingTransactionID returns the old "pending_transaction_id" field's value of the Transaction entity.
// If the Transaction object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TransactionMutation) OldPendingTransactionID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPendingTransactionID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPendingTransactionID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPendingTransactionID: %w", err)
	}
	return oldValue.PendingTransactionID, nil
}

// ResetPendingTransactionID resets all changes to the "pending_transaction_id" field.
func (m *TransactionMutation) ResetPendingTransactionID() {
	m.pending_transaction_id = nil
}

// SetAccountOwner sets the "account_owner" field.
func (m *TransactionMutation) SetAccountOwner(s string) {
	m.account_owner = &s
}

// AccountOwner returns the value of the "account_owner" field in the mutation.
func (m *TransactionMutation) AccountOwner() (r string, exists bool) {
	v := m.account_owner
	if v == nil {
		return
	}
	return *v, true
}

// OldAccountOwner returns the old "account_owner" field's value of the Transaction entity.
// If the Transaction object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TransactionMutation) OldAccountOwner(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAccountOwner is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAccountOwner requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAccountOwner: %w", err)
	}
	return oldValue.AccountOwner, nil
}

// ResetAccountOwner resets all changes to the "account_owner" field.
func (m *TransactionMutation) ResetAccountOwner() {
	m.account_owner = nil
}

// SetTransactionID sets the "transaction_id" field.
func (m *TransactionMutation) SetTransactionID(s string) {
	m.transaction_id = &s
}

// TransactionID returns the value of the "transaction_id" field in the mutation.
func (m *TransactionMutation) TransactionID() (r string, exists bool) {
	v := m.transaction_id
	if v == nil {
		return
	}
	return *v, true
}

// OldTransactionID returns the old "transaction_id" field's value of the Transaction entity.
// If the Transaction object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TransactionMutation) OldTransactionID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTransactionID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTransactionID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTransactionID: %w", err)
	}
	return oldValue.TransactionID, nil
}

// ResetTransactionID resets all changes to the "transaction_id" field.
func (m *TransactionMutation) ResetTransactionID() {
	m.transaction_id = nil
}

// SetTransactionCode sets the "transaction_code" field.
func (m *TransactionMutation) SetTransactionCode(s string) {
	m.transaction_code = &s
}

// TransactionCode returns the value of the "transaction_code" field in the mutation.
func (m *TransactionMutation) TransactionCode() (r string, exists bool) {
	v := m.transaction_code
	if v == nil {
		return
	}
	return *v, true
}

// OldTransactionCode returns the old "transaction_code" field's value of the Transaction entity.
// If the Transaction object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TransactionMutation) OldTransactionCode(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTransactionCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTransactionCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTransactionCode: %w", err)
	}
	return oldValue.TransactionCode, nil
}

// ResetTransactionCode resets all changes to the "transaction_code" field.
func (m *TransactionMutation) ResetTransactionCode() {
	m.transaction_code = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *TransactionMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *TransactionMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Transaction entity.
// If the Transaction object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TransactionMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *TransactionMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetInstitutionAccountID sets the "institution_account" edge to the PlaidInstitutionAccount entity by id.
func (m *TransactionMutation) SetInstitutionAccountID(id int) {
	m.institution_account = &id
}

// ClearInstitutionAccount clears the "institution_account" edge to the PlaidInstitutionAccount entity.
func (m *TransactionMutation) ClearInstitutionAccount() {
	m.clearedinstitution_account = true
}

// InstitutionAccountCleared reports if the "institution_account" edge to the PlaidInstitutionAccount entity was cleared.
func (m *TransactionMutation) InstitutionAccountCleared() bool {
	return m.clearedinstitution_account
}

// InstitutionAccountID returns the "institution_account" edge ID in the mutation.
func (m *TransactionMutation) InstitutionAccountID() (id int, exists bool) {
	if m.institution_account != nil {
		return *m.institution_account, true
	}
	return
}

// InstitutionAccountIDs returns the "institution_account" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// InstitutionAccountID instead. It exists only for internal usage by the builders.
func (m *TransactionMutation) InstitutionAccountIDs() (ids []int) {
	if id := m.institution_account; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetInstitutionAccount resets all changes to the "institution_account" edge.
func (m *TransactionMutation) ResetInstitutionAccount() {
	m.institution_account = nil
	m.clearedinstitution_account = false
}

// AddTransactionCategoryIDs adds the "transaction_categories" edge to the SpendingCategory entity by ids.
func (m *TransactionMutation) AddTransactionCategoryIDs(ids ...int) {
	if m.transaction_categories == nil {
		m.transaction_categories = make(map[int]struct{})
	}
	for i := range ids {
		m.transaction_categories[ids[i]] = struct{}{}
	}
}

// ClearTransactionCategories clears the "transaction_categories" edge to the SpendingCategory entity.
func (m *TransactionMutation) ClearTransactionCategories() {
	m.clearedtransaction_categories = true
}

// TransactionCategoriesCleared reports if the "transaction_categories" edge to the SpendingCategory entity was cleared.
func (m *TransactionMutation) TransactionCategoriesCleared() bool {
	return m.clearedtransaction_categories
}

// RemoveTransactionCategoryIDs removes the "transaction_categories" edge to the SpendingCategory entity by IDs.
func (m *TransactionMutation) RemoveTransactionCategoryIDs(ids ...int) {
	if m.removedtransaction_categories == nil {
		m.removedtransaction_categories = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.transaction_categories, ids[i])
		m.removedtransaction_categories[ids[i]] = struct{}{}
	}
}

// RemovedTransactionCategories returns the removed IDs of the "transaction_categories" edge to the SpendingCategory entity.
func (m *TransactionMutation) RemovedTransactionCategoriesIDs() (ids []int) {
	for id := range m.removedtransaction_categories {
		ids = append(ids, id)
	}
	return
}

// TransactionCategoriesIDs returns the "transaction_categories" edge IDs in the mutation.
func (m *TransactionMutation) TransactionCategoriesIDs() (ids []int) {
	for id := range m.transaction_categories {
		ids = append(ids, id)
	}
	return
}

// ResetTransactionCategories resets all changes to the "transaction_categories" edge.
func (m *TransactionMutation) ResetTransactionCategories() {
	m.transaction_categories = nil
	m.clearedtransaction_categories = false
	m.removedtransaction_categories = nil
}

// Where appends a list predicates to the TransactionMutation builder.
func (m *TransactionMutation) Where(ps ...predicate.Transaction) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the TransactionMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *TransactionMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Transaction, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *TransactionMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *TransactionMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Transaction).
func (m *TransactionMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *TransactionMutation) Fields() []string {
	fields := make([]string, 0, 27)
	if m.financial_account_id != nil {
		fields = append(fields, transaction.FieldFinancialAccountID)
	}
	if m.amount != nil {
		fields = append(fields, transaction.FieldAmount)
	}
	if m.iso_currency_code != nil {
		fields = append(fields, transaction.FieldIsoCurrencyCode)
	}
	if m.unofficial_currency_code != nil {
		fields = append(fields, transaction.FieldUnofficialCurrencyCode)
	}
	if m.category != nil {
		fields = append(fields, transaction.FieldCategory)
	}
	if m.category_id != nil {
		fields = append(fields, transaction.FieldCategoryID)
	}
	if m.check_number != nil {
		fields = append(fields, transaction.FieldCheckNumber)
	}
	if m.date != nil {
		fields = append(fields, transaction.FieldDate)
	}
	if m.datetime != nil {
		fields = append(fields, transaction.FieldDatetime)
	}
	if m.authorized_date != nil {
		fields = append(fields, transaction.FieldAuthorizedDate)
	}
	if m.authorized_datetime != nil {
		fields = append(fields, transaction.FieldAuthorizedDatetime)
	}
	if m.location_address != nil {
		fields = append(fields, transaction.FieldLocationAddress)
	}
	if m.location_city != nil {
		fields = append(fields, transaction.FieldLocationCity)
	}
	if m.location_region != nil {
		fields = append(fields, transaction.FieldLocationRegion)
	}
	if m.location_postal_code != nil {
		fields = append(fields, transaction.FieldLocationPostalCode)
	}
	if m.location_lat != nil {
		fields = append(fields, transaction.FieldLocationLat)
	}
	if m.location_lon != nil {
		fields = append(fields, transaction.FieldLocationLon)
	}
	if m.location_store_number != nil {
		fields = append(fields, transaction.FieldLocationStoreNumber)
	}
	if m.name != nil {
		fields = append(fields, transaction.FieldName)
	}
	if m.merchant_name != nil {
		fields = append(fields, transaction.FieldMerchantName)
	}
	if m.payment_channel != nil {
		fields = append(fields, transaction.FieldPaymentChannel)
	}
	if m.pending != nil {
		fields = append(fields, transaction.FieldPending)
	}
	if m.pending_transaction_id != nil {
		fields = append(fields, transaction.FieldPendingTransactionID)
	}
	if m.account_owner != nil {
		fields = append(fields, transaction.FieldAccountOwner)
	}
	if m.transaction_id != nil {
		fields = append(fields, transaction.FieldTransactionID)
	}
	if m.transaction_code != nil {
		fields = append(fields, transaction.FieldTransactionCode)
	}
	if m.created_at != nil {
		fields = append(fields, transaction.FieldCreatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *TransactionMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case transaction.FieldFinancialAccountID:
		return m.FinancialAccountID()
	case transaction.FieldAmount:
		return m.Amount()
	case transaction.FieldIsoCurrencyCode:
		return m.IsoCurrencyCode()
	case transaction.FieldUnofficialCurrencyCode:
		return m.UnofficialCurrencyCode()
	case transaction.FieldCategory:
		return m.Category()
	case transaction.FieldCategoryID:
		return m.CategoryID()
	case transaction.FieldCheckNumber:
		return m.CheckNumber()
	case transaction.FieldDate:
		return m.Date()
	case transaction.FieldDatetime:
		return m.Datetime()
	case transaction.FieldAuthorizedDate:
		return m.AuthorizedDate()
	case transaction.FieldAuthorizedDatetime:
		return m.AuthorizedDatetime()
	case transaction.FieldLocationAddress:
		return m.LocationAddress()
	case transaction.FieldLocationCity:
		return m.LocationCity()
	case transaction.FieldLocationRegion:
		return m.LocationRegion()
	case transaction.FieldLocationPostalCode:
		return m.LocationPostalCode()
	case transaction.FieldLocationLat:
		return m.LocationLat()
	case transaction.FieldLocationLon:
		return m.LocationLon()
	case transaction.FieldLocationStoreNumber:
		return m.LocationStoreNumber()
	case transaction.FieldName:
		return m.Name()
	case transaction.FieldMerchantName:
		return m.MerchantName()
	case transaction.FieldPaymentChannel:
		return m.PaymentChannel()
	case transaction.FieldPending:
		return m.Pending()
	case transaction.FieldPendingTransactionID:
		return m.PendingTransactionID()
	case transaction.FieldAccountOwner:
		return m.AccountOwner()
	case transaction.FieldTransactionID:
		return m.TransactionID()
	case transaction.FieldTransactionCode:
		return m.TransactionCode()
	case transaction.FieldCreatedAt:
		return m.CreatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *TransactionMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case transaction.FieldFinancialAccountID:
		return m.OldFinancialAccountID(ctx)
	case transaction.FieldAmount:
		return m.OldAmount(ctx)
	case transaction.FieldIsoCurrencyCode:
		return m.OldIsoCurrencyCode(ctx)
	case transaction.FieldUnofficialCurrencyCode:
		return m.OldUnofficialCurrencyCode(ctx)
	case transaction.FieldCategory:
		return m.OldCategory(ctx)
	case transaction.FieldCategoryID:
		return m.OldCategoryID(ctx)
	case transaction.FieldCheckNumber:
		return m.OldCheckNumber(ctx)
	case transaction.FieldDate:
		return m.OldDate(ctx)
	case transaction.FieldDatetime:
		return m.OldDatetime(ctx)
	case transaction.FieldAuthorizedDate:
		return m.OldAuthorizedDate(ctx)
	case transaction.FieldAuthorizedDatetime:
		return m.OldAuthorizedDatetime(ctx)
	case transaction.FieldLocationAddress:
		return m.OldLocationAddress(ctx)
	case transaction.FieldLocationCity:
		return m.OldLocationCity(ctx)
	case transaction.FieldLocationRegion:
		return m.OldLocationRegion(ctx)
	case transaction.FieldLocationPostalCode:
		return m.OldLocationPostalCode(ctx)
	case transaction.FieldLocationLat:
		return m.OldLocationLat(ctx)
	case transaction.FieldLocationLon:
		return m.OldLocationLon(ctx)
	case transaction.FieldLocationStoreNumber:
		return m.OldLocationStoreNumber(ctx)
	case transaction.FieldName:
		return m.OldName(ctx)
	case transaction.FieldMerchantName:
		return m.OldMerchantName(ctx)
	case transaction.FieldPaymentChannel:
		return m.OldPaymentChannel(ctx)
	case transaction.FieldPending:
		return m.OldPending(ctx)
	case transaction.FieldPendingTransactionID:
		return m.OldPendingTransactionID(ctx)
	case transaction.FieldAccountOwner:
		return m.OldAccountOwner(ctx)
	case transaction.FieldTransactionID:
		return m.OldTransactionID(ctx)
	case transaction.FieldTransactionCode:
		return m.OldTransactionCode(ctx)
	case transaction.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown Transaction field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TransactionMutation) SetField(name string, value ent.Value) error {
	switch name {
	case transaction.FieldFinancialAccountID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFinancialAccountID(v)
		return nil
	case transaction.FieldAmount:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAmount(v)
		return nil
	case transaction.FieldIsoCurrencyCode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsoCurrencyCode(v)
		return nil
	case transaction.FieldUnofficialCurrencyCode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUnofficialCurrencyCode(v)
		return nil
	case transaction.FieldCategory:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCategory(v)
		return nil
	case transaction.FieldCategoryID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCategoryID(v)
		return nil
	case transaction.FieldCheckNumber:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCheckNumber(v)
		return nil
	case transaction.FieldDate:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDate(v)
		return nil
	case transaction.FieldDatetime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDatetime(v)
		return nil
	case transaction.FieldAuthorizedDate:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAuthorizedDate(v)
		return nil
	case transaction.FieldAuthorizedDatetime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAuthorizedDatetime(v)
		return nil
	case transaction.FieldLocationAddress:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLocationAddress(v)
		return nil
	case transaction.FieldLocationCity:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLocationCity(v)
		return nil
	case transaction.FieldLocationRegion:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLocationRegion(v)
		return nil
	case transaction.FieldLocationPostalCode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLocationPostalCode(v)
		return nil
	case transaction.FieldLocationLat:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLocationLat(v)
		return nil
	case transaction.FieldLocationLon:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLocationLon(v)
		return nil
	case transaction.FieldLocationStoreNumber:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLocationStoreNumber(v)
		return nil
	case transaction.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case transaction.FieldMerchantName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMerchantName(v)
		return nil
	case transaction.FieldPaymentChannel:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPaymentChannel(v)
		return nil
	case transaction.FieldPending:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPending(v)
		return nil
	case transaction.FieldPendingTransactionID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPendingTransactionID(v)
		return nil
	case transaction.FieldAccountOwner:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAccountOwner(v)
		return nil
	case transaction.FieldTransactionID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTransactionID(v)
		return nil
	case transaction.FieldTransactionCode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTransactionCode(v)
		return nil
	case transaction.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown Transaction field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *TransactionMutation) AddedFields() []string {
	var fields []string
	if m.addamount != nil {
		fields = append(fields, transaction.FieldAmount)
	}
	if m.addlocation_lat != nil {
		fields = append(fields, transaction.FieldLocationLat)
	}
	if m.addlocation_lon != nil {
		fields = append(fields, transaction.FieldLocationLon)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *TransactionMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case transaction.FieldAmount:
		return m.AddedAmount()
	case transaction.FieldLocationLat:
		return m.AddedLocationLat()
	case transaction.FieldLocationLon:
		return m.AddedLocationLon()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TransactionMutation) AddField(name string, value ent.Value) error {
	switch name {
	case transaction.FieldAmount:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddAmount(v)
		return nil
	case transaction.FieldLocationLat:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddLocationLat(v)
		return nil
	case transaction.FieldLocationLon:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddLocationLon(v)
		return nil
	}
	return fmt.Errorf("unknown Transaction numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *TransactionMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(transaction.FieldCategory) {
		fields = append(fields, transaction.FieldCategory)
	}
	if m.FieldCleared(transaction.FieldCategoryID) {
		fields = append(fields, transaction.FieldCategoryID)
	}
	if m.FieldCleared(transaction.FieldDatetime) {
		fields = append(fields, transaction.FieldDatetime)
	}
	if m.FieldCleared(transaction.FieldAuthorizedDate) {
		fields = append(fields, transaction.FieldAuthorizedDate)
	}
	if m.FieldCleared(transaction.FieldAuthorizedDatetime) {
		fields = append(fields, transaction.FieldAuthorizedDatetime)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *TransactionMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *TransactionMutation) ClearField(name string) error {
	switch name {
	case transaction.FieldCategory:
		m.ClearCategory()
		return nil
	case transaction.FieldCategoryID:
		m.ClearCategoryID()
		return nil
	case transaction.FieldDatetime:
		m.ClearDatetime()
		return nil
	case transaction.FieldAuthorizedDate:
		m.ClearAuthorizedDate()
		return nil
	case transaction.FieldAuthorizedDatetime:
		m.ClearAuthorizedDatetime()
		return nil
	}
	return fmt.Errorf("unknown Transaction nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *TransactionMutation) ResetField(name string) error {
	switch name {
	case transaction.FieldFinancialAccountID:
		m.ResetFinancialAccountID()
		return nil
	case transaction.FieldAmount:
		m.ResetAmount()
		return nil
	case transaction.FieldIsoCurrencyCode:
		m.ResetIsoCurrencyCode()
		return nil
	case transaction.FieldUnofficialCurrencyCode:
		m.ResetUnofficialCurrencyCode()
		return nil
	case transaction.FieldCategory:
		m.ResetCategory()
		return nil
	case transaction.FieldCategoryID:
		m.ResetCategoryID()
		return nil
	case transaction.FieldCheckNumber:
		m.ResetCheckNumber()
		return nil
	case transaction.FieldDate:
		m.ResetDate()
		return nil
	case transaction.FieldDatetime:
		m.ResetDatetime()
		return nil
	case transaction.FieldAuthorizedDate:
		m.ResetAuthorizedDate()
		return nil
	case transaction.FieldAuthorizedDatetime:
		m.ResetAuthorizedDatetime()
		return nil
	case transaction.FieldLocationAddress:
		m.ResetLocationAddress()
		return nil
	case transaction.FieldLocationCity:
		m.ResetLocationCity()
		return nil
	case transaction.FieldLocationRegion:
		m.ResetLocationRegion()
		return nil
	case transaction.FieldLocationPostalCode:
		m.ResetLocationPostalCode()
		return nil
	case transaction.FieldLocationLat:
		m.ResetLocationLat()
		return nil
	case transaction.FieldLocationLon:
		m.ResetLocationLon()
		return nil
	case transaction.FieldLocationStoreNumber:
		m.ResetLocationStoreNumber()
		return nil
	case transaction.FieldName:
		m.ResetName()
		return nil
	case transaction.FieldMerchantName:
		m.ResetMerchantName()
		return nil
	case transaction.FieldPaymentChannel:
		m.ResetPaymentChannel()
		return nil
	case transaction.FieldPending:
		m.ResetPending()
		return nil
	case transaction.FieldPendingTransactionID:
		m.ResetPendingTransactionID()
		return nil
	case transaction.FieldAccountOwner:
		m.ResetAccountOwner()
		return nil
	case transaction.FieldTransactionID:
		m.ResetTransactionID()
		return nil
	case transaction.FieldTransactionCode:
		m.ResetTransactionCode()
		return nil
	case transaction.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	}
	return fmt.Errorf("unknown Transaction field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *TransactionMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.institution_account != nil {
		edges = append(edges, transaction.EdgeInstitutionAccount)
	}
	if m.transaction_categories != nil {
		edges = append(edges, transaction.EdgeTransactionCategories)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *TransactionMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case transaction.EdgeInstitutionAccount:
		if id := m.institution_account; id != nil {
			return []ent.Value{*id}
		}
	case transaction.EdgeTransactionCategories:
		ids := make([]ent.Value, 0, len(m.transaction_categories))
		for id := range m.transaction_categories {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *TransactionMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedtransaction_categories != nil {
		edges = append(edges, transaction.EdgeTransactionCategories)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *TransactionMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case transaction.EdgeTransactionCategories:
		ids := make([]ent.Value, 0, len(m.removedtransaction_categories))
		for id := range m.removedtransaction_categories {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *TransactionMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedinstitution_account {
		edges = append(edges, transaction.EdgeInstitutionAccount)
	}
	if m.clearedtransaction_categories {
		edges = append(edges, transaction.EdgeTransactionCategories)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *TransactionMutation) EdgeCleared(name string) bool {
	switch name {
	case transaction.EdgeInstitutionAccount:
		return m.clearedinstitution_account
	case transaction.EdgeTransactionCategories:
		return m.clearedtransaction_categories
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *TransactionMutation) ClearEdge(name string) error {
	switch name {
	case transaction.EdgeInstitutionAccount:
		m.ClearInstitutionAccount()
		return nil
	}
	return fmt.Errorf("unknown Transaction unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *TransactionMutation) ResetEdge(name string) error {
	switch name {
	case transaction.EdgeInstitutionAccount:
		m.ResetInstitutionAccount()
		return nil
	case transaction.EdgeTransactionCategories:
		m.ResetTransactionCategories()
		return nil
	}
	return fmt.Errorf("unknown Transaction edge %s", name)
}

// TransactionSyncMutation represents an operation that mutates the TransactionSync nodes in the graph.
type TransactionSyncMutation struct {
	config
	op            Op
	typ           string
	id            *int
	created_at    *time.Time
	cursor        *string
	clearedFields map[string]struct{}
	item          *int
	cleareditem   bool
	done          bool
	oldValue      func(context.Context) (*TransactionSync, error)
	predicates    []predicate.TransactionSync
}

var _ ent.Mutation = (*TransactionSyncMutation)(nil)

// transactionsyncOption allows management of the mutation configuration using functional options.
type transactionsyncOption func(*TransactionSyncMutation)

// newTransactionSyncMutation creates new mutation for the TransactionSync entity.
func newTransactionSyncMutation(c config, op Op, opts ...transactionsyncOption) *TransactionSyncMutation {
	m := &TransactionSyncMutation{
		config:        c,
		op:            op,
		typ:           TypeTransactionSync,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withTransactionSyncID sets the ID field of the mutation.
func withTransactionSyncID(id int) transactionsyncOption {
	return func(m *TransactionSyncMutation) {
		var (
			err   error
			once  sync.Once
			value *TransactionSync
		)
		m.oldValue = func(ctx context.Context) (*TransactionSync, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().TransactionSync.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withTransactionSync sets the old TransactionSync of the mutation.
func withTransactionSync(node *TransactionSync) transactionsyncOption {
	return func(m *TransactionSyncMutation) {
		m.oldValue = func(context.Context) (*TransactionSync, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m TransactionSyncMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m TransactionSyncMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *TransactionSyncMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *TransactionSyncMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().TransactionSync.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *TransactionSyncMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *TransactionSyncMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the TransactionSync entity.
// If the TransactionSync object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TransactionSyncMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *TransactionSyncMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetCursor sets the "cursor" field.
func (m *TransactionSyncMutation) SetCursor(s string) {
	m.cursor = &s
}

// Cursor returns the value of the "cursor" field in the mutation.
func (m *TransactionSyncMutation) Cursor() (r string, exists bool) {
	v := m.cursor
	if v == nil {
		return
	}
	return *v, true
}

// OldCursor returns the old "cursor" field's value of the TransactionSync entity.
// If the TransactionSync object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TransactionSyncMutation) OldCursor(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCursor is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCursor requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCursor: %w", err)
	}
	return oldValue.Cursor, nil
}

// ResetCursor resets all changes to the "cursor" field.
func (m *TransactionSyncMutation) ResetCursor() {
	m.cursor = nil
}

// SetItemID sets the "item" edge to the PlaidItem entity by id.
func (m *TransactionSyncMutation) SetItemID(id int) {
	m.item = &id
}

// ClearItem clears the "item" edge to the PlaidItem entity.
func (m *TransactionSyncMutation) ClearItem() {
	m.cleareditem = true
}

// ItemCleared reports if the "item" edge to the PlaidItem entity was cleared.
func (m *TransactionSyncMutation) ItemCleared() bool {
	return m.cleareditem
}

// ItemID returns the "item" edge ID in the mutation.
func (m *TransactionSyncMutation) ItemID() (id int, exists bool) {
	if m.item != nil {
		return *m.item, true
	}
	return
}

// ItemIDs returns the "item" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ItemID instead. It exists only for internal usage by the builders.
func (m *TransactionSyncMutation) ItemIDs() (ids []int) {
	if id := m.item; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetItem resets all changes to the "item" edge.
func (m *TransactionSyncMutation) ResetItem() {
	m.item = nil
	m.cleareditem = false
}

// Where appends a list predicates to the TransactionSyncMutation builder.
func (m *TransactionSyncMutation) Where(ps ...predicate.TransactionSync) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the TransactionSyncMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *TransactionSyncMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.TransactionSync, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *TransactionSyncMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *TransactionSyncMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (TransactionSync).
func (m *TransactionSyncMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *TransactionSyncMutation) Fields() []string {
	fields := make([]string, 0, 2)
	if m.created_at != nil {
		fields = append(fields, transactionsync.FieldCreatedAt)
	}
	if m.cursor != nil {
		fields = append(fields, transactionsync.FieldCursor)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *TransactionSyncMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case transactionsync.FieldCreatedAt:
		return m.CreatedAt()
	case transactionsync.FieldCursor:
		return m.Cursor()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *TransactionSyncMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case transactionsync.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case transactionsync.FieldCursor:
		return m.OldCursor(ctx)
	}
	return nil, fmt.Errorf("unknown TransactionSync field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TransactionSyncMutation) SetField(name string, value ent.Value) error {
	switch name {
	case transactionsync.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case transactionsync.FieldCursor:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCursor(v)
		return nil
	}
	return fmt.Errorf("unknown TransactionSync field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *TransactionSyncMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *TransactionSyncMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TransactionSyncMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown TransactionSync numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *TransactionSyncMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *TransactionSyncMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *TransactionSyncMutation) ClearField(name string) error {
	return fmt.Errorf("unknown TransactionSync nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *TransactionSyncMutation) ResetField(name string) error {
	switch name {
	case transactionsync.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case transactionsync.FieldCursor:
		m.ResetCursor()
		return nil
	}
	return fmt.Errorf("unknown TransactionSync field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *TransactionSyncMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.item != nil {
		edges = append(edges, transactionsync.EdgeItem)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *TransactionSyncMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case transactionsync.EdgeItem:
		if id := m.item; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *TransactionSyncMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *TransactionSyncMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *TransactionSyncMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.cleareditem {
		edges = append(edges, transactionsync.EdgeItem)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *TransactionSyncMutation) EdgeCleared(name string) bool {
	switch name {
	case transactionsync.EdgeItem:
		return m.cleareditem
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *TransactionSyncMutation) ClearEdge(name string) error {
	switch name {
	case transactionsync.EdgeItem:
		m.ClearItem()
		return nil
	}
	return fmt.Errorf("unknown TransactionSync unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *TransactionSyncMutation) ResetEdge(name string) error {
	switch name {
	case transactionsync.EdgeItem:
		m.ResetItem()
		return nil
	}
	return fmt.Errorf("unknown TransactionSync edge %s", name)
}

// UserMutation represents an operation that mutates the User nodes in the graph.
type UserMutation struct {
	config
	op                               Op
	typ                              string
	id                               *int
	identity_provider_id             *string
	offer_frequency                  *user.OfferFrequency
	home_country                     *string
	home_state                       *string
	home_city                        *string
	clearedFields                    map[string]struct{}
	plaid_items                      map[int]struct{}
	removedplaid_items               map[int]struct{}
	clearedplaid_items               bool
	spending_categories              map[int]struct{}
	removedspending_categories       map[int]struct{}
	clearedspending_categories       bool
	notification_channels            map[int]struct{}
	removednotification_channels     map[int]struct{}
	clearednotification_channels     bool
	notifications                    map[int]struct{}
	removednotifications             map[int]struct{}
	clearednotifications             bool
	available_discount_offers        map[int]struct{}
	removedavailable_discount_offers map[int]struct{}
	clearedavailable_discount_offers bool
	done                             bool
	oldValue                         func(context.Context) (*User, error)
	predicates                       []predicate.User
}

var _ ent.Mutation = (*UserMutation)(nil)

// userOption allows management of the mutation configuration using functional options.
type userOption func(*UserMutation)

// newUserMutation creates new mutation for the User entity.
func newUserMutation(c config, op Op, opts ...userOption) *UserMutation {
	m := &UserMutation{
		config:        c,
		op:            op,
		typ:           TypeUser,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withUserID sets the ID field of the mutation.
func withUserID(id int) userOption {
	return func(m *UserMutation) {
		var (
			err   error
			once  sync.Once
			value *User
		)
		m.oldValue = func(ctx context.Context) (*User, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().User.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withUser sets the old User of the mutation.
func withUser(node *User) userOption {
	return func(m *UserMutation) {
		m.oldValue = func(context.Context) (*User, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m UserMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m UserMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *UserMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *UserMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().User.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetIdentityProviderID sets the "identity_provider_id" field.
func (m *UserMutation) SetIdentityProviderID(s string) {
	m.identity_provider_id = &s
}

// IdentityProviderID returns the value of the "identity_provider_id" field in the mutation.
func (m *UserMutation) IdentityProviderID() (r string, exists bool) {
	v := m.identity_provider_id
	if v == nil {
		return
	}
	return *v, true
}

// OldIdentityProviderID returns the old "identity_provider_id" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldIdentityProviderID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIdentityProviderID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIdentityProviderID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIdentityProviderID: %w", err)
	}
	return oldValue.IdentityProviderID, nil
}

// ClearIdentityProviderID clears the value of the "identity_provider_id" field.
func (m *UserMutation) ClearIdentityProviderID() {
	m.identity_provider_id = nil
	m.clearedFields[user.FieldIdentityProviderID] = struct{}{}
}

// IdentityProviderIDCleared returns if the "identity_provider_id" field was cleared in this mutation.
func (m *UserMutation) IdentityProviderIDCleared() bool {
	_, ok := m.clearedFields[user.FieldIdentityProviderID]
	return ok
}

// ResetIdentityProviderID resets all changes to the "identity_provider_id" field.
func (m *UserMutation) ResetIdentityProviderID() {
	m.identity_provider_id = nil
	delete(m.clearedFields, user.FieldIdentityProviderID)
}

// SetOfferFrequency sets the "offer_frequency" field.
func (m *UserMutation) SetOfferFrequency(uf user.OfferFrequency) {
	m.offer_frequency = &uf
}

// OfferFrequency returns the value of the "offer_frequency" field in the mutation.
func (m *UserMutation) OfferFrequency() (r user.OfferFrequency, exists bool) {
	v := m.offer_frequency
	if v == nil {
		return
	}
	return *v, true
}

// OldOfferFrequency returns the old "offer_frequency" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldOfferFrequency(ctx context.Context) (v user.OfferFrequency, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOfferFrequency is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOfferFrequency requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOfferFrequency: %w", err)
	}
	return oldValue.OfferFrequency, nil
}

// ResetOfferFrequency resets all changes to the "offer_frequency" field.
func (m *UserMutation) ResetOfferFrequency() {
	m.offer_frequency = nil
}

// SetHomeCountry sets the "home_country" field.
func (m *UserMutation) SetHomeCountry(s string) {
	m.home_country = &s
}

// HomeCountry returns the value of the "home_country" field in the mutation.
func (m *UserMutation) HomeCountry() (r string, exists bool) {
	v := m.home_country
	if v == nil {
		return
	}
	return *v, true
}

// OldHomeCountry returns the old "home_country" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldHomeCountry(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHomeCountry is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHomeCountry requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHomeCountry: %w", err)
	}
	return oldValue.HomeCountry, nil
}

// ClearHomeCountry clears the value of the "home_country" field.
func (m *UserMutation) ClearHomeCountry() {
	m.home_country = nil
	m.clearedFields[user.FieldHomeCountry] = struct{}{}
}

// HomeCountryCleared returns if the "home_country" field was cleared in this mutation.
func (m *UserMutation) HomeCountryCleared() bool {
	_, ok := m.clearedFields[user.FieldHomeCountry]
	return ok
}

// ResetHomeCountry resets all changes to the "home_country" field.
func (m *UserMutation) ResetHomeCountry() {
	m.home_country = nil
	delete(m.clearedFields, user.FieldHomeCountry)
}

// SetHomeState sets the "home_state" field.
func (m *UserMutation) SetHomeState(s string) {
	m.home_state = &s
}

// HomeState returns the value of the "home_state" field in the mutation.
func (m *UserMutation) HomeState() (r string, exists bool) {
	v := m.home_state
	if v == nil {
		return
	}
	return *v, true
}

// OldHomeState returns the old "home_state" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldHomeState(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHomeState is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHomeState requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHomeState: %w", err)
	}
	return oldValue.HomeState, nil
}

// ClearHomeState clears the value of the "home_state" field.
func (m *UserMutation) ClearHomeState() {
	m.home_state = nil
	m.clearedFields[user.FieldHomeState] = struct{}{}
}

// HomeStateCleared returns if the "home_state" field was cleared in this mutation.
func (m *UserMutation) HomeStateCleared() bool {
	_, ok := m.clearedFields[user.FieldHomeState]
	return ok
}

// ResetHomeState resets all changes to the "home_state" field.
func (m *UserMutation) ResetHomeState() {
	m.home_state = nil
	delete(m.clearedFields, user.FieldHomeState)
}

// SetHomeCity sets the "home_city" field.
func (m *UserMutation) SetHomeCity(s string) {
	m.home_city = &s
}

// HomeCity returns the value of the "home_city" field in the mutation.
func (m *UserMutation) HomeCity() (r string, exists bool) {
	v := m.home_city
	if v == nil {
		return
	}
	return *v, true
}

// OldHomeCity returns the old "home_city" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldHomeCity(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHomeCity is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHomeCity requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHomeCity: %w", err)
	}
	return oldValue.HomeCity, nil
}

// ClearHomeCity clears the value of the "home_city" field.
func (m *UserMutation) ClearHomeCity() {
	m.home_city = nil
	m.clearedFields[user.FieldHomeCity] = struct{}{}
}

// HomeCityCleared returns if the "home_city" field was cleared in this mutation.
func (m *UserMutation) HomeCityCleared() bool {
	_, ok := m.clearedFields[user.FieldHomeCity]
	return ok
}

// ResetHomeCity resets all changes to the "home_city" field.
func (m *UserMutation) ResetHomeCity() {
	m.home_city = nil
	delete(m.clearedFields, user.FieldHomeCity)
}

// AddPlaidItemIDs adds the "plaid_items" edge to the PlaidItem entity by ids.
func (m *UserMutation) AddPlaidItemIDs(ids ...int) {
	if m.plaid_items == nil {
		m.plaid_items = make(map[int]struct{})
	}
	for i := range ids {
		m.plaid_items[ids[i]] = struct{}{}
	}
}

// ClearPlaidItems clears the "plaid_items" edge to the PlaidItem entity.
func (m *UserMutation) ClearPlaidItems() {
	m.clearedplaid_items = true
}

// PlaidItemsCleared reports if the "plaid_items" edge to the PlaidItem entity was cleared.
func (m *UserMutation) PlaidItemsCleared() bool {
	return m.clearedplaid_items
}

// RemovePlaidItemIDs removes the "plaid_items" edge to the PlaidItem entity by IDs.
func (m *UserMutation) RemovePlaidItemIDs(ids ...int) {
	if m.removedplaid_items == nil {
		m.removedplaid_items = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.plaid_items, ids[i])
		m.removedplaid_items[ids[i]] = struct{}{}
	}
}

// RemovedPlaidItems returns the removed IDs of the "plaid_items" edge to the PlaidItem entity.
func (m *UserMutation) RemovedPlaidItemsIDs() (ids []int) {
	for id := range m.removedplaid_items {
		ids = append(ids, id)
	}
	return
}

// PlaidItemsIDs returns the "plaid_items" edge IDs in the mutation.
func (m *UserMutation) PlaidItemsIDs() (ids []int) {
	for id := range m.plaid_items {
		ids = append(ids, id)
	}
	return
}

// ResetPlaidItems resets all changes to the "plaid_items" edge.
func (m *UserMutation) ResetPlaidItems() {
	m.plaid_items = nil
	m.clearedplaid_items = false
	m.removedplaid_items = nil
}

// AddSpendingCategoryIDs adds the "spending_categories" edge to the SpendingCategory entity by ids.
func (m *UserMutation) AddSpendingCategoryIDs(ids ...int) {
	if m.spending_categories == nil {
		m.spending_categories = make(map[int]struct{})
	}
	for i := range ids {
		m.spending_categories[ids[i]] = struct{}{}
	}
}

// ClearSpendingCategories clears the "spending_categories" edge to the SpendingCategory entity.
func (m *UserMutation) ClearSpendingCategories() {
	m.clearedspending_categories = true
}

// SpendingCategoriesCleared reports if the "spending_categories" edge to the SpendingCategory entity was cleared.
func (m *UserMutation) SpendingCategoriesCleared() bool {
	return m.clearedspending_categories
}

// RemoveSpendingCategoryIDs removes the "spending_categories" edge to the SpendingCategory entity by IDs.
func (m *UserMutation) RemoveSpendingCategoryIDs(ids ...int) {
	if m.removedspending_categories == nil {
		m.removedspending_categories = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.spending_categories, ids[i])
		m.removedspending_categories[ids[i]] = struct{}{}
	}
}

// RemovedSpendingCategories returns the removed IDs of the "spending_categories" edge to the SpendingCategory entity.
func (m *UserMutation) RemovedSpendingCategoriesIDs() (ids []int) {
	for id := range m.removedspending_categories {
		ids = append(ids, id)
	}
	return
}

// SpendingCategoriesIDs returns the "spending_categories" edge IDs in the mutation.
func (m *UserMutation) SpendingCategoriesIDs() (ids []int) {
	for id := range m.spending_categories {
		ids = append(ids, id)
	}
	return
}

// ResetSpendingCategories resets all changes to the "spending_categories" edge.
func (m *UserMutation) ResetSpendingCategories() {
	m.spending_categories = nil
	m.clearedspending_categories = false
	m.removedspending_categories = nil
}

// AddNotificationChannelIDs adds the "notification_channels" edge to the UserNotificationChannelPreferences entity by ids.
func (m *UserMutation) AddNotificationChannelIDs(ids ...int) {
	if m.notification_channels == nil {
		m.notification_channels = make(map[int]struct{})
	}
	for i := range ids {
		m.notification_channels[ids[i]] = struct{}{}
	}
}

// ClearNotificationChannels clears the "notification_channels" edge to the UserNotificationChannelPreferences entity.
func (m *UserMutation) ClearNotificationChannels() {
	m.clearednotification_channels = true
}

// NotificationChannelsCleared reports if the "notification_channels" edge to the UserNotificationChannelPreferences entity was cleared.
func (m *UserMutation) NotificationChannelsCleared() bool {
	return m.clearednotification_channels
}

// RemoveNotificationChannelIDs removes the "notification_channels" edge to the UserNotificationChannelPreferences entity by IDs.
func (m *UserMutation) RemoveNotificationChannelIDs(ids ...int) {
	if m.removednotification_channels == nil {
		m.removednotification_channels = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.notification_channels, ids[i])
		m.removednotification_channels[ids[i]] = struct{}{}
	}
}

// RemovedNotificationChannels returns the removed IDs of the "notification_channels" edge to the UserNotificationChannelPreferences entity.
func (m *UserMutation) RemovedNotificationChannelsIDs() (ids []int) {
	for id := range m.removednotification_channels {
		ids = append(ids, id)
	}
	return
}

// NotificationChannelsIDs returns the "notification_channels" edge IDs in the mutation.
func (m *UserMutation) NotificationChannelsIDs() (ids []int) {
	for id := range m.notification_channels {
		ids = append(ids, id)
	}
	return
}

// ResetNotificationChannels resets all changes to the "notification_channels" edge.
func (m *UserMutation) ResetNotificationChannels() {
	m.notification_channels = nil
	m.clearednotification_channels = false
	m.removednotification_channels = nil
}

// AddNotificationIDs adds the "notifications" edge to the Notification entity by ids.
func (m *UserMutation) AddNotificationIDs(ids ...int) {
	if m.notifications == nil {
		m.notifications = make(map[int]struct{})
	}
	for i := range ids {
		m.notifications[ids[i]] = struct{}{}
	}
}

// ClearNotifications clears the "notifications" edge to the Notification entity.
func (m *UserMutation) ClearNotifications() {
	m.clearednotifications = true
}

// NotificationsCleared reports if the "notifications" edge to the Notification entity was cleared.
func (m *UserMutation) NotificationsCleared() bool {
	return m.clearednotifications
}

// RemoveNotificationIDs removes the "notifications" edge to the Notification entity by IDs.
func (m *UserMutation) RemoveNotificationIDs(ids ...int) {
	if m.removednotifications == nil {
		m.removednotifications = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.notifications, ids[i])
		m.removednotifications[ids[i]] = struct{}{}
	}
}

// RemovedNotifications returns the removed IDs of the "notifications" edge to the Notification entity.
func (m *UserMutation) RemovedNotificationsIDs() (ids []int) {
	for id := range m.removednotifications {
		ids = append(ids, id)
	}
	return
}

// NotificationsIDs returns the "notifications" edge IDs in the mutation.
func (m *UserMutation) NotificationsIDs() (ids []int) {
	for id := range m.notifications {
		ids = append(ids, id)
	}
	return
}

// ResetNotifications resets all changes to the "notifications" edge.
func (m *UserMutation) ResetNotifications() {
	m.notifications = nil
	m.clearednotifications = false
	m.removednotifications = nil
}

// AddAvailableDiscountOfferIDs adds the "available_discount_offers" edge to the DiscountOffer entity by ids.
func (m *UserMutation) AddAvailableDiscountOfferIDs(ids ...int) {
	if m.available_discount_offers == nil {
		m.available_discount_offers = make(map[int]struct{})
	}
	for i := range ids {
		m.available_discount_offers[ids[i]] = struct{}{}
	}
}

// ClearAvailableDiscountOffers clears the "available_discount_offers" edge to the DiscountOffer entity.
func (m *UserMutation) ClearAvailableDiscountOffers() {
	m.clearedavailable_discount_offers = true
}

// AvailableDiscountOffersCleared reports if the "available_discount_offers" edge to the DiscountOffer entity was cleared.
func (m *UserMutation) AvailableDiscountOffersCleared() bool {
	return m.clearedavailable_discount_offers
}

// RemoveAvailableDiscountOfferIDs removes the "available_discount_offers" edge to the DiscountOffer entity by IDs.
func (m *UserMutation) RemoveAvailableDiscountOfferIDs(ids ...int) {
	if m.removedavailable_discount_offers == nil {
		m.removedavailable_discount_offers = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.available_discount_offers, ids[i])
		m.removedavailable_discount_offers[ids[i]] = struct{}{}
	}
}

// RemovedAvailableDiscountOffers returns the removed IDs of the "available_discount_offers" edge to the DiscountOffer entity.
func (m *UserMutation) RemovedAvailableDiscountOffersIDs() (ids []int) {
	for id := range m.removedavailable_discount_offers {
		ids = append(ids, id)
	}
	return
}

// AvailableDiscountOffersIDs returns the "available_discount_offers" edge IDs in the mutation.
func (m *UserMutation) AvailableDiscountOffersIDs() (ids []int) {
	for id := range m.available_discount_offers {
		ids = append(ids, id)
	}
	return
}

// ResetAvailableDiscountOffers resets all changes to the "available_discount_offers" edge.
func (m *UserMutation) ResetAvailableDiscountOffers() {
	m.available_discount_offers = nil
	m.clearedavailable_discount_offers = false
	m.removedavailable_discount_offers = nil
}

// Where appends a list predicates to the UserMutation builder.
func (m *UserMutation) Where(ps ...predicate.User) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the UserMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *UserMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.User, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *UserMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *UserMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (User).
func (m *UserMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *UserMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.identity_provider_id != nil {
		fields = append(fields, user.FieldIdentityProviderID)
	}
	if m.offer_frequency != nil {
		fields = append(fields, user.FieldOfferFrequency)
	}
	if m.home_country != nil {
		fields = append(fields, user.FieldHomeCountry)
	}
	if m.home_state != nil {
		fields = append(fields, user.FieldHomeState)
	}
	if m.home_city != nil {
		fields = append(fields, user.FieldHomeCity)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *UserMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case user.FieldIdentityProviderID:
		return m.IdentityProviderID()
	case user.FieldOfferFrequency:
		return m.OfferFrequency()
	case user.FieldHomeCountry:
		return m.HomeCountry()
	case user.FieldHomeState:
		return m.HomeState()
	case user.FieldHomeCity:
		return m.HomeCity()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *UserMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case user.FieldIdentityProviderID:
		return m.OldIdentityProviderID(ctx)
	case user.FieldOfferFrequency:
		return m.OldOfferFrequency(ctx)
	case user.FieldHomeCountry:
		return m.OldHomeCountry(ctx)
	case user.FieldHomeState:
		return m.OldHomeState(ctx)
	case user.FieldHomeCity:
		return m.OldHomeCity(ctx)
	}
	return nil, fmt.Errorf("unknown User field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserMutation) SetField(name string, value ent.Value) error {
	switch name {
	case user.FieldIdentityProviderID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIdentityProviderID(v)
		return nil
	case user.FieldOfferFrequency:
		v, ok := value.(user.OfferFrequency)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOfferFrequency(v)
		return nil
	case user.FieldHomeCountry:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHomeCountry(v)
		return nil
	case user.FieldHomeState:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHomeState(v)
		return nil
	case user.FieldHomeCity:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHomeCity(v)
		return nil
	}
	return fmt.Errorf("unknown User field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *UserMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *UserMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown User numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *UserMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(user.FieldIdentityProviderID) {
		fields = append(fields, user.FieldIdentityProviderID)
	}
	if m.FieldCleared(user.FieldHomeCountry) {
		fields = append(fields, user.FieldHomeCountry)
	}
	if m.FieldCleared(user.FieldHomeState) {
		fields = append(fields, user.FieldHomeState)
	}
	if m.FieldCleared(user.FieldHomeCity) {
		fields = append(fields, user.FieldHomeCity)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *UserMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *UserMutation) ClearField(name string) error {
	switch name {
	case user.FieldIdentityProviderID:
		m.ClearIdentityProviderID()
		return nil
	case user.FieldHomeCountry:
		m.ClearHomeCountry()
		return nil
	case user.FieldHomeState:
		m.ClearHomeState()
		return nil
	case user.FieldHomeCity:
		m.ClearHomeCity()
		return nil
	}
	return fmt.Errorf("unknown User nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *UserMutation) ResetField(name string) error {
	switch name {
	case user.FieldIdentityProviderID:
		m.ResetIdentityProviderID()
		return nil
	case user.FieldOfferFrequency:
		m.ResetOfferFrequency()
		return nil
	case user.FieldHomeCountry:
		m.ResetHomeCountry()
		return nil
	case user.FieldHomeState:
		m.ResetHomeState()
		return nil
	case user.FieldHomeCity:
		m.ResetHomeCity()
		return nil
	}
	return fmt.Errorf("unknown User field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *UserMutation) AddedEdges() []string {
	edges := make([]string, 0, 5)
	if m.plaid_items != nil {
		edges = append(edges, user.EdgePlaidItems)
	}
	if m.spending_categories != nil {
		edges = append(edges, user.EdgeSpendingCategories)
	}
	if m.notification_channels != nil {
		edges = append(edges, user.EdgeNotificationChannels)
	}
	if m.notifications != nil {
		edges = append(edges, user.EdgeNotifications)
	}
	if m.available_discount_offers != nil {
		edges = append(edges, user.EdgeAvailableDiscountOffers)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *UserMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case user.EdgePlaidItems:
		ids := make([]ent.Value, 0, len(m.plaid_items))
		for id := range m.plaid_items {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeSpendingCategories:
		ids := make([]ent.Value, 0, len(m.spending_categories))
		for id := range m.spending_categories {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeNotificationChannels:
		ids := make([]ent.Value, 0, len(m.notification_channels))
		for id := range m.notification_channels {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeNotifications:
		ids := make([]ent.Value, 0, len(m.notifications))
		for id := range m.notifications {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeAvailableDiscountOffers:
		ids := make([]ent.Value, 0, len(m.available_discount_offers))
		for id := range m.available_discount_offers {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *UserMutation) RemovedEdges() []string {
	edges := make([]string, 0, 5)
	if m.removedplaid_items != nil {
		edges = append(edges, user.EdgePlaidItems)
	}
	if m.removedspending_categories != nil {
		edges = append(edges, user.EdgeSpendingCategories)
	}
	if m.removednotification_channels != nil {
		edges = append(edges, user.EdgeNotificationChannels)
	}
	if m.removednotifications != nil {
		edges = append(edges, user.EdgeNotifications)
	}
	if m.removedavailable_discount_offers != nil {
		edges = append(edges, user.EdgeAvailableDiscountOffers)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *UserMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case user.EdgePlaidItems:
		ids := make([]ent.Value, 0, len(m.removedplaid_items))
		for id := range m.removedplaid_items {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeSpendingCategories:
		ids := make([]ent.Value, 0, len(m.removedspending_categories))
		for id := range m.removedspending_categories {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeNotificationChannels:
		ids := make([]ent.Value, 0, len(m.removednotification_channels))
		for id := range m.removednotification_channels {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeNotifications:
		ids := make([]ent.Value, 0, len(m.removednotifications))
		for id := range m.removednotifications {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeAvailableDiscountOffers:
		ids := make([]ent.Value, 0, len(m.removedavailable_discount_offers))
		for id := range m.removedavailable_discount_offers {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *UserMutation) ClearedEdges() []string {
	edges := make([]string, 0, 5)
	if m.clearedplaid_items {
		edges = append(edges, user.EdgePlaidItems)
	}
	if m.clearedspending_categories {
		edges = append(edges, user.EdgeSpendingCategories)
	}
	if m.clearednotification_channels {
		edges = append(edges, user.EdgeNotificationChannels)
	}
	if m.clearednotifications {
		edges = append(edges, user.EdgeNotifications)
	}
	if m.clearedavailable_discount_offers {
		edges = append(edges, user.EdgeAvailableDiscountOffers)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *UserMutation) EdgeCleared(name string) bool {
	switch name {
	case user.EdgePlaidItems:
		return m.clearedplaid_items
	case user.EdgeSpendingCategories:
		return m.clearedspending_categories
	case user.EdgeNotificationChannels:
		return m.clearednotification_channels
	case user.EdgeNotifications:
		return m.clearednotifications
	case user.EdgeAvailableDiscountOffers:
		return m.clearedavailable_discount_offers
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *UserMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown User unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *UserMutation) ResetEdge(name string) error {
	switch name {
	case user.EdgePlaidItems:
		m.ResetPlaidItems()
		return nil
	case user.EdgeSpendingCategories:
		m.ResetSpendingCategories()
		return nil
	case user.EdgeNotificationChannels:
		m.ResetNotificationChannels()
		return nil
	case user.EdgeNotifications:
		m.ResetNotifications()
		return nil
	case user.EdgeAvailableDiscountOffers:
		m.ResetAvailableDiscountOffers()
		return nil
	}
	return fmt.Errorf("unknown User edge %s", name)
}

// UserNotificationChannelPreferencesMutation represents an operation that mutates the UserNotificationChannelPreferences nodes in the graph.
type UserNotificationChannelPreferencesMutation struct {
	config
	op                  Op
	typ                 string
	id                  *int
	chanel              *usernotificationchannelpreferences.Chanel
	clearedFields       map[string]struct{}
	chanel_users        *int
	clearedchanel_users bool
	done                bool
	oldValue            func(context.Context) (*UserNotificationChannelPreferences, error)
	predicates          []predicate.UserNotificationChannelPreferences
}

var _ ent.Mutation = (*UserNotificationChannelPreferencesMutation)(nil)

// usernotificationchannelpreferencesOption allows management of the mutation configuration using functional options.
type usernotificationchannelpreferencesOption func(*UserNotificationChannelPreferencesMutation)

// newUserNotificationChannelPreferencesMutation creates new mutation for the UserNotificationChannelPreferences entity.
func newUserNotificationChannelPreferencesMutation(c config, op Op, opts ...usernotificationchannelpreferencesOption) *UserNotificationChannelPreferencesMutation {
	m := &UserNotificationChannelPreferencesMutation{
		config:        c,
		op:            op,
		typ:           TypeUserNotificationChannelPreferences,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withUserNotificationChannelPreferencesID sets the ID field of the mutation.
func withUserNotificationChannelPreferencesID(id int) usernotificationchannelpreferencesOption {
	return func(m *UserNotificationChannelPreferencesMutation) {
		var (
			err   error
			once  sync.Once
			value *UserNotificationChannelPreferences
		)
		m.oldValue = func(ctx context.Context) (*UserNotificationChannelPreferences, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().UserNotificationChannelPreferences.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withUserNotificationChannelPreferences sets the old UserNotificationChannelPreferences of the mutation.
func withUserNotificationChannelPreferences(node *UserNotificationChannelPreferences) usernotificationchannelpreferencesOption {
	return func(m *UserNotificationChannelPreferencesMutation) {
		m.oldValue = func(context.Context) (*UserNotificationChannelPreferences, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m UserNotificationChannelPreferencesMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m UserNotificationChannelPreferencesMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *UserNotificationChannelPreferencesMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *UserNotificationChannelPreferencesMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().UserNotificationChannelPreferences.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetChanel sets the "chanel" field.
func (m *UserNotificationChannelPreferencesMutation) SetChanel(u usernotificationchannelpreferences.Chanel) {
	m.chanel = &u
}

// Chanel returns the value of the "chanel" field in the mutation.
func (m *UserNotificationChannelPreferencesMutation) Chanel() (r usernotificationchannelpreferences.Chanel, exists bool) {
	v := m.chanel
	if v == nil {
		return
	}
	return *v, true
}

// OldChanel returns the old "chanel" field's value of the UserNotificationChannelPreferences entity.
// If the UserNotificationChannelPreferences object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserNotificationChannelPreferencesMutation) OldChanel(ctx context.Context) (v usernotificationchannelpreferences.Chanel, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldChanel is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldChanel requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldChanel: %w", err)
	}
	return oldValue.Chanel, nil
}

// ResetChanel resets all changes to the "chanel" field.
func (m *UserNotificationChannelPreferencesMutation) ResetChanel() {
	m.chanel = nil
}

// SetChanelUsersID sets the "chanel_users" edge to the User entity by id.
func (m *UserNotificationChannelPreferencesMutation) SetChanelUsersID(id int) {
	m.chanel_users = &id
}

// ClearChanelUsers clears the "chanel_users" edge to the User entity.
func (m *UserNotificationChannelPreferencesMutation) ClearChanelUsers() {
	m.clearedchanel_users = true
}

// ChanelUsersCleared reports if the "chanel_users" edge to the User entity was cleared.
func (m *UserNotificationChannelPreferencesMutation) ChanelUsersCleared() bool {
	return m.clearedchanel_users
}

// ChanelUsersID returns the "chanel_users" edge ID in the mutation.
func (m *UserNotificationChannelPreferencesMutation) ChanelUsersID() (id int, exists bool) {
	if m.chanel_users != nil {
		return *m.chanel_users, true
	}
	return
}

// ChanelUsersIDs returns the "chanel_users" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ChanelUsersID instead. It exists only for internal usage by the builders.
func (m *UserNotificationChannelPreferencesMutation) ChanelUsersIDs() (ids []int) {
	if id := m.chanel_users; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetChanelUsers resets all changes to the "chanel_users" edge.
func (m *UserNotificationChannelPreferencesMutation) ResetChanelUsers() {
	m.chanel_users = nil
	m.clearedchanel_users = false
}

// Where appends a list predicates to the UserNotificationChannelPreferencesMutation builder.
func (m *UserNotificationChannelPreferencesMutation) Where(ps ...predicate.UserNotificationChannelPreferences) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the UserNotificationChannelPreferencesMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *UserNotificationChannelPreferencesMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.UserNotificationChannelPreferences, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *UserNotificationChannelPreferencesMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *UserNotificationChannelPreferencesMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (UserNotificationChannelPreferences).
func (m *UserNotificationChannelPreferencesMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *UserNotificationChannelPreferencesMutation) Fields() []string {
	fields := make([]string, 0, 1)
	if m.chanel != nil {
		fields = append(fields, usernotificationchannelpreferences.FieldChanel)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *UserNotificationChannelPreferencesMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case usernotificationchannelpreferences.FieldChanel:
		return m.Chanel()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *UserNotificationChannelPreferencesMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case usernotificationchannelpreferences.FieldChanel:
		return m.OldChanel(ctx)
	}
	return nil, fmt.Errorf("unknown UserNotificationChannelPreferences field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserNotificationChannelPreferencesMutation) SetField(name string, value ent.Value) error {
	switch name {
	case usernotificationchannelpreferences.FieldChanel:
		v, ok := value.(usernotificationchannelpreferences.Chanel)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetChanel(v)
		return nil
	}
	return fmt.Errorf("unknown UserNotificationChannelPreferences field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *UserNotificationChannelPreferencesMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *UserNotificationChannelPreferencesMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserNotificationChannelPreferencesMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown UserNotificationChannelPreferences numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *UserNotificationChannelPreferencesMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *UserNotificationChannelPreferencesMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *UserNotificationChannelPreferencesMutation) ClearField(name string) error {
	return fmt.Errorf("unknown UserNotificationChannelPreferences nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *UserNotificationChannelPreferencesMutation) ResetField(name string) error {
	switch name {
	case usernotificationchannelpreferences.FieldChanel:
		m.ResetChanel()
		return nil
	}
	return fmt.Errorf("unknown UserNotificationChannelPreferences field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *UserNotificationChannelPreferencesMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.chanel_users != nil {
		edges = append(edges, usernotificationchannelpreferences.EdgeChanelUsers)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *UserNotificationChannelPreferencesMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case usernotificationchannelpreferences.EdgeChanelUsers:
		if id := m.chanel_users; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *UserNotificationChannelPreferencesMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *UserNotificationChannelPreferencesMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *UserNotificationChannelPreferencesMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedchanel_users {
		edges = append(edges, usernotificationchannelpreferences.EdgeChanelUsers)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *UserNotificationChannelPreferencesMutation) EdgeCleared(name string) bool {
	switch name {
	case usernotificationchannelpreferences.EdgeChanelUsers:
		return m.clearedchanel_users
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *UserNotificationChannelPreferencesMutation) ClearEdge(name string) error {
	switch name {
	case usernotificationchannelpreferences.EdgeChanelUsers:
		m.ClearChanelUsers()
		return nil
	}
	return fmt.Errorf("unknown UserNotificationChannelPreferences unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *UserNotificationChannelPreferencesMutation) ResetEdge(name string) error {
	switch name {
	case usernotificationchannelpreferences.EdgeChanelUsers:
		m.ResetChanelUsers()
		return nil
	}
	return fmt.Errorf("unknown UserNotificationChannelPreferences edge %s", name)
}
