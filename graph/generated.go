// Code generated by github.com/99designs/gqlgen, DO NOT EDIT.

package graph

import (
	"bytes"
	"context"
	"errors"
	"fmt"
	"io"
	"strconv"
	"sync"
	"sync/atomic"
	"time"
	"wallit/ent"
	"wallit/ent/discountoffer"
	"wallit/ent/notification"
	"wallit/ent/user"
	"wallit/ent/usernotificationchannelpreferences"
	"wallit/graph/model"

	"github.com/99designs/gqlgen/graphql"
	"github.com/99designs/gqlgen/graphql/introspection"
	gqlparser "github.com/vektah/gqlparser/v2"
	"github.com/vektah/gqlparser/v2/ast"
)

// region    ************************** generated!.gotpl **************************

// NewExecutableSchema creates an ExecutableSchema from the ResolverRoot interface.
func NewExecutableSchema(cfg Config) graphql.ExecutableSchema {
	return &executableSchema{
		resolvers:  cfg.Resolvers,
		directives: cfg.Directives,
		complexity: cfg.Complexity,
	}
}

type Config struct {
	Resolvers  ResolverRoot
	Directives DirectiveRoot
	Complexity ComplexityRoot
}

type ResolverRoot interface {
	Mutation() MutationResolver
	Query() QueryResolver
	Subscription() SubscriptionResolver
}

type DirectiveRoot struct {
}

type ComplexityRoot struct {
	DiscountOffer struct {
		Amount                         func(childComplexity int) int
		CreatedAt                      func(childComplexity int) int
		Currency                       func(childComplexity int) int
		Description                    func(childComplexity int) int
		DiscountEligibleUsers          func(childComplexity int) int
		DiscountOfferNotification      func(childComplexity int) int
		ExpiresAt                      func(childComplexity int) int
		ID                             func(childComplexity int) int
		MerchantSpecificIdentification func(childComplexity int) int
		OwnerMerchant                  func(childComplexity int) int
		Type                           func(childComplexity int) int
	}

	DiscountOfferConnection struct {
		Edges      func(childComplexity int) int
		PageInfo   func(childComplexity int) int
		TotalCount func(childComplexity int) int
	}

	DiscountOfferEdge struct {
		Cursor func(childComplexity int) int
		Node   func(childComplexity int) int
	}

	InstitutionInfo struct {
		InstitutionID func(childComplexity int) int
		Name          func(childComplexity int) int
	}

	LinkTokenHost struct {
		LinkToken func(childComplexity int) int
	}

	Merchant struct {
		DiscountOffers func(childComplexity int) int
		ID             func(childComplexity int) int
		Name           func(childComplexity int) int
	}

	Mutation struct {
		CreateDiscountOffer             func(childComplexity int, input ent.CreateDiscountOfferInput) int
		CreateLinkToken                 func(childComplexity int, input model.CreateLinkTokenParams) int
		CreateMerchant                  func(childComplexity int, input ent.CreateMerchantInput) int
		ExchangeAuthTokenForUserProfile func(childComplexity int, input model.ExchangeAuthTokenForUserProfileInput) int
		ExchangePublicToken             func(childComplexity int, input model.ExchangePublicTokenParams) int
		MarkNotificationsAsCheckedInApp func(childComplexity int, ids []int) int
		SetNotificationChannels         func(childComplexity int, userID int, notificationChannel []usernotificationchannelpreferences.Chanel) int
		SetOfferFrequency               func(childComplexity int, userID int, frequency user.OfferFrequency) int
		SetSpendingCategories           func(childComplexity int, userID int, spendingCategoryIDs []int) int
		UpdateUser                      func(childComplexity int, id int, input *ent.UpdateUserInput) int
	}

	Notification struct {
		CheckedInApp                func(childComplexity int) int
		CreatedAt                   func(childComplexity int) int
		ID                          func(childComplexity int) int
		IncludedInAggregatedOfferAt func(childComplexity int) int
		NotificationDiscountOffer   func(childComplexity int) int
		NotificationRecipient       func(childComplexity int) int
		Type                        func(childComplexity int) int
	}

	NotificationConnection struct {
		Edges      func(childComplexity int) int
		PageInfo   func(childComplexity int) int
		TotalCount func(childComplexity int) int
	}

	NotificationEdge struct {
		Cursor func(childComplexity int) int
		Node   func(childComplexity int) int
	}

	PageInfo struct {
		EndCursor       func(childComplexity int) int
		HasNextPage     func(childComplexity int) int
		HasPreviousPage func(childComplexity int) int
		StartCursor     func(childComplexity int) int
	}

	PlaidAccountBalances struct {
		Available       func(childComplexity int) int
		Current         func(childComplexity int) int
		IsoCurrencyCode func(childComplexity int) int
	}

	PlaidAccountInfo struct {
		AccountID    func(childComplexity int) int
		Balances     func(childComplexity int) int
		Mask         func(childComplexity int) int
		Name         func(childComplexity int) int
		OfficialName func(childComplexity int) int
		Transactions func(childComplexity int, after *ent.Cursor, first *int, before *ent.Cursor, last *int, where *ent.TransactionWhereInput, orderBy *ent.TransactionOrder) int
		Type         func(childComplexity int) int
	}

	PlaidInstitution struct {
		Accounts      func(childComplexity int) int
		ID            func(childComplexity int) int
		InstitutionID func(childComplexity int) int
		Name          func(childComplexity int) int
		PlaidItem     func(childComplexity int) int
	}

	PlaidInstitutionAccount struct {
		AccountID              func(childComplexity int) int
		BalanceAvailable       func(childComplexity int) int
		BalanceCurrent         func(childComplexity int) int
		BalanceIsoCurrencyCode func(childComplexity int) int
		ID                     func(childComplexity int) int
		Mask                   func(childComplexity int) int
		Name                   func(childComplexity int) int
		OfficialName           func(childComplexity int) int
		ParentInstitution      func(childComplexity int) int
		Transactions           func(childComplexity int, after *ent.Cursor, first *int, before *ent.Cursor, last *int, orderBy *ent.TransactionOrder, where *ent.TransactionWhereInput) int
		Type                   func(childComplexity int) int
	}

	PlaidInstitutionAccountConnection struct {
		Edges      func(childComplexity int) int
		PageInfo   func(childComplexity int) int
		TotalCount func(childComplexity int) int
	}

	PlaidInstitutionAccountEdge struct {
		Cursor func(childComplexity int) int
		Node   func(childComplexity int) int
	}

	PlaidInstitutionConnection struct {
		Edges      func(childComplexity int) int
		PageInfo   func(childComplexity int) int
		TotalCount func(childComplexity int) int
	}

	PlaidInstitutionEdge struct {
		Cursor func(childComplexity int) int
		Node   func(childComplexity int) int
	}

	PlaidItem struct {
		AccessToken      func(childComplexity int) int
		CreatedAt        func(childComplexity int) int
		ID               func(childComplexity int) int
		Institution      func(childComplexity int) int
		ItemID           func(childComplexity int) int
		Owner            func(childComplexity int) int
		TransactionSyncs func(childComplexity int) int
		UpdatedAt        func(childComplexity int) int
	}

	PlaidItemConnection struct {
		Edges      func(childComplexity int) int
		PageInfo   func(childComplexity int) int
		TotalCount func(childComplexity int) int
	}

	PlaidItemEdge struct {
		Cursor func(childComplexity int) int
		Node   func(childComplexity int) int
	}

	Query struct {
		DiscountOffers           func(childComplexity int, after *ent.Cursor, first *int, before *ent.Cursor, last *int, orderBy *ent.DiscountOfferOrder, where *ent.DiscountOfferWhereInput) int
		Node                     func(childComplexity int, id int) int
		Nodes                    func(childComplexity int, ids []int) int
		NotificationChannels     func(childComplexity int, after *ent.Cursor, first *int, before *ent.Cursor, last *int, where *ent.UserNotificationChannelPreferencesWhereInput) int
		Notifications            func(childComplexity int, after *ent.Cursor, first *int, before *ent.Cursor, last *int, orderBy *ent.NotificationOrder, where *ent.NotificationWhereInput) int
		PlaidInstitutionAccounts func(childComplexity int, after *ent.Cursor, first *int, before *ent.Cursor, last *int, where *ent.PlaidInstitutionAccountWhereInput) int
		PlaidInstitutions        func(childComplexity int, after *ent.Cursor, first *int, before *ent.Cursor, last *int, where *ent.PlaidInstitutionWhereInput) int
		PlaidItems               func(childComplexity int, after *ent.Cursor, first *int, before *ent.Cursor, last *int, where *ent.PlaidItemWhereInput) int
		SpendingCategories       func(childComplexity int, after *ent.Cursor, first *int, before *ent.Cursor, last *int, where *ent.SpendingCategoryWhereInput) int
		Transactions             func(childComplexity int, after *ent.Cursor, first *int, before *ent.Cursor, last *int, orderBy *ent.TransactionOrder, where *ent.TransactionWhereInput) int
	}

	SpendingCategory struct {
		CategoryID           func(childComplexity int) int
		CategoryTransactions func(childComplexity int) int
		CreatedAt            func(childComplexity int) int
		ID                   func(childComplexity int) int
		InterestedUsers      func(childComplexity int) int
		Name                 func(childComplexity int) int
	}

	SpendingCategoryConnection struct {
		Edges      func(childComplexity int) int
		PageInfo   func(childComplexity int) int
		TotalCount func(childComplexity int) int
	}

	SpendingCategoryEdge struct {
		Cursor func(childComplexity int) int
		Node   func(childComplexity int) int
	}

	Subscription struct {
		Notification func(childComplexity int, ownerID int) int
	}

	Transaction struct {
		AccountOwner           func(childComplexity int) int
		Amount                 func(childComplexity int) int
		AuthorizedDate         func(childComplexity int) int
		AuthorizedDatetime     func(childComplexity int) int
		Category               func(childComplexity int) int
		CategoryID             func(childComplexity int) int
		CheckNumber            func(childComplexity int) int
		CreatedAt              func(childComplexity int) int
		Date                   func(childComplexity int) int
		Datetime               func(childComplexity int) int
		FinancialAccountID     func(childComplexity int) int
		ID                     func(childComplexity int) int
		InstitutionAccount     func(childComplexity int) int
		IsoCurrencyCode        func(childComplexity int) int
		LocationAddress        func(childComplexity int) int
		LocationCity           func(childComplexity int) int
		LocationLat            func(childComplexity int) int
		LocationLon            func(childComplexity int) int
		LocationPostalCode     func(childComplexity int) int
		LocationRegion         func(childComplexity int) int
		LocationStoreNumber    func(childComplexity int) int
		MerchantName           func(childComplexity int) int
		Name                   func(childComplexity int) int
		PaymentChannel         func(childComplexity int) int
		Pending                func(childComplexity int) int
		PendingTransactionID   func(childComplexity int) int
		TransactionCategories  func(childComplexity int) int
		TransactionCode        func(childComplexity int) int
		TransactionID          func(childComplexity int) int
		UnofficialCurrencyCode func(childComplexity int) int
	}

	TransactionConnection struct {
		Edges      func(childComplexity int) int
		PageInfo   func(childComplexity int) int
		TotalCount func(childComplexity int) int
	}

	TransactionEdge struct {
		Cursor func(childComplexity int) int
		Node   func(childComplexity int) int
	}

	TransactionSync struct {
		CreatedAt func(childComplexity int) int
		Cursor    func(childComplexity int) int
		ID        func(childComplexity int) int
		Item      func(childComplexity int) int
	}

	User struct {
		AvailableDiscountOffers func(childComplexity int) int
		HomeCity                func(childComplexity int) int
		HomeCountry             func(childComplexity int) int
		HomeState               func(childComplexity int) int
		ID                      func(childComplexity int) int
		IdentityProviderID      func(childComplexity int) int
		NotificationChannels    func(childComplexity int) int
		Notifications           func(childComplexity int) int
		OfferFrequency          func(childComplexity int) int
		PlaidItems              func(childComplexity int) int
		SpendingCategories      func(childComplexity int) int
	}

	UserNotificationChannelPreferences struct {
		Chanel      func(childComplexity int) int
		ChanelUsers func(childComplexity int) int
		ID          func(childComplexity int) int
	}

	UserNotificationChannelPreferencesConnection struct {
		Edges      func(childComplexity int) int
		PageInfo   func(childComplexity int) int
		TotalCount func(childComplexity int) int
	}

	UserNotificationChannelPreferencesEdge struct {
		Cursor func(childComplexity int) int
		Node   func(childComplexity int) int
	}
}

type MutationResolver interface {
	CreateLinkToken(ctx context.Context, input model.CreateLinkTokenParams) (*model.LinkTokenHost, error)
	ExchangePublicToken(ctx context.Context, input model.ExchangePublicTokenParams) (string, error)
	CreateDiscountOffer(ctx context.Context, input ent.CreateDiscountOfferInput) (*ent.DiscountOffer, error)
	CreateMerchant(ctx context.Context, input ent.CreateMerchantInput) (*ent.Merchant, error)
	MarkNotificationsAsCheckedInApp(ctx context.Context, ids []int) (bool, error)
	ExchangeAuthTokenForUserProfile(ctx context.Context, input model.ExchangeAuthTokenForUserProfileInput) (*ent.User, error)
	UpdateUser(ctx context.Context, id int, input *ent.UpdateUserInput) (*ent.User, error)
	SetSpendingCategories(ctx context.Context, userID int, spendingCategoryIDs []int) (*ent.User, error)
	SetNotificationChannels(ctx context.Context, userID int, notificationChannel []usernotificationchannelpreferences.Chanel) (*ent.User, error)
	SetOfferFrequency(ctx context.Context, userID int, frequency user.OfferFrequency) (*ent.User, error)
}
type QueryResolver interface {
	Node(ctx context.Context, id int) (ent.Noder, error)
	Nodes(ctx context.Context, ids []int) ([]ent.Noder, error)
	DiscountOffers(ctx context.Context, after *ent.Cursor, first *int, before *ent.Cursor, last *int, orderBy *ent.DiscountOfferOrder, where *ent.DiscountOfferWhereInput) (*ent.DiscountOfferConnection, error)
	Notifications(ctx context.Context, after *ent.Cursor, first *int, before *ent.Cursor, last *int, orderBy *ent.NotificationOrder, where *ent.NotificationWhereInput) (*ent.NotificationConnection, error)
	PlaidItems(ctx context.Context, after *ent.Cursor, first *int, before *ent.Cursor, last *int, where *ent.PlaidItemWhereInput) (*ent.PlaidItemConnection, error)
	Transactions(ctx context.Context, after *ent.Cursor, first *int, before *ent.Cursor, last *int, orderBy *ent.TransactionOrder, where *ent.TransactionWhereInput) (*ent.TransactionConnection, error)
	PlaidInstitutionAccounts(ctx context.Context, after *ent.Cursor, first *int, before *ent.Cursor, last *int, where *ent.PlaidInstitutionAccountWhereInput) (*ent.PlaidInstitutionAccountConnection, error)
	PlaidInstitutions(ctx context.Context, after *ent.Cursor, first *int, before *ent.Cursor, last *int, where *ent.PlaidInstitutionWhereInput) (*ent.PlaidInstitutionConnection, error)
	SpendingCategories(ctx context.Context, after *ent.Cursor, first *int, before *ent.Cursor, last *int, where *ent.SpendingCategoryWhereInput) (*ent.SpendingCategoryConnection, error)
	NotificationChannels(ctx context.Context, after *ent.Cursor, first *int, before *ent.Cursor, last *int, where *ent.UserNotificationChannelPreferencesWhereInput) (*ent.UserNotificationChannelPreferencesConnection, error)
}
type SubscriptionResolver interface {
	Notification(ctx context.Context, ownerID int) (<-chan *ent.Notification, error)
}

type executableSchema struct {
	resolvers  ResolverRoot
	directives DirectiveRoot
	complexity ComplexityRoot
}

func (e *executableSchema) Schema() *ast.Schema {
	return parsedSchema
}

func (e *executableSchema) Complexity(typeName, field string, childComplexity int, rawArgs map[string]interface{}) (int, bool) {
	ec := executionContext{nil, e}
	_ = ec
	switch typeName + "." + field {

	case "DiscountOffer.amount":
		if e.complexity.DiscountOffer.Amount == nil {
			break
		}

		return e.complexity.DiscountOffer.Amount(childComplexity), true

	case "DiscountOffer.createdAt":
		if e.complexity.DiscountOffer.CreatedAt == nil {
			break
		}

		return e.complexity.DiscountOffer.CreatedAt(childComplexity), true

	case "DiscountOffer.currency":
		if e.complexity.DiscountOffer.Currency == nil {
			break
		}

		return e.complexity.DiscountOffer.Currency(childComplexity), true

	case "DiscountOffer.description":
		if e.complexity.DiscountOffer.Description == nil {
			break
		}

		return e.complexity.DiscountOffer.Description(childComplexity), true

	case "DiscountOffer.discountEligibleUsers":
		if e.complexity.DiscountOffer.DiscountEligibleUsers == nil {
			break
		}

		return e.complexity.DiscountOffer.DiscountEligibleUsers(childComplexity), true

	case "DiscountOffer.discountOfferNotification":
		if e.complexity.DiscountOffer.DiscountOfferNotification == nil {
			break
		}

		return e.complexity.DiscountOffer.DiscountOfferNotification(childComplexity), true

	case "DiscountOffer.expiresAt":
		if e.complexity.DiscountOffer.ExpiresAt == nil {
			break
		}

		return e.complexity.DiscountOffer.ExpiresAt(childComplexity), true

	case "DiscountOffer.id":
		if e.complexity.DiscountOffer.ID == nil {
			break
		}

		return e.complexity.DiscountOffer.ID(childComplexity), true

	case "DiscountOffer.merchantSpecificIdentification":
		if e.complexity.DiscountOffer.MerchantSpecificIdentification == nil {
			break
		}

		return e.complexity.DiscountOffer.MerchantSpecificIdentification(childComplexity), true

	case "DiscountOffer.ownerMerchant":
		if e.complexity.DiscountOffer.OwnerMerchant == nil {
			break
		}

		return e.complexity.DiscountOffer.OwnerMerchant(childComplexity), true

	case "DiscountOffer.type":
		if e.complexity.DiscountOffer.Type == nil {
			break
		}

		return e.complexity.DiscountOffer.Type(childComplexity), true

	case "DiscountOfferConnection.edges":
		if e.complexity.DiscountOfferConnection.Edges == nil {
			break
		}

		return e.complexity.DiscountOfferConnection.Edges(childComplexity), true

	case "DiscountOfferConnection.pageInfo":
		if e.complexity.DiscountOfferConnection.PageInfo == nil {
			break
		}

		return e.complexity.DiscountOfferConnection.PageInfo(childComplexity), true

	case "DiscountOfferConnection.totalCount":
		if e.complexity.DiscountOfferConnection.TotalCount == nil {
			break
		}

		return e.complexity.DiscountOfferConnection.TotalCount(childComplexity), true

	case "DiscountOfferEdge.cursor":
		if e.complexity.DiscountOfferEdge.Cursor == nil {
			break
		}

		return e.complexity.DiscountOfferEdge.Cursor(childComplexity), true

	case "DiscountOfferEdge.node":
		if e.complexity.DiscountOfferEdge.Node == nil {
			break
		}

		return e.complexity.DiscountOfferEdge.Node(childComplexity), true

	case "InstitutionInfo.institutionId":
		if e.complexity.InstitutionInfo.InstitutionID == nil {
			break
		}

		return e.complexity.InstitutionInfo.InstitutionID(childComplexity), true

	case "InstitutionInfo.name":
		if e.complexity.InstitutionInfo.Name == nil {
			break
		}

		return e.complexity.InstitutionInfo.Name(childComplexity), true

	case "LinkTokenHost.linkToken":
		if e.complexity.LinkTokenHost.LinkToken == nil {
			break
		}

		return e.complexity.LinkTokenHost.LinkToken(childComplexity), true

	case "Merchant.discountOffers":
		if e.complexity.Merchant.DiscountOffers == nil {
			break
		}

		return e.complexity.Merchant.DiscountOffers(childComplexity), true

	case "Merchant.id":
		if e.complexity.Merchant.ID == nil {
			break
		}

		return e.complexity.Merchant.ID(childComplexity), true

	case "Merchant.name":
		if e.complexity.Merchant.Name == nil {
			break
		}

		return e.complexity.Merchant.Name(childComplexity), true

	case "Mutation.createDiscountOffer":
		if e.complexity.Mutation.CreateDiscountOffer == nil {
			break
		}

		args, err := ec.field_Mutation_createDiscountOffer_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.CreateDiscountOffer(childComplexity, args["input"].(ent.CreateDiscountOfferInput)), true

	case "Mutation.createLinkToken":
		if e.complexity.Mutation.CreateLinkToken == nil {
			break
		}

		args, err := ec.field_Mutation_createLinkToken_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.CreateLinkToken(childComplexity, args["input"].(model.CreateLinkTokenParams)), true

	case "Mutation.createMerchant":
		if e.complexity.Mutation.CreateMerchant == nil {
			break
		}

		args, err := ec.field_Mutation_createMerchant_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.CreateMerchant(childComplexity, args["input"].(ent.CreateMerchantInput)), true

	case "Mutation.exchangeAuthTokenForUserProfile":
		if e.complexity.Mutation.ExchangeAuthTokenForUserProfile == nil {
			break
		}

		args, err := ec.field_Mutation_exchangeAuthTokenForUserProfile_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.ExchangeAuthTokenForUserProfile(childComplexity, args["input"].(model.ExchangeAuthTokenForUserProfileInput)), true

	case "Mutation.exchangePublicToken":
		if e.complexity.Mutation.ExchangePublicToken == nil {
			break
		}

		args, err := ec.field_Mutation_exchangePublicToken_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.ExchangePublicToken(childComplexity, args["input"].(model.ExchangePublicTokenParams)), true

	case "Mutation.markNotificationsAsCheckedInApp":
		if e.complexity.Mutation.MarkNotificationsAsCheckedInApp == nil {
			break
		}

		args, err := ec.field_Mutation_markNotificationsAsCheckedInApp_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.MarkNotificationsAsCheckedInApp(childComplexity, args["ids"].([]int)), true

	case "Mutation.setNotificationChannels":
		if e.complexity.Mutation.SetNotificationChannels == nil {
			break
		}

		args, err := ec.field_Mutation_setNotificationChannels_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.SetNotificationChannels(childComplexity, args["userID"].(int), args["notificationChannel"].([]usernotificationchannelpreferences.Chanel)), true

	case "Mutation.setOfferFrequency":
		if e.complexity.Mutation.SetOfferFrequency == nil {
			break
		}

		args, err := ec.field_Mutation_setOfferFrequency_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.SetOfferFrequency(childComplexity, args["userID"].(int), args["frequency"].(user.OfferFrequency)), true

	case "Mutation.setSpendingCategories":
		if e.complexity.Mutation.SetSpendingCategories == nil {
			break
		}

		args, err := ec.field_Mutation_setSpendingCategories_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.SetSpendingCategories(childComplexity, args["userID"].(int), args["spendingCategoryIDs"].([]int)), true

	case "Mutation.updateUser":
		if e.complexity.Mutation.UpdateUser == nil {
			break
		}

		args, err := ec.field_Mutation_updateUser_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.UpdateUser(childComplexity, args["id"].(int), args["input"].(*ent.UpdateUserInput)), true

	case "Notification.checkedInApp":
		if e.complexity.Notification.CheckedInApp == nil {
			break
		}

		return e.complexity.Notification.CheckedInApp(childComplexity), true

	case "Notification.createdAt":
		if e.complexity.Notification.CreatedAt == nil {
			break
		}

		return e.complexity.Notification.CreatedAt(childComplexity), true

	case "Notification.id":
		if e.complexity.Notification.ID == nil {
			break
		}

		return e.complexity.Notification.ID(childComplexity), true

	case "Notification.includedInAggregatedOfferAt":
		if e.complexity.Notification.IncludedInAggregatedOfferAt == nil {
			break
		}

		return e.complexity.Notification.IncludedInAggregatedOfferAt(childComplexity), true

	case "Notification.notificationDiscountOffer":
		if e.complexity.Notification.NotificationDiscountOffer == nil {
			break
		}

		return e.complexity.Notification.NotificationDiscountOffer(childComplexity), true

	case "Notification.notificationRecipient":
		if e.complexity.Notification.NotificationRecipient == nil {
			break
		}

		return e.complexity.Notification.NotificationRecipient(childComplexity), true

	case "Notification.type":
		if e.complexity.Notification.Type == nil {
			break
		}

		return e.complexity.Notification.Type(childComplexity), true

	case "NotificationConnection.edges":
		if e.complexity.NotificationConnection.Edges == nil {
			break
		}

		return e.complexity.NotificationConnection.Edges(childComplexity), true

	case "NotificationConnection.pageInfo":
		if e.complexity.NotificationConnection.PageInfo == nil {
			break
		}

		return e.complexity.NotificationConnection.PageInfo(childComplexity), true

	case "NotificationConnection.totalCount":
		if e.complexity.NotificationConnection.TotalCount == nil {
			break
		}

		return e.complexity.NotificationConnection.TotalCount(childComplexity), true

	case "NotificationEdge.cursor":
		if e.complexity.NotificationEdge.Cursor == nil {
			break
		}

		return e.complexity.NotificationEdge.Cursor(childComplexity), true

	case "NotificationEdge.node":
		if e.complexity.NotificationEdge.Node == nil {
			break
		}

		return e.complexity.NotificationEdge.Node(childComplexity), true

	case "PageInfo.endCursor":
		if e.complexity.PageInfo.EndCursor == nil {
			break
		}

		return e.complexity.PageInfo.EndCursor(childComplexity), true

	case "PageInfo.hasNextPage":
		if e.complexity.PageInfo.HasNextPage == nil {
			break
		}

		return e.complexity.PageInfo.HasNextPage(childComplexity), true

	case "PageInfo.hasPreviousPage":
		if e.complexity.PageInfo.HasPreviousPage == nil {
			break
		}

		return e.complexity.PageInfo.HasPreviousPage(childComplexity), true

	case "PageInfo.startCursor":
		if e.complexity.PageInfo.StartCursor == nil {
			break
		}

		return e.complexity.PageInfo.StartCursor(childComplexity), true

	case "PlaidAccountBalances.available":
		if e.complexity.PlaidAccountBalances.Available == nil {
			break
		}

		return e.complexity.PlaidAccountBalances.Available(childComplexity), true

	case "PlaidAccountBalances.current":
		if e.complexity.PlaidAccountBalances.Current == nil {
			break
		}

		return e.complexity.PlaidAccountBalances.Current(childComplexity), true

	case "PlaidAccountBalances.isoCurrencyCode":
		if e.complexity.PlaidAccountBalances.IsoCurrencyCode == nil {
			break
		}

		return e.complexity.PlaidAccountBalances.IsoCurrencyCode(childComplexity), true

	case "PlaidAccountInfo.accountId":
		if e.complexity.PlaidAccountInfo.AccountID == nil {
			break
		}

		return e.complexity.PlaidAccountInfo.AccountID(childComplexity), true

	case "PlaidAccountInfo.balances":
		if e.complexity.PlaidAccountInfo.Balances == nil {
			break
		}

		return e.complexity.PlaidAccountInfo.Balances(childComplexity), true

	case "PlaidAccountInfo.mask":
		if e.complexity.PlaidAccountInfo.Mask == nil {
			break
		}

		return e.complexity.PlaidAccountInfo.Mask(childComplexity), true

	case "PlaidAccountInfo.name":
		if e.complexity.PlaidAccountInfo.Name == nil {
			break
		}

		return e.complexity.PlaidAccountInfo.Name(childComplexity), true

	case "PlaidAccountInfo.officialName":
		if e.complexity.PlaidAccountInfo.OfficialName == nil {
			break
		}

		return e.complexity.PlaidAccountInfo.OfficialName(childComplexity), true

	case "PlaidAccountInfo.transactions":
		if e.complexity.PlaidAccountInfo.Transactions == nil {
			break
		}

		args, err := ec.field_PlaidAccountInfo_transactions_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.PlaidAccountInfo.Transactions(childComplexity, args["after"].(*ent.Cursor), args["first"].(*int), args["before"].(*ent.Cursor), args["last"].(*int), args["where"].(*ent.TransactionWhereInput), args["orderBy"].(*ent.TransactionOrder)), true

	case "PlaidAccountInfo.type":
		if e.complexity.PlaidAccountInfo.Type == nil {
			break
		}

		return e.complexity.PlaidAccountInfo.Type(childComplexity), true

	case "PlaidInstitution.accounts":
		if e.complexity.PlaidInstitution.Accounts == nil {
			break
		}

		return e.complexity.PlaidInstitution.Accounts(childComplexity), true

	case "PlaidInstitution.id":
		if e.complexity.PlaidInstitution.ID == nil {
			break
		}

		return e.complexity.PlaidInstitution.ID(childComplexity), true

	case "PlaidInstitution.institutionID":
		if e.complexity.PlaidInstitution.InstitutionID == nil {
			break
		}

		return e.complexity.PlaidInstitution.InstitutionID(childComplexity), true

	case "PlaidInstitution.name":
		if e.complexity.PlaidInstitution.Name == nil {
			break
		}

		return e.complexity.PlaidInstitution.Name(childComplexity), true

	case "PlaidInstitution.plaidItem":
		if e.complexity.PlaidInstitution.PlaidItem == nil {
			break
		}

		return e.complexity.PlaidInstitution.PlaidItem(childComplexity), true

	case "PlaidInstitutionAccount.accountID":
		if e.complexity.PlaidInstitutionAccount.AccountID == nil {
			break
		}

		return e.complexity.PlaidInstitutionAccount.AccountID(childComplexity), true

	case "PlaidInstitutionAccount.balanceAvailable":
		if e.complexity.PlaidInstitutionAccount.BalanceAvailable == nil {
			break
		}

		return e.complexity.PlaidInstitutionAccount.BalanceAvailable(childComplexity), true

	case "PlaidInstitutionAccount.balanceCurrent":
		if e.complexity.PlaidInstitutionAccount.BalanceCurrent == nil {
			break
		}

		return e.complexity.PlaidInstitutionAccount.BalanceCurrent(childComplexity), true

	case "PlaidInstitutionAccount.balanceIsoCurrencyCode":
		if e.complexity.PlaidInstitutionAccount.BalanceIsoCurrencyCode == nil {
			break
		}

		return e.complexity.PlaidInstitutionAccount.BalanceIsoCurrencyCode(childComplexity), true

	case "PlaidInstitutionAccount.id":
		if e.complexity.PlaidInstitutionAccount.ID == nil {
			break
		}

		return e.complexity.PlaidInstitutionAccount.ID(childComplexity), true

	case "PlaidInstitutionAccount.mask":
		if e.complexity.PlaidInstitutionAccount.Mask == nil {
			break
		}

		return e.complexity.PlaidInstitutionAccount.Mask(childComplexity), true

	case "PlaidInstitutionAccount.name":
		if e.complexity.PlaidInstitutionAccount.Name == nil {
			break
		}

		return e.complexity.PlaidInstitutionAccount.Name(childComplexity), true

	case "PlaidInstitutionAccount.officialName":
		if e.complexity.PlaidInstitutionAccount.OfficialName == nil {
			break
		}

		return e.complexity.PlaidInstitutionAccount.OfficialName(childComplexity), true

	case "PlaidInstitutionAccount.parentInstitution":
		if e.complexity.PlaidInstitutionAccount.ParentInstitution == nil {
			break
		}

		return e.complexity.PlaidInstitutionAccount.ParentInstitution(childComplexity), true

	case "PlaidInstitutionAccount.transactions":
		if e.complexity.PlaidInstitutionAccount.Transactions == nil {
			break
		}

		args, err := ec.field_PlaidInstitutionAccount_transactions_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.PlaidInstitutionAccount.Transactions(childComplexity, args["after"].(*ent.Cursor), args["first"].(*int), args["before"].(*ent.Cursor), args["last"].(*int), args["orderBy"].(*ent.TransactionOrder), args["where"].(*ent.TransactionWhereInput)), true

	case "PlaidInstitutionAccount.type":
		if e.complexity.PlaidInstitutionAccount.Type == nil {
			break
		}

		return e.complexity.PlaidInstitutionAccount.Type(childComplexity), true

	case "PlaidInstitutionAccountConnection.edges":
		if e.complexity.PlaidInstitutionAccountConnection.Edges == nil {
			break
		}

		return e.complexity.PlaidInstitutionAccountConnection.Edges(childComplexity), true

	case "PlaidInstitutionAccountConnection.pageInfo":
		if e.complexity.PlaidInstitutionAccountConnection.PageInfo == nil {
			break
		}

		return e.complexity.PlaidInstitutionAccountConnection.PageInfo(childComplexity), true

	case "PlaidInstitutionAccountConnection.totalCount":
		if e.complexity.PlaidInstitutionAccountConnection.TotalCount == nil {
			break
		}

		return e.complexity.PlaidInstitutionAccountConnection.TotalCount(childComplexity), true

	case "PlaidInstitutionAccountEdge.cursor":
		if e.complexity.PlaidInstitutionAccountEdge.Cursor == nil {
			break
		}

		return e.complexity.PlaidInstitutionAccountEdge.Cursor(childComplexity), true

	case "PlaidInstitutionAccountEdge.node":
		if e.complexity.PlaidInstitutionAccountEdge.Node == nil {
			break
		}

		return e.complexity.PlaidInstitutionAccountEdge.Node(childComplexity), true

	case "PlaidInstitutionConnection.edges":
		if e.complexity.PlaidInstitutionConnection.Edges == nil {
			break
		}

		return e.complexity.PlaidInstitutionConnection.Edges(childComplexity), true

	case "PlaidInstitutionConnection.pageInfo":
		if e.complexity.PlaidInstitutionConnection.PageInfo == nil {
			break
		}

		return e.complexity.PlaidInstitutionConnection.PageInfo(childComplexity), true

	case "PlaidInstitutionConnection.totalCount":
		if e.complexity.PlaidInstitutionConnection.TotalCount == nil {
			break
		}

		return e.complexity.PlaidInstitutionConnection.TotalCount(childComplexity), true

	case "PlaidInstitutionEdge.cursor":
		if e.complexity.PlaidInstitutionEdge.Cursor == nil {
			break
		}

		return e.complexity.PlaidInstitutionEdge.Cursor(childComplexity), true

	case "PlaidInstitutionEdge.node":
		if e.complexity.PlaidInstitutionEdge.Node == nil {
			break
		}

		return e.complexity.PlaidInstitutionEdge.Node(childComplexity), true

	case "PlaidItem.accessToken":
		if e.complexity.PlaidItem.AccessToken == nil {
			break
		}

		return e.complexity.PlaidItem.AccessToken(childComplexity), true

	case "PlaidItem.createdAt":
		if e.complexity.PlaidItem.CreatedAt == nil {
			break
		}

		return e.complexity.PlaidItem.CreatedAt(childComplexity), true

	case "PlaidItem.id":
		if e.complexity.PlaidItem.ID == nil {
			break
		}

		return e.complexity.PlaidItem.ID(childComplexity), true

	case "PlaidItem.institution":
		if e.complexity.PlaidItem.Institution == nil {
			break
		}

		return e.complexity.PlaidItem.Institution(childComplexity), true

	case "PlaidItem.itemID":
		if e.complexity.PlaidItem.ItemID == nil {
			break
		}

		return e.complexity.PlaidItem.ItemID(childComplexity), true

	case "PlaidItem.owner":
		if e.complexity.PlaidItem.Owner == nil {
			break
		}

		return e.complexity.PlaidItem.Owner(childComplexity), true

	case "PlaidItem.transactionSyncs":
		if e.complexity.PlaidItem.TransactionSyncs == nil {
			break
		}

		return e.complexity.PlaidItem.TransactionSyncs(childComplexity), true

	case "PlaidItem.updatedAt":
		if e.complexity.PlaidItem.UpdatedAt == nil {
			break
		}

		return e.complexity.PlaidItem.UpdatedAt(childComplexity), true

	case "PlaidItemConnection.edges":
		if e.complexity.PlaidItemConnection.Edges == nil {
			break
		}

		return e.complexity.PlaidItemConnection.Edges(childComplexity), true

	case "PlaidItemConnection.pageInfo":
		if e.complexity.PlaidItemConnection.PageInfo == nil {
			break
		}

		return e.complexity.PlaidItemConnection.PageInfo(childComplexity), true

	case "PlaidItemConnection.totalCount":
		if e.complexity.PlaidItemConnection.TotalCount == nil {
			break
		}

		return e.complexity.PlaidItemConnection.TotalCount(childComplexity), true

	case "PlaidItemEdge.cursor":
		if e.complexity.PlaidItemEdge.Cursor == nil {
			break
		}

		return e.complexity.PlaidItemEdge.Cursor(childComplexity), true

	case "PlaidItemEdge.node":
		if e.complexity.PlaidItemEdge.Node == nil {
			break
		}

		return e.complexity.PlaidItemEdge.Node(childComplexity), true

	case "Query.discountOffers":
		if e.complexity.Query.DiscountOffers == nil {
			break
		}

		args, err := ec.field_Query_discountOffers_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.DiscountOffers(childComplexity, args["after"].(*ent.Cursor), args["first"].(*int), args["before"].(*ent.Cursor), args["last"].(*int), args["orderBy"].(*ent.DiscountOfferOrder), args["where"].(*ent.DiscountOfferWhereInput)), true

	case "Query.node":
		if e.complexity.Query.Node == nil {
			break
		}

		args, err := ec.field_Query_node_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Node(childComplexity, args["id"].(int)), true

	case "Query.nodes":
		if e.complexity.Query.Nodes == nil {
			break
		}

		args, err := ec.field_Query_nodes_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Nodes(childComplexity, args["ids"].([]int)), true

	case "Query.notificationChannels":
		if e.complexity.Query.NotificationChannels == nil {
			break
		}

		args, err := ec.field_Query_notificationChannels_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.NotificationChannels(childComplexity, args["after"].(*ent.Cursor), args["first"].(*int), args["before"].(*ent.Cursor), args["last"].(*int), args["where"].(*ent.UserNotificationChannelPreferencesWhereInput)), true

	case "Query.notifications":
		if e.complexity.Query.Notifications == nil {
			break
		}

		args, err := ec.field_Query_notifications_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Notifications(childComplexity, args["after"].(*ent.Cursor), args["first"].(*int), args["before"].(*ent.Cursor), args["last"].(*int), args["orderBy"].(*ent.NotificationOrder), args["where"].(*ent.NotificationWhereInput)), true

	case "Query.plaidInstitutionAccounts":
		if e.complexity.Query.PlaidInstitutionAccounts == nil {
			break
		}

		args, err := ec.field_Query_plaidInstitutionAccounts_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.PlaidInstitutionAccounts(childComplexity, args["after"].(*ent.Cursor), args["first"].(*int), args["before"].(*ent.Cursor), args["last"].(*int), args["where"].(*ent.PlaidInstitutionAccountWhereInput)), true

	case "Query.plaidInstitutions":
		if e.complexity.Query.PlaidInstitutions == nil {
			break
		}

		args, err := ec.field_Query_plaidInstitutions_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.PlaidInstitutions(childComplexity, args["after"].(*ent.Cursor), args["first"].(*int), args["before"].(*ent.Cursor), args["last"].(*int), args["where"].(*ent.PlaidInstitutionWhereInput)), true

	case "Query.plaidItems":
		if e.complexity.Query.PlaidItems == nil {
			break
		}

		args, err := ec.field_Query_plaidItems_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.PlaidItems(childComplexity, args["after"].(*ent.Cursor), args["first"].(*int), args["before"].(*ent.Cursor), args["last"].(*int), args["where"].(*ent.PlaidItemWhereInput)), true

	case "Query.spendingCategories":
		if e.complexity.Query.SpendingCategories == nil {
			break
		}

		args, err := ec.field_Query_spendingCategories_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.SpendingCategories(childComplexity, args["after"].(*ent.Cursor), args["first"].(*int), args["before"].(*ent.Cursor), args["last"].(*int), args["where"].(*ent.SpendingCategoryWhereInput)), true

	case "Query.transactions":
		if e.complexity.Query.Transactions == nil {
			break
		}

		args, err := ec.field_Query_transactions_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Transactions(childComplexity, args["after"].(*ent.Cursor), args["first"].(*int), args["before"].(*ent.Cursor), args["last"].(*int), args["orderBy"].(*ent.TransactionOrder), args["where"].(*ent.TransactionWhereInput)), true

	case "SpendingCategory.categoryID":
		if e.complexity.SpendingCategory.CategoryID == nil {
			break
		}

		return e.complexity.SpendingCategory.CategoryID(childComplexity), true

	case "SpendingCategory.categoryTransactions":
		if e.complexity.SpendingCategory.CategoryTransactions == nil {
			break
		}

		return e.complexity.SpendingCategory.CategoryTransactions(childComplexity), true

	case "SpendingCategory.createdAt":
		if e.complexity.SpendingCategory.CreatedAt == nil {
			break
		}

		return e.complexity.SpendingCategory.CreatedAt(childComplexity), true

	case "SpendingCategory.id":
		if e.complexity.SpendingCategory.ID == nil {
			break
		}

		return e.complexity.SpendingCategory.ID(childComplexity), true

	case "SpendingCategory.interestedUsers":
		if e.complexity.SpendingCategory.InterestedUsers == nil {
			break
		}

		return e.complexity.SpendingCategory.InterestedUsers(childComplexity), true

	case "SpendingCategory.name":
		if e.complexity.SpendingCategory.Name == nil {
			break
		}

		return e.complexity.SpendingCategory.Name(childComplexity), true

	case "SpendingCategoryConnection.edges":
		if e.complexity.SpendingCategoryConnection.Edges == nil {
			break
		}

		return e.complexity.SpendingCategoryConnection.Edges(childComplexity), true

	case "SpendingCategoryConnection.pageInfo":
		if e.complexity.SpendingCategoryConnection.PageInfo == nil {
			break
		}

		return e.complexity.SpendingCategoryConnection.PageInfo(childComplexity), true

	case "SpendingCategoryConnection.totalCount":
		if e.complexity.SpendingCategoryConnection.TotalCount == nil {
			break
		}

		return e.complexity.SpendingCategoryConnection.TotalCount(childComplexity), true

	case "SpendingCategoryEdge.cursor":
		if e.complexity.SpendingCategoryEdge.Cursor == nil {
			break
		}

		return e.complexity.SpendingCategoryEdge.Cursor(childComplexity), true

	case "SpendingCategoryEdge.node":
		if e.complexity.SpendingCategoryEdge.Node == nil {
			break
		}

		return e.complexity.SpendingCategoryEdge.Node(childComplexity), true

	case "Subscription.notification":
		if e.complexity.Subscription.Notification == nil {
			break
		}

		args, err := ec.field_Subscription_notification_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Subscription.Notification(childComplexity, args["ownerID"].(int)), true

	case "Transaction.accountOwner":
		if e.complexity.Transaction.AccountOwner == nil {
			break
		}

		return e.complexity.Transaction.AccountOwner(childComplexity), true

	case "Transaction.amount":
		if e.complexity.Transaction.Amount == nil {
			break
		}

		return e.complexity.Transaction.Amount(childComplexity), true

	case "Transaction.authorizedDate":
		if e.complexity.Transaction.AuthorizedDate == nil {
			break
		}

		return e.complexity.Transaction.AuthorizedDate(childComplexity), true

	case "Transaction.authorizedDatetime":
		if e.complexity.Transaction.AuthorizedDatetime == nil {
			break
		}

		return e.complexity.Transaction.AuthorizedDatetime(childComplexity), true

	case "Transaction.category":
		if e.complexity.Transaction.Category == nil {
			break
		}

		return e.complexity.Transaction.Category(childComplexity), true

	case "Transaction.categoryID":
		if e.complexity.Transaction.CategoryID == nil {
			break
		}

		return e.complexity.Transaction.CategoryID(childComplexity), true

	case "Transaction.checkNumber":
		if e.complexity.Transaction.CheckNumber == nil {
			break
		}

		return e.complexity.Transaction.CheckNumber(childComplexity), true

	case "Transaction.createdAt":
		if e.complexity.Transaction.CreatedAt == nil {
			break
		}

		return e.complexity.Transaction.CreatedAt(childComplexity), true

	case "Transaction.date":
		if e.complexity.Transaction.Date == nil {
			break
		}

		return e.complexity.Transaction.Date(childComplexity), true

	case "Transaction.datetime":
		if e.complexity.Transaction.Datetime == nil {
			break
		}

		return e.complexity.Transaction.Datetime(childComplexity), true

	case "Transaction.financialAccountID":
		if e.complexity.Transaction.FinancialAccountID == nil {
			break
		}

		return e.complexity.Transaction.FinancialAccountID(childComplexity), true

	case "Transaction.id":
		if e.complexity.Transaction.ID == nil {
			break
		}

		return e.complexity.Transaction.ID(childComplexity), true

	case "Transaction.institutionAccount":
		if e.complexity.Transaction.InstitutionAccount == nil {
			break
		}

		return e.complexity.Transaction.InstitutionAccount(childComplexity), true

	case "Transaction.isoCurrencyCode":
		if e.complexity.Transaction.IsoCurrencyCode == nil {
			break
		}

		return e.complexity.Transaction.IsoCurrencyCode(childComplexity), true

	case "Transaction.locationAddress":
		if e.complexity.Transaction.LocationAddress == nil {
			break
		}

		return e.complexity.Transaction.LocationAddress(childComplexity), true

	case "Transaction.locationCity":
		if e.complexity.Transaction.LocationCity == nil {
			break
		}

		return e.complexity.Transaction.LocationCity(childComplexity), true

	case "Transaction.locationLat":
		if e.complexity.Transaction.LocationLat == nil {
			break
		}

		return e.complexity.Transaction.LocationLat(childComplexity), true

	case "Transaction.locationLon":
		if e.complexity.Transaction.LocationLon == nil {
			break
		}

		return e.complexity.Transaction.LocationLon(childComplexity), true

	case "Transaction.locationPostalCode":
		if e.complexity.Transaction.LocationPostalCode == nil {
			break
		}

		return e.complexity.Transaction.LocationPostalCode(childComplexity), true

	case "Transaction.locationRegion":
		if e.complexity.Transaction.LocationRegion == nil {
			break
		}

		return e.complexity.Transaction.LocationRegion(childComplexity), true

	case "Transaction.locationStoreNumber":
		if e.complexity.Transaction.LocationStoreNumber == nil {
			break
		}

		return e.complexity.Transaction.LocationStoreNumber(childComplexity), true

	case "Transaction.merchantName":
		if e.complexity.Transaction.MerchantName == nil {
			break
		}

		return e.complexity.Transaction.MerchantName(childComplexity), true

	case "Transaction.name":
		if e.complexity.Transaction.Name == nil {
			break
		}

		return e.complexity.Transaction.Name(childComplexity), true

	case "Transaction.paymentChannel":
		if e.complexity.Transaction.PaymentChannel == nil {
			break
		}

		return e.complexity.Transaction.PaymentChannel(childComplexity), true

	case "Transaction.pending":
		if e.complexity.Transaction.Pending == nil {
			break
		}

		return e.complexity.Transaction.Pending(childComplexity), true

	case "Transaction.pendingTransactionID":
		if e.complexity.Transaction.PendingTransactionID == nil {
			break
		}

		return e.complexity.Transaction.PendingTransactionID(childComplexity), true

	case "Transaction.transactionCategories":
		if e.complexity.Transaction.TransactionCategories == nil {
			break
		}

		return e.complexity.Transaction.TransactionCategories(childComplexity), true

	case "Transaction.transactionCode":
		if e.complexity.Transaction.TransactionCode == nil {
			break
		}

		return e.complexity.Transaction.TransactionCode(childComplexity), true

	case "Transaction.transactionID":
		if e.complexity.Transaction.TransactionID == nil {
			break
		}

		return e.complexity.Transaction.TransactionID(childComplexity), true

	case "Transaction.unofficialCurrencyCode":
		if e.complexity.Transaction.UnofficialCurrencyCode == nil {
			break
		}

		return e.complexity.Transaction.UnofficialCurrencyCode(childComplexity), true

	case "TransactionConnection.edges":
		if e.complexity.TransactionConnection.Edges == nil {
			break
		}

		return e.complexity.TransactionConnection.Edges(childComplexity), true

	case "TransactionConnection.pageInfo":
		if e.complexity.TransactionConnection.PageInfo == nil {
			break
		}

		return e.complexity.TransactionConnection.PageInfo(childComplexity), true

	case "TransactionConnection.totalCount":
		if e.complexity.TransactionConnection.TotalCount == nil {
			break
		}

		return e.complexity.TransactionConnection.TotalCount(childComplexity), true

	case "TransactionEdge.cursor":
		if e.complexity.TransactionEdge.Cursor == nil {
			break
		}

		return e.complexity.TransactionEdge.Cursor(childComplexity), true

	case "TransactionEdge.node":
		if e.complexity.TransactionEdge.Node == nil {
			break
		}

		return e.complexity.TransactionEdge.Node(childComplexity), true

	case "TransactionSync.createdAt":
		if e.complexity.TransactionSync.CreatedAt == nil {
			break
		}

		return e.complexity.TransactionSync.CreatedAt(childComplexity), true

	case "TransactionSync.cursor":
		if e.complexity.TransactionSync.Cursor == nil {
			break
		}

		return e.complexity.TransactionSync.Cursor(childComplexity), true

	case "TransactionSync.id":
		if e.complexity.TransactionSync.ID == nil {
			break
		}

		return e.complexity.TransactionSync.ID(childComplexity), true

	case "TransactionSync.item":
		if e.complexity.TransactionSync.Item == nil {
			break
		}

		return e.complexity.TransactionSync.Item(childComplexity), true

	case "User.availableDiscountOffers":
		if e.complexity.User.AvailableDiscountOffers == nil {
			break
		}

		return e.complexity.User.AvailableDiscountOffers(childComplexity), true

	case "User.homeCity":
		if e.complexity.User.HomeCity == nil {
			break
		}

		return e.complexity.User.HomeCity(childComplexity), true

	case "User.homeCountry":
		if e.complexity.User.HomeCountry == nil {
			break
		}

		return e.complexity.User.HomeCountry(childComplexity), true

	case "User.homeState":
		if e.complexity.User.HomeState == nil {
			break
		}

		return e.complexity.User.HomeState(childComplexity), true

	case "User.id":
		if e.complexity.User.ID == nil {
			break
		}

		return e.complexity.User.ID(childComplexity), true

	case "User.identityProviderID":
		if e.complexity.User.IdentityProviderID == nil {
			break
		}

		return e.complexity.User.IdentityProviderID(childComplexity), true

	case "User.notificationChannels":
		if e.complexity.User.NotificationChannels == nil {
			break
		}

		return e.complexity.User.NotificationChannels(childComplexity), true

	case "User.notifications":
		if e.complexity.User.Notifications == nil {
			break
		}

		return e.complexity.User.Notifications(childComplexity), true

	case "User.offerFrequency":
		if e.complexity.User.OfferFrequency == nil {
			break
		}

		return e.complexity.User.OfferFrequency(childComplexity), true

	case "User.plaidItems":
		if e.complexity.User.PlaidItems == nil {
			break
		}

		return e.complexity.User.PlaidItems(childComplexity), true

	case "User.spendingCategories":
		if e.complexity.User.SpendingCategories == nil {
			break
		}

		return e.complexity.User.SpendingCategories(childComplexity), true

	case "UserNotificationChannelPreferences.chanel":
		if e.complexity.UserNotificationChannelPreferences.Chanel == nil {
			break
		}

		return e.complexity.UserNotificationChannelPreferences.Chanel(childComplexity), true

	case "UserNotificationChannelPreferences.chanelUsers":
		if e.complexity.UserNotificationChannelPreferences.ChanelUsers == nil {
			break
		}

		return e.complexity.UserNotificationChannelPreferences.ChanelUsers(childComplexity), true

	case "UserNotificationChannelPreferences.id":
		if e.complexity.UserNotificationChannelPreferences.ID == nil {
			break
		}

		return e.complexity.UserNotificationChannelPreferences.ID(childComplexity), true

	case "UserNotificationChannelPreferencesConnection.edges":
		if e.complexity.UserNotificationChannelPreferencesConnection.Edges == nil {
			break
		}

		return e.complexity.UserNotificationChannelPreferencesConnection.Edges(childComplexity), true

	case "UserNotificationChannelPreferencesConnection.pageInfo":
		if e.complexity.UserNotificationChannelPreferencesConnection.PageInfo == nil {
			break
		}

		return e.complexity.UserNotificationChannelPreferencesConnection.PageInfo(childComplexity), true

	case "UserNotificationChannelPreferencesConnection.totalCount":
		if e.complexity.UserNotificationChannelPreferencesConnection.TotalCount == nil {
			break
		}

		return e.complexity.UserNotificationChannelPreferencesConnection.TotalCount(childComplexity), true

	case "UserNotificationChannelPreferencesEdge.cursor":
		if e.complexity.UserNotificationChannelPreferencesEdge.Cursor == nil {
			break
		}

		return e.complexity.UserNotificationChannelPreferencesEdge.Cursor(childComplexity), true

	case "UserNotificationChannelPreferencesEdge.node":
		if e.complexity.UserNotificationChannelPreferencesEdge.Node == nil {
			break
		}

		return e.complexity.UserNotificationChannelPreferencesEdge.Node(childComplexity), true

	}
	return 0, false
}

func (e *executableSchema) Exec(ctx context.Context) graphql.ResponseHandler {
	rc := graphql.GetOperationContext(ctx)
	ec := executionContext{rc, e}
	inputUnmarshalMap := graphql.BuildUnmarshalerMap(
		ec.unmarshalInputCreateDiscountOfferInput,
		ec.unmarshalInputCreateLinkTokenParams,
		ec.unmarshalInputCreateMerchantInput,
		ec.unmarshalInputCreateUserInput,
		ec.unmarshalInputDiscountOfferOrder,
		ec.unmarshalInputDiscountOfferWhereInput,
		ec.unmarshalInputExchangeAuthTokenForUserProfileInput,
		ec.unmarshalInputExchangePublicTokenParams,
		ec.unmarshalInputMerchantWhereInput,
		ec.unmarshalInputNotificationOrder,
		ec.unmarshalInputNotificationWhereInput,
		ec.unmarshalInputPlaidInstitutionAccountWhereInput,
		ec.unmarshalInputPlaidInstitutionWhereInput,
		ec.unmarshalInputPlaidItemOrder,
		ec.unmarshalInputPlaidItemWhereInput,
		ec.unmarshalInputSpendingCategoryWhereInput,
		ec.unmarshalInputTransactionOrder,
		ec.unmarshalInputTransactionSyncWhereInput,
		ec.unmarshalInputTransactionWhereInput,
		ec.unmarshalInputUpdateUserInput,
		ec.unmarshalInputUpdateUserNotificationChannelPreferencesInput,
		ec.unmarshalInputUserNotificationChannelPreferencesWhereInput,
		ec.unmarshalInputUserWhereInput,
	)
	first := true

	switch rc.Operation.Operation {
	case ast.Query:
		return func(ctx context.Context) *graphql.Response {
			if !first {
				return nil
			}
			first = false
			ctx = graphql.WithUnmarshalerMap(ctx, inputUnmarshalMap)
			data := ec._Query(ctx, rc.Operation.SelectionSet)
			var buf bytes.Buffer
			data.MarshalGQL(&buf)

			return &graphql.Response{
				Data: buf.Bytes(),
			}
		}
	case ast.Mutation:
		return func(ctx context.Context) *graphql.Response {
			if !first {
				return nil
			}
			first = false
			ctx = graphql.WithUnmarshalerMap(ctx, inputUnmarshalMap)
			data := ec._Mutation(ctx, rc.Operation.SelectionSet)
			var buf bytes.Buffer
			data.MarshalGQL(&buf)

			return &graphql.Response{
				Data: buf.Bytes(),
			}
		}
	case ast.Subscription:
		next := ec._Subscription(ctx, rc.Operation.SelectionSet)

		var buf bytes.Buffer
		return func(ctx context.Context) *graphql.Response {
			buf.Reset()
			data := next(ctx)

			if data == nil {
				return nil
			}
			data.MarshalGQL(&buf)

			return &graphql.Response{
				Data: buf.Bytes(),
			}
		}

	default:
		return graphql.OneShot(graphql.ErrorResponse(ctx, "unsupported GraphQL operation"))
	}
}

type executionContext struct {
	*graphql.OperationContext
	*executableSchema
}

func (ec *executionContext) introspectSchema() (*introspection.Schema, error) {
	if ec.DisableIntrospection {
		return nil, errors.New("introspection disabled")
	}
	return introspection.WrapSchema(parsedSchema), nil
}

func (ec *executionContext) introspectType(name string) (*introspection.Type, error) {
	if ec.DisableIntrospection {
		return nil, errors.New("introspection disabled")
	}
	return introspection.WrapTypeFromDef(parsedSchema, parsedSchema.Types[name]), nil
}

var sources = []*ast.Source{
	{Name: "../api/graphql/discount_offer.graphql", Input: `extend type Query {
    discountOffers(
        after: Cursor
        first: Int
        before: Cursor
        last: Int
        orderBy: DiscountOfferOrder
        where: DiscountOfferWhereInput
    ): DiscountOfferConnection!
}

#extend type Subscription {
#    discountOffers(recipientID: ID!): DiscountOffer!
#}

extend type Mutation {
    createDiscountOffer(input: CreateDiscountOfferInput!): DiscountOffer!
}
`, BuiltIn: false},
	{Name: "../api/graphql/ent.graphql", Input: `directive @goField(forceResolver: Boolean, name: String) on FIELD_DEFINITION | INPUT_FIELD_DEFINITION
directive @goModel(model: String, models: [String!]) on OBJECT | INPUT_OBJECT | SCALAR | ENUM | INTERFACE | UNION
"""
CreateDiscountOfferInput is used for create DiscountOffer object.
Input was generated by ent.
"""
input CreateDiscountOfferInput {
  amount: Int!
  type: DiscountOfferType
  currency: String
  description: String!
  merchantSpecificIdentification: String!
  expiresAt: Time!
  ownerMerchantID: ID!
  discountEligibleUserIDs: [ID!]!
  discountOfferNotificationID: ID
}
"""
CreateMerchantInput is used for create Merchant object.
Input was generated by ent.
"""
input CreateMerchantInput {
  name: String!
  discountOfferIDs: [ID!]
}
"""
CreateUserInput is used for create User object.
Input was generated by ent.
"""
input CreateUserInput {
  identityProviderID: String
  offerFrequency: UserOfferFrequency
  homeCountry: String
  homeState: String
  homeCity: String
}
"""
Define a Relay Cursor type:
https://relay.dev/graphql/connections.htm#sec-Cursor
"""
scalar Cursor
type DiscountOffer implements Node {
  id: ID!
  amount: Int!
  type: DiscountOfferType!
  currency: String
  description: String!
  merchantSpecificIdentification: String!
  createdAt: Time!
  expiresAt: Time!
  ownerMerchant: Merchant!
  discountEligibleUsers: [User!]!
  discountOfferNotification: Notification
}
"""A connection to a list of items."""
type DiscountOfferConnection {
  """A list of edges."""
  edges: [DiscountOfferEdge]
  """Information to aid in pagination."""
  pageInfo: PageInfo!
  """Identifies the total count of items in the connection."""
  totalCount: Int!
}
"""An edge in a connection."""
type DiscountOfferEdge {
  """The item at the end of the edge."""
  node: DiscountOffer
  """A cursor for use in pagination."""
  cursor: Cursor!
}
"""Ordering options for DiscountOffer connections"""
input DiscountOfferOrder {
  """The ordering direction."""
  direction: OrderDirection! = ASC
  """The field by which to order DiscountOffers."""
  field: DiscountOfferOrderField!
}
"""Properties by which DiscountOffer connections can be ordered."""
enum DiscountOfferOrderField {
  CREATED_AT
}
"""DiscountOfferType is enum for the field type"""
enum DiscountOfferType @goModel(model: "wallit/ent/discountoffer.Type") {
  FIXED_AMOUNT
  PERCENT_FROM_PRICE
}
"""
DiscountOfferWhereInput is used for filtering DiscountOffer objects.
Input was generated by ent.
"""
input DiscountOfferWhereInput {
  not: DiscountOfferWhereInput
  and: [DiscountOfferWhereInput!]
  or: [DiscountOfferWhereInput!]
  """id field predicates"""
  id: ID
  idNEQ: ID
  idIn: [ID!]
  idNotIn: [ID!]
  idGT: ID
  idGTE: ID
  idLT: ID
  idLTE: ID
  """amount field predicates"""
  amount: Int
  amountNEQ: Int
  amountIn: [Int!]
  amountNotIn: [Int!]
  amountGT: Int
  amountGTE: Int
  amountLT: Int
  amountLTE: Int
  """type field predicates"""
  type: DiscountOfferType
  typeNEQ: DiscountOfferType
  typeIn: [DiscountOfferType!]
  typeNotIn: [DiscountOfferType!]
  """currency field predicates"""
  currency: String
  currencyNEQ: String
  currencyIn: [String!]
  currencyNotIn: [String!]
  currencyGT: String
  currencyGTE: String
  currencyLT: String
  currencyLTE: String
  currencyContains: String
  currencyHasPrefix: String
  currencyHasSuffix: String
  currencyIsNil: Boolean
  currencyNotNil: Boolean
  currencyEqualFold: String
  currencyContainsFold: String
  """description field predicates"""
  description: String
  descriptionNEQ: String
  descriptionIn: [String!]
  descriptionNotIn: [String!]
  descriptionGT: String
  descriptionGTE: String
  descriptionLT: String
  descriptionLTE: String
  descriptionContains: String
  descriptionHasPrefix: String
  descriptionHasSuffix: String
  descriptionEqualFold: String
  descriptionContainsFold: String
  """merchant_specific_identification field predicates"""
  merchantSpecificIdentification: String
  merchantSpecificIdentificationNEQ: String
  merchantSpecificIdentificationIn: [String!]
  merchantSpecificIdentificationNotIn: [String!]
  merchantSpecificIdentificationGT: String
  merchantSpecificIdentificationGTE: String
  merchantSpecificIdentificationLT: String
  merchantSpecificIdentificationLTE: String
  merchantSpecificIdentificationContains: String
  merchantSpecificIdentificationHasPrefix: String
  merchantSpecificIdentificationHasSuffix: String
  merchantSpecificIdentificationEqualFold: String
  merchantSpecificIdentificationContainsFold: String
  """created_at field predicates"""
  createdAt: Time
  createdAtNEQ: Time
  createdAtIn: [Time!]
  createdAtNotIn: [Time!]
  createdAtGT: Time
  createdAtGTE: Time
  createdAtLT: Time
  createdAtLTE: Time
  """expires_at field predicates"""
  expiresAt: Time
  expiresAtNEQ: Time
  expiresAtIn: [Time!]
  expiresAtNotIn: [Time!]
  expiresAtGT: Time
  expiresAtGTE: Time
  expiresAtLT: Time
  expiresAtLTE: Time
  """owner_merchant edge predicates"""
  hasOwnerMerchant: Boolean
  hasOwnerMerchantWith: [MerchantWhereInput!]
  """discount_eligible_users edge predicates"""
  hasDiscountEligibleUsers: Boolean
  hasDiscountEligibleUsersWith: [UserWhereInput!]
  """discount_offer_notification edge predicates"""
  hasDiscountOfferNotification: Boolean
  hasDiscountOfferNotificationWith: [NotificationWhereInput!]
}
type Merchant implements Node {
  id: ID!
  name: String!
  discountOffers: [DiscountOffer!]
}
"""
MerchantWhereInput is used for filtering Merchant objects.
Input was generated by ent.
"""
input MerchantWhereInput {
  not: MerchantWhereInput
  and: [MerchantWhereInput!]
  or: [MerchantWhereInput!]
  """id field predicates"""
  id: ID
  idNEQ: ID
  idIn: [ID!]
  idNotIn: [ID!]
  idGT: ID
  idGTE: ID
  idLT: ID
  idLTE: ID
  """name field predicates"""
  name: String
  nameNEQ: String
  nameIn: [String!]
  nameNotIn: [String!]
  nameGT: String
  nameGTE: String
  nameLT: String
  nameLTE: String
  nameContains: String
  nameHasPrefix: String
  nameHasSuffix: String
  nameEqualFold: String
  nameContainsFold: String
  """discount_offers edge predicates"""
  hasDiscountOffers: Boolean
  hasDiscountOffersWith: [DiscountOfferWhereInput!]
}
"""
An object with an ID.
Follows the [Relay Global Object Identification Specification](https://relay.dev/graphql/objectidentification.htm)
"""
interface Node @goModel(model: "wallit/ent.Noder") {
  """The id of the object."""
  id: ID!
}
type Notification implements Node {
  id: ID!
  checkedInApp: Boolean!
  type: NotificationType!
  createdAt: Time!
  includedInAggregatedOfferAt: Time
  notificationRecipient: User!
  notificationDiscountOffer: DiscountOffer
}
"""A connection to a list of items."""
type NotificationConnection {
  """A list of edges."""
  edges: [NotificationEdge]
  """Information to aid in pagination."""
  pageInfo: PageInfo!
  """Identifies the total count of items in the connection."""
  totalCount: Int!
}
"""An edge in a connection."""
type NotificationEdge {
  """The item at the end of the edge."""
  node: Notification
  """A cursor for use in pagination."""
  cursor: Cursor!
}
"""Ordering options for Notification connections"""
input NotificationOrder {
  """The ordering direction."""
  direction: OrderDirection! = ASC
  """The field by which to order Notifications."""
  field: NotificationOrderField!
}
"""Properties by which Notification connections can be ordered."""
enum NotificationOrderField {
  CREATED_AT
}
"""NotificationType is enum for the field type"""
enum NotificationType @goModel(model: "wallit/ent/notification.Type") {
  OFFER
  INSIGHTS
}
"""
NotificationWhereInput is used for filtering Notification objects.
Input was generated by ent.
"""
input NotificationWhereInput {
  not: NotificationWhereInput
  and: [NotificationWhereInput!]
  or: [NotificationWhereInput!]
  """id field predicates"""
  id: ID
  idNEQ: ID
  idIn: [ID!]
  idNotIn: [ID!]
  idGT: ID
  idGTE: ID
  idLT: ID
  idLTE: ID
  """checked_in_app field predicates"""
  checkedInApp: Boolean
  checkedInAppNEQ: Boolean
  """type field predicates"""
  type: NotificationType
  typeNEQ: NotificationType
  typeIn: [NotificationType!]
  typeNotIn: [NotificationType!]
  """created_at field predicates"""
  createdAt: Time
  createdAtNEQ: Time
  createdAtIn: [Time!]
  createdAtNotIn: [Time!]
  createdAtGT: Time
  createdAtGTE: Time
  createdAtLT: Time
  createdAtLTE: Time
  """included_in_aggregated_offer_at field predicates"""
  includedInAggregatedOfferAt: Time
  includedInAggregatedOfferAtNEQ: Time
  includedInAggregatedOfferAtIn: [Time!]
  includedInAggregatedOfferAtNotIn: [Time!]
  includedInAggregatedOfferAtGT: Time
  includedInAggregatedOfferAtGTE: Time
  includedInAggregatedOfferAtLT: Time
  includedInAggregatedOfferAtLTE: Time
  includedInAggregatedOfferAtIsNil: Boolean
  includedInAggregatedOfferAtNotNil: Boolean
  """notification_recipient edge predicates"""
  hasNotificationRecipient: Boolean
  hasNotificationRecipientWith: [UserWhereInput!]
  """notification_discount_offer edge predicates"""
  hasNotificationDiscountOffer: Boolean
  hasNotificationDiscountOfferWith: [DiscountOfferWhereInput!]
}
"""Possible directions in which to order a list of items when provided an ` + "`" + `orderBy` + "`" + ` argument."""
enum OrderDirection {
  """Specifies an ascending order for a given ` + "`" + `orderBy` + "`" + ` argument."""
  ASC
  """Specifies a descending order for a given ` + "`" + `orderBy` + "`" + ` argument."""
  DESC
}
"""
Information about pagination in a connection.
https://relay.dev/graphql/connections.htm#sec-undefined.PageInfo
"""
type PageInfo {
  """When paginating forwards, are there more items?"""
  hasNextPage: Boolean!
  """When paginating backwards, are there more items?"""
  hasPreviousPage: Boolean!
  """When paginating backwards, the cursor to continue."""
  startCursor: Cursor
  """When paginating forwards, the cursor to continue."""
  endCursor: Cursor
}
type PlaidInstitution implements Node {
  id: ID!
  institutionID: String!
  name: String!
  plaidItem: PlaidItem
  accounts: [PlaidInstitutionAccount!]
}
type PlaidInstitutionAccount implements Node {
  id: ID!
  accountID: String!
  balanceAvailable: Float!
  balanceCurrent: Float!
  balanceIsoCurrencyCode: String!
  mask: String!
  name: String!
  officialName: String
  type: String!
  parentInstitution: PlaidInstitution
  transactions(
    """Returns the elements in the list that come after the specified cursor."""
    after: Cursor

    """Returns the first _n_ elements from the list."""
    first: Int

    """Returns the elements in the list that come before the specified cursor."""
    before: Cursor

    """Returns the last _n_ elements from the list."""
    last: Int

    """Ordering options for Transactions returned from the connection."""
    orderBy: TransactionOrder

    """Filtering options for Transactions returned from the connection."""
    where: TransactionWhereInput
  ): TransactionConnection!
}
"""A connection to a list of items."""
type PlaidInstitutionAccountConnection {
  """A list of edges."""
  edges: [PlaidInstitutionAccountEdge]
  """Information to aid in pagination."""
  pageInfo: PageInfo!
  """Identifies the total count of items in the connection."""
  totalCount: Int!
}
"""An edge in a connection."""
type PlaidInstitutionAccountEdge {
  """The item at the end of the edge."""
  node: PlaidInstitutionAccount
  """A cursor for use in pagination."""
  cursor: Cursor!
}
"""
PlaidInstitutionAccountWhereInput is used for filtering PlaidInstitutionAccount objects.
Input was generated by ent.
"""
input PlaidInstitutionAccountWhereInput {
  not: PlaidInstitutionAccountWhereInput
  and: [PlaidInstitutionAccountWhereInput!]
  or: [PlaidInstitutionAccountWhereInput!]
  """id field predicates"""
  id: ID
  idNEQ: ID
  idIn: [ID!]
  idNotIn: [ID!]
  idGT: ID
  idGTE: ID
  idLT: ID
  idLTE: ID
  """account_id field predicates"""
  accountID: String
  accountIDNEQ: String
  accountIDIn: [String!]
  accountIDNotIn: [String!]
  accountIDGT: String
  accountIDGTE: String
  accountIDLT: String
  accountIDLTE: String
  accountIDContains: String
  accountIDHasPrefix: String
  accountIDHasSuffix: String
  accountIDEqualFold: String
  accountIDContainsFold: String
  """balance_available field predicates"""
  balanceAvailable: Float
  balanceAvailableNEQ: Float
  balanceAvailableIn: [Float!]
  balanceAvailableNotIn: [Float!]
  balanceAvailableGT: Float
  balanceAvailableGTE: Float
  balanceAvailableLT: Float
  balanceAvailableLTE: Float
  """balance_current field predicates"""
  balanceCurrent: Float
  balanceCurrentNEQ: Float
  balanceCurrentIn: [Float!]
  balanceCurrentNotIn: [Float!]
  balanceCurrentGT: Float
  balanceCurrentGTE: Float
  balanceCurrentLT: Float
  balanceCurrentLTE: Float
  """balance_iso_currency_code field predicates"""
  balanceIsoCurrencyCode: String
  balanceIsoCurrencyCodeNEQ: String
  balanceIsoCurrencyCodeIn: [String!]
  balanceIsoCurrencyCodeNotIn: [String!]
  balanceIsoCurrencyCodeGT: String
  balanceIsoCurrencyCodeGTE: String
  balanceIsoCurrencyCodeLT: String
  balanceIsoCurrencyCodeLTE: String
  balanceIsoCurrencyCodeContains: String
  balanceIsoCurrencyCodeHasPrefix: String
  balanceIsoCurrencyCodeHasSuffix: String
  balanceIsoCurrencyCodeEqualFold: String
  balanceIsoCurrencyCodeContainsFold: String
  """mask field predicates"""
  mask: String
  maskNEQ: String
  maskIn: [String!]
  maskNotIn: [String!]
  maskGT: String
  maskGTE: String
  maskLT: String
  maskLTE: String
  maskContains: String
  maskHasPrefix: String
  maskHasSuffix: String
  maskEqualFold: String
  maskContainsFold: String
  """name field predicates"""
  name: String
  nameNEQ: String
  nameIn: [String!]
  nameNotIn: [String!]
  nameGT: String
  nameGTE: String
  nameLT: String
  nameLTE: String
  nameContains: String
  nameHasPrefix: String
  nameHasSuffix: String
  nameEqualFold: String
  nameContainsFold: String
  """official_name field predicates"""
  officialName: String
  officialNameNEQ: String
  officialNameIn: [String!]
  officialNameNotIn: [String!]
  officialNameGT: String
  officialNameGTE: String
  officialNameLT: String
  officialNameLTE: String
  officialNameContains: String
  officialNameHasPrefix: String
  officialNameHasSuffix: String
  officialNameIsNil: Boolean
  officialNameNotNil: Boolean
  officialNameEqualFold: String
  officialNameContainsFold: String
  """type field predicates"""
  type: String
  typeNEQ: String
  typeIn: [String!]
  typeNotIn: [String!]
  typeGT: String
  typeGTE: String
  typeLT: String
  typeLTE: String
  typeContains: String
  typeHasPrefix: String
  typeHasSuffix: String
  typeEqualFold: String
  typeContainsFold: String
  """parent_institution edge predicates"""
  hasParentInstitution: Boolean
  hasParentInstitutionWith: [PlaidInstitutionWhereInput!]
  """transactions edge predicates"""
  hasTransactions: Boolean
  hasTransactionsWith: [TransactionWhereInput!]
}
"""A connection to a list of items."""
type PlaidInstitutionConnection {
  """A list of edges."""
  edges: [PlaidInstitutionEdge]
  """Information to aid in pagination."""
  pageInfo: PageInfo!
  """Identifies the total count of items in the connection."""
  totalCount: Int!
}
"""An edge in a connection."""
type PlaidInstitutionEdge {
  """The item at the end of the edge."""
  node: PlaidInstitution
  """A cursor for use in pagination."""
  cursor: Cursor!
}
"""
PlaidInstitutionWhereInput is used for filtering PlaidInstitution objects.
Input was generated by ent.
"""
input PlaidInstitutionWhereInput {
  not: PlaidInstitutionWhereInput
  and: [PlaidInstitutionWhereInput!]
  or: [PlaidInstitutionWhereInput!]
  """id field predicates"""
  id: ID
  idNEQ: ID
  idIn: [ID!]
  idNotIn: [ID!]
  idGT: ID
  idGTE: ID
  idLT: ID
  idLTE: ID
  """institution_id field predicates"""
  institutionID: String
  institutionIDNEQ: String
  institutionIDIn: [String!]
  institutionIDNotIn: [String!]
  institutionIDGT: String
  institutionIDGTE: String
  institutionIDLT: String
  institutionIDLTE: String
  institutionIDContains: String
  institutionIDHasPrefix: String
  institutionIDHasSuffix: String
  institutionIDEqualFold: String
  institutionIDContainsFold: String
  """name field predicates"""
  name: String
  nameNEQ: String
  nameIn: [String!]
  nameNotIn: [String!]
  nameGT: String
  nameGTE: String
  nameLT: String
  nameLTE: String
  nameContains: String
  nameHasPrefix: String
  nameHasSuffix: String
  nameEqualFold: String
  nameContainsFold: String
  """plaid_item edge predicates"""
  hasPlaidItem: Boolean
  hasPlaidItemWith: [PlaidItemWhereInput!]
  """accounts edge predicates"""
  hasAccounts: Boolean
  hasAccountsWith: [PlaidInstitutionAccountWhereInput!]
}
type PlaidItem implements Node {
  id: ID!
  itemID: String!
  accessToken: String!
  createdAt: Time!
  updatedAt: Time!
  owner: User
  transactionSyncs: [TransactionSync!]
  institution: PlaidInstitution
}
"""A connection to a list of items."""
type PlaidItemConnection {
  """A list of edges."""
  edges: [PlaidItemEdge]
  """Information to aid in pagination."""
  pageInfo: PageInfo!
  """Identifies the total count of items in the connection."""
  totalCount: Int!
}
"""An edge in a connection."""
type PlaidItemEdge {
  """The item at the end of the edge."""
  node: PlaidItem
  """A cursor for use in pagination."""
  cursor: Cursor!
}
"""Ordering options for PlaidItem connections"""
input PlaidItemOrder {
  """The ordering direction."""
  direction: OrderDirection! = ASC
  """The field by which to order PlaidItems."""
  field: PlaidItemOrderField!
}
"""Properties by which PlaidItem connections can be ordered."""
enum PlaidItemOrderField {
  CREATED_AT
  UPDATED_AT
}
"""
PlaidItemWhereInput is used for filtering PlaidItem objects.
Input was generated by ent.
"""
input PlaidItemWhereInput {
  not: PlaidItemWhereInput
  and: [PlaidItemWhereInput!]
  or: [PlaidItemWhereInput!]
  """id field predicates"""
  id: ID
  idNEQ: ID
  idIn: [ID!]
  idNotIn: [ID!]
  idGT: ID
  idGTE: ID
  idLT: ID
  idLTE: ID
  """item_id field predicates"""
  itemID: String
  itemIDNEQ: String
  itemIDIn: [String!]
  itemIDNotIn: [String!]
  itemIDGT: String
  itemIDGTE: String
  itemIDLT: String
  itemIDLTE: String
  itemIDContains: String
  itemIDHasPrefix: String
  itemIDHasSuffix: String
  itemIDEqualFold: String
  itemIDContainsFold: String
  """access_token field predicates"""
  accessToken: String
  accessTokenNEQ: String
  accessTokenIn: [String!]
  accessTokenNotIn: [String!]
  accessTokenGT: String
  accessTokenGTE: String
  accessTokenLT: String
  accessTokenLTE: String
  accessTokenContains: String
  accessTokenHasPrefix: String
  accessTokenHasSuffix: String
  accessTokenEqualFold: String
  accessTokenContainsFold: String
  """created_at field predicates"""
  createdAt: Time
  createdAtNEQ: Time
  createdAtIn: [Time!]
  createdAtNotIn: [Time!]
  createdAtGT: Time
  createdAtGTE: Time
  createdAtLT: Time
  createdAtLTE: Time
  """updated_at field predicates"""
  updatedAt: Time
  updatedAtNEQ: Time
  updatedAtIn: [Time!]
  updatedAtNotIn: [Time!]
  updatedAtGT: Time
  updatedAtGTE: Time
  updatedAtLT: Time
  updatedAtLTE: Time
  """owner edge predicates"""
  hasOwner: Boolean
  hasOwnerWith: [UserWhereInput!]
  """transaction_syncs edge predicates"""
  hasTransactionSyncs: Boolean
  hasTransactionSyncsWith: [TransactionSyncWhereInput!]
  """institution edge predicates"""
  hasInstitution: Boolean
  hasInstitutionWith: [PlaidInstitutionWhereInput!]
}
type Query {
  """Fetches an object given its ID."""
  node(
    """ID of the object."""
    id: ID!
  ): Node
  """Lookup nodes by a list of IDs."""
  nodes(
    """The list of node IDs."""
    ids: [ID!]!
  ): [Node]!
}
type SpendingCategory implements Node {
  id: ID!
  name: String!
  categoryID: String!
  createdAt: Time!
  categoryTransactions: [Transaction!]
  interestedUsers: [User!]
}
"""A connection to a list of items."""
type SpendingCategoryConnection {
  """A list of edges."""
  edges: [SpendingCategoryEdge]
  """Information to aid in pagination."""
  pageInfo: PageInfo!
  """Identifies the total count of items in the connection."""
  totalCount: Int!
}
"""An edge in a connection."""
type SpendingCategoryEdge {
  """The item at the end of the edge."""
  node: SpendingCategory
  """A cursor for use in pagination."""
  cursor: Cursor!
}
"""
SpendingCategoryWhereInput is used for filtering SpendingCategory objects.
Input was generated by ent.
"""
input SpendingCategoryWhereInput {
  not: SpendingCategoryWhereInput
  and: [SpendingCategoryWhereInput!]
  or: [SpendingCategoryWhereInput!]
  """id field predicates"""
  id: ID
  idNEQ: ID
  idIn: [ID!]
  idNotIn: [ID!]
  idGT: ID
  idGTE: ID
  idLT: ID
  idLTE: ID
  """name field predicates"""
  name: String
  nameNEQ: String
  nameIn: [String!]
  nameNotIn: [String!]
  nameGT: String
  nameGTE: String
  nameLT: String
  nameLTE: String
  nameContains: String
  nameHasPrefix: String
  nameHasSuffix: String
  nameEqualFold: String
  nameContainsFold: String
  """category_id field predicates"""
  categoryID: String
  categoryIDNEQ: String
  categoryIDIn: [String!]
  categoryIDNotIn: [String!]
  categoryIDGT: String
  categoryIDGTE: String
  categoryIDLT: String
  categoryIDLTE: String
  categoryIDContains: String
  categoryIDHasPrefix: String
  categoryIDHasSuffix: String
  categoryIDEqualFold: String
  categoryIDContainsFold: String
  """created_at field predicates"""
  createdAt: Time
  createdAtNEQ: Time
  createdAtIn: [Time!]
  createdAtNotIn: [Time!]
  createdAtGT: Time
  createdAtGTE: Time
  createdAtLT: Time
  createdAtLTE: Time
  """category_transactions edge predicates"""
  hasCategoryTransactions: Boolean
  hasCategoryTransactionsWith: [TransactionWhereInput!]
  """interested_users edge predicates"""
  hasInterestedUsers: Boolean
  hasInterestedUsersWith: [UserWhereInput!]
}
"""The builtin Time type"""
scalar Time
type Transaction implements Node {
  id: ID!
  financialAccountID: String!
  amount: Float!
  isoCurrencyCode: String!
  unofficialCurrencyCode: String!
  category: String
  categoryID: String
  checkNumber: String!
  date: String!
  datetime: Time
  authorizedDate: String
  authorizedDatetime: Time
  locationAddress: String!
  locationCity: String!
  locationRegion: String!
  locationPostalCode: String!
  locationLat: Float!
  locationLon: Float!
  locationStoreNumber: String!
  name: String!
  merchantName: String!
  paymentChannel: String!
  pending: Boolean!
  pendingTransactionID: String!
  accountOwner: String!
  transactionID: String!
  transactionCode: String!
  createdAt: Time!
  institutionAccount: PlaidInstitutionAccount
  transactionCategories: [SpendingCategory!]
}
"""A connection to a list of items."""
type TransactionConnection {
  """A list of edges."""
  edges: [TransactionEdge]
  """Information to aid in pagination."""
  pageInfo: PageInfo!
  """Identifies the total count of items in the connection."""
  totalCount: Int!
}
"""An edge in a connection."""
type TransactionEdge {
  """The item at the end of the edge."""
  node: Transaction
  """A cursor for use in pagination."""
  cursor: Cursor!
}
"""Ordering options for Transaction connections"""
input TransactionOrder {
  """The ordering direction."""
  direction: OrderDirection! = ASC
  """The field by which to order Transactions."""
  field: TransactionOrderField!
}
"""Properties by which Transaction connections can be ordered."""
enum TransactionOrderField {
  DATE
  DATETIME
}
type TransactionSync implements Node {
  id: ID!
  createdAt: Time!
  cursor: String!
  item: PlaidItem
}
"""
TransactionSyncWhereInput is used for filtering TransactionSync objects.
Input was generated by ent.
"""
input TransactionSyncWhereInput {
  not: TransactionSyncWhereInput
  and: [TransactionSyncWhereInput!]
  or: [TransactionSyncWhereInput!]
  """id field predicates"""
  id: ID
  idNEQ: ID
  idIn: [ID!]
  idNotIn: [ID!]
  idGT: ID
  idGTE: ID
  idLT: ID
  idLTE: ID
  """created_at field predicates"""
  createdAt: Time
  createdAtNEQ: Time
  createdAtIn: [Time!]
  createdAtNotIn: [Time!]
  createdAtGT: Time
  createdAtGTE: Time
  createdAtLT: Time
  createdAtLTE: Time
  """cursor field predicates"""
  cursor: String
  cursorNEQ: String
  cursorIn: [String!]
  cursorNotIn: [String!]
  cursorGT: String
  cursorGTE: String
  cursorLT: String
  cursorLTE: String
  cursorContains: String
  cursorHasPrefix: String
  cursorHasSuffix: String
  cursorEqualFold: String
  cursorContainsFold: String
  """item edge predicates"""
  hasItem: Boolean
  hasItemWith: [PlaidItemWhereInput!]
}
"""
TransactionWhereInput is used for filtering Transaction objects.
Input was generated by ent.
"""
input TransactionWhereInput {
  not: TransactionWhereInput
  and: [TransactionWhereInput!]
  or: [TransactionWhereInput!]
  """id field predicates"""
  id: ID
  idNEQ: ID
  idIn: [ID!]
  idNotIn: [ID!]
  idGT: ID
  idGTE: ID
  idLT: ID
  idLTE: ID
  """financial_account_id field predicates"""
  financialAccountID: String
  financialAccountIDNEQ: String
  financialAccountIDIn: [String!]
  financialAccountIDNotIn: [String!]
  financialAccountIDGT: String
  financialAccountIDGTE: String
  financialAccountIDLT: String
  financialAccountIDLTE: String
  financialAccountIDContains: String
  financialAccountIDHasPrefix: String
  financialAccountIDHasSuffix: String
  financialAccountIDEqualFold: String
  financialAccountIDContainsFold: String
  """amount field predicates"""
  amount: Float
  amountNEQ: Float
  amountIn: [Float!]
  amountNotIn: [Float!]
  amountGT: Float
  amountGTE: Float
  amountLT: Float
  amountLTE: Float
  """iso_currency_code field predicates"""
  isoCurrencyCode: String
  isoCurrencyCodeNEQ: String
  isoCurrencyCodeIn: [String!]
  isoCurrencyCodeNotIn: [String!]
  isoCurrencyCodeGT: String
  isoCurrencyCodeGTE: String
  isoCurrencyCodeLT: String
  isoCurrencyCodeLTE: String
  isoCurrencyCodeContains: String
  isoCurrencyCodeHasPrefix: String
  isoCurrencyCodeHasSuffix: String
  isoCurrencyCodeEqualFold: String
  isoCurrencyCodeContainsFold: String
  """unofficial_currency_code field predicates"""
  unofficialCurrencyCode: String
  unofficialCurrencyCodeNEQ: String
  unofficialCurrencyCodeIn: [String!]
  unofficialCurrencyCodeNotIn: [String!]
  unofficialCurrencyCodeGT: String
  unofficialCurrencyCodeGTE: String
  unofficialCurrencyCodeLT: String
  unofficialCurrencyCodeLTE: String
  unofficialCurrencyCodeContains: String
  unofficialCurrencyCodeHasPrefix: String
  unofficialCurrencyCodeHasSuffix: String
  unofficialCurrencyCodeEqualFold: String
  unofficialCurrencyCodeContainsFold: String
  """category field predicates"""
  category: String
  categoryNEQ: String
  categoryIn: [String!]
  categoryNotIn: [String!]
  categoryGT: String
  categoryGTE: String
  categoryLT: String
  categoryLTE: String
  categoryContains: String
  categoryHasPrefix: String
  categoryHasSuffix: String
  categoryIsNil: Boolean
  categoryNotNil: Boolean
  categoryEqualFold: String
  categoryContainsFold: String
  """category_id field predicates"""
  categoryID: String
  categoryIDNEQ: String
  categoryIDIn: [String!]
  categoryIDNotIn: [String!]
  categoryIDGT: String
  categoryIDGTE: String
  categoryIDLT: String
  categoryIDLTE: String
  categoryIDContains: String
  categoryIDHasPrefix: String
  categoryIDHasSuffix: String
  categoryIDIsNil: Boolean
  categoryIDNotNil: Boolean
  categoryIDEqualFold: String
  categoryIDContainsFold: String
  """check_number field predicates"""
  checkNumber: String
  checkNumberNEQ: String
  checkNumberIn: [String!]
  checkNumberNotIn: [String!]
  checkNumberGT: String
  checkNumberGTE: String
  checkNumberLT: String
  checkNumberLTE: String
  checkNumberContains: String
  checkNumberHasPrefix: String
  checkNumberHasSuffix: String
  checkNumberEqualFold: String
  checkNumberContainsFold: String
  """date field predicates"""
  date: String
  dateNEQ: String
  dateIn: [String!]
  dateNotIn: [String!]
  dateGT: String
  dateGTE: String
  dateLT: String
  dateLTE: String
  dateContains: String
  dateHasPrefix: String
  dateHasSuffix: String
  dateEqualFold: String
  dateContainsFold: String
  """datetime field predicates"""
  datetime: Time
  datetimeNEQ: Time
  datetimeIn: [Time!]
  datetimeNotIn: [Time!]
  datetimeGT: Time
  datetimeGTE: Time
  datetimeLT: Time
  datetimeLTE: Time
  datetimeIsNil: Boolean
  datetimeNotNil: Boolean
  """authorized_date field predicates"""
  authorizedDate: String
  authorizedDateNEQ: String
  authorizedDateIn: [String!]
  authorizedDateNotIn: [String!]
  authorizedDateGT: String
  authorizedDateGTE: String
  authorizedDateLT: String
  authorizedDateLTE: String
  authorizedDateContains: String
  authorizedDateHasPrefix: String
  authorizedDateHasSuffix: String
  authorizedDateIsNil: Boolean
  authorizedDateNotNil: Boolean
  authorizedDateEqualFold: String
  authorizedDateContainsFold: String
  """authorized_datetime field predicates"""
  authorizedDatetime: Time
  authorizedDatetimeNEQ: Time
  authorizedDatetimeIn: [Time!]
  authorizedDatetimeNotIn: [Time!]
  authorizedDatetimeGT: Time
  authorizedDatetimeGTE: Time
  authorizedDatetimeLT: Time
  authorizedDatetimeLTE: Time
  authorizedDatetimeIsNil: Boolean
  authorizedDatetimeNotNil: Boolean
  """location_address field predicates"""
  locationAddress: String
  locationAddressNEQ: String
  locationAddressIn: [String!]
  locationAddressNotIn: [String!]
  locationAddressGT: String
  locationAddressGTE: String
  locationAddressLT: String
  locationAddressLTE: String
  locationAddressContains: String
  locationAddressHasPrefix: String
  locationAddressHasSuffix: String
  locationAddressEqualFold: String
  locationAddressContainsFold: String
  """location_city field predicates"""
  locationCity: String
  locationCityNEQ: String
  locationCityIn: [String!]
  locationCityNotIn: [String!]
  locationCityGT: String
  locationCityGTE: String
  locationCityLT: String
  locationCityLTE: String
  locationCityContains: String
  locationCityHasPrefix: String
  locationCityHasSuffix: String
  locationCityEqualFold: String
  locationCityContainsFold: String
  """location_region field predicates"""
  locationRegion: String
  locationRegionNEQ: String
  locationRegionIn: [String!]
  locationRegionNotIn: [String!]
  locationRegionGT: String
  locationRegionGTE: String
  locationRegionLT: String
  locationRegionLTE: String
  locationRegionContains: String
  locationRegionHasPrefix: String
  locationRegionHasSuffix: String
  locationRegionEqualFold: String
  locationRegionContainsFold: String
  """location_postal_code field predicates"""
  locationPostalCode: String
  locationPostalCodeNEQ: String
  locationPostalCodeIn: [String!]
  locationPostalCodeNotIn: [String!]
  locationPostalCodeGT: String
  locationPostalCodeGTE: String
  locationPostalCodeLT: String
  locationPostalCodeLTE: String
  locationPostalCodeContains: String
  locationPostalCodeHasPrefix: String
  locationPostalCodeHasSuffix: String
  locationPostalCodeEqualFold: String
  locationPostalCodeContainsFold: String
  """location_lat field predicates"""
  locationLat: Float
  locationLatNEQ: Float
  locationLatIn: [Float!]
  locationLatNotIn: [Float!]
  locationLatGT: Float
  locationLatGTE: Float
  locationLatLT: Float
  locationLatLTE: Float
  """location_lon field predicates"""
  locationLon: Float
  locationLonNEQ: Float
  locationLonIn: [Float!]
  locationLonNotIn: [Float!]
  locationLonGT: Float
  locationLonGTE: Float
  locationLonLT: Float
  locationLonLTE: Float
  """location_store_number field predicates"""
  locationStoreNumber: String
  locationStoreNumberNEQ: String
  locationStoreNumberIn: [String!]
  locationStoreNumberNotIn: [String!]
  locationStoreNumberGT: String
  locationStoreNumberGTE: String
  locationStoreNumberLT: String
  locationStoreNumberLTE: String
  locationStoreNumberContains: String
  locationStoreNumberHasPrefix: String
  locationStoreNumberHasSuffix: String
  locationStoreNumberEqualFold: String
  locationStoreNumberContainsFold: String
  """name field predicates"""
  name: String
  nameNEQ: String
  nameIn: [String!]
  nameNotIn: [String!]
  nameGT: String
  nameGTE: String
  nameLT: String
  nameLTE: String
  nameContains: String
  nameHasPrefix: String
  nameHasSuffix: String
  nameEqualFold: String
  nameContainsFold: String
  """merchant_name field predicates"""
  merchantName: String
  merchantNameNEQ: String
  merchantNameIn: [String!]
  merchantNameNotIn: [String!]
  merchantNameGT: String
  merchantNameGTE: String
  merchantNameLT: String
  merchantNameLTE: String
  merchantNameContains: String
  merchantNameHasPrefix: String
  merchantNameHasSuffix: String
  merchantNameEqualFold: String
  merchantNameContainsFold: String
  """payment_channel field predicates"""
  paymentChannel: String
  paymentChannelNEQ: String
  paymentChannelIn: [String!]
  paymentChannelNotIn: [String!]
  paymentChannelGT: String
  paymentChannelGTE: String
  paymentChannelLT: String
  paymentChannelLTE: String
  paymentChannelContains: String
  paymentChannelHasPrefix: String
  paymentChannelHasSuffix: String
  paymentChannelEqualFold: String
  paymentChannelContainsFold: String
  """pending field predicates"""
  pending: Boolean
  pendingNEQ: Boolean
  """pending_transaction_id field predicates"""
  pendingTransactionID: String
  pendingTransactionIDNEQ: String
  pendingTransactionIDIn: [String!]
  pendingTransactionIDNotIn: [String!]
  pendingTransactionIDGT: String
  pendingTransactionIDGTE: String
  pendingTransactionIDLT: String
  pendingTransactionIDLTE: String
  pendingTransactionIDContains: String
  pendingTransactionIDHasPrefix: String
  pendingTransactionIDHasSuffix: String
  pendingTransactionIDEqualFold: String
  pendingTransactionIDContainsFold: String
  """account_owner field predicates"""
  accountOwner: String
  accountOwnerNEQ: String
  accountOwnerIn: [String!]
  accountOwnerNotIn: [String!]
  accountOwnerGT: String
  accountOwnerGTE: String
  accountOwnerLT: String
  accountOwnerLTE: String
  accountOwnerContains: String
  accountOwnerHasPrefix: String
  accountOwnerHasSuffix: String
  accountOwnerEqualFold: String
  accountOwnerContainsFold: String
  """transaction_id field predicates"""
  transactionID: String
  transactionIDNEQ: String
  transactionIDIn: [String!]
  transactionIDNotIn: [String!]
  transactionIDGT: String
  transactionIDGTE: String
  transactionIDLT: String
  transactionIDLTE: String
  transactionIDContains: String
  transactionIDHasPrefix: String
  transactionIDHasSuffix: String
  transactionIDEqualFold: String
  transactionIDContainsFold: String
  """transaction_code field predicates"""
  transactionCode: String
  transactionCodeNEQ: String
  transactionCodeIn: [String!]
  transactionCodeNotIn: [String!]
  transactionCodeGT: String
  transactionCodeGTE: String
  transactionCodeLT: String
  transactionCodeLTE: String
  transactionCodeContains: String
  transactionCodeHasPrefix: String
  transactionCodeHasSuffix: String
  transactionCodeEqualFold: String
  transactionCodeContainsFold: String
  """created_at field predicates"""
  createdAt: Time
  createdAtNEQ: Time
  createdAtIn: [Time!]
  createdAtNotIn: [Time!]
  createdAtGT: Time
  createdAtGTE: Time
  createdAtLT: Time
  createdAtLTE: Time
  """institution_account edge predicates"""
  hasInstitutionAccount: Boolean
  hasInstitutionAccountWith: [PlaidInstitutionAccountWhereInput!]
  """transaction_categories edge predicates"""
  hasTransactionCategories: Boolean
  hasTransactionCategoriesWith: [SpendingCategoryWhereInput!]
}
"""
UpdateUserInput is used for update User object.
Input was generated by ent.
"""
input UpdateUserInput {
  offerFrequency: UserOfferFrequency
  homeCountry: String
  clearHomeCountry: Boolean
  homeState: String
  clearHomeState: Boolean
  homeCity: String
  clearHomeCity: Boolean
}
"""
UpdateUserNotificationChannelPreferencesInput is used for update UserNotificationChannelPreferences object.
Input was generated by ent.
"""
input UpdateUserNotificationChannelPreferencesInput {
  chanel: UserNotificationChannelPreferencesChanel
}
type User implements Node {
  id: ID!
  identityProviderID: String
  offerFrequency: UserOfferFrequency!
  homeCountry: String
  homeState: String
  homeCity: String
  plaidItems: [PlaidItem!]
  spendingCategories: [SpendingCategory!]
  notificationChannels: [UserNotificationChannelPreferences!]
  notifications: [Notification!]
  availableDiscountOffers: [DiscountOffer!]
}
type UserNotificationChannelPreferences implements Node {
  id: ID!
  chanel: UserNotificationChannelPreferencesChanel!
  chanelUsers: User
}
"""UserNotificationChannelPreferencesChanel is enum for the field chanel"""
enum UserNotificationChannelPreferencesChanel @goModel(model: "wallit/ent/usernotificationchannelpreferences.Chanel") {
  EMAIL
  SMS
  PUSH
}
"""A connection to a list of items."""
type UserNotificationChannelPreferencesConnection {
  """A list of edges."""
  edges: [UserNotificationChannelPreferencesEdge]
  """Information to aid in pagination."""
  pageInfo: PageInfo!
  """Identifies the total count of items in the connection."""
  totalCount: Int!
}
"""An edge in a connection."""
type UserNotificationChannelPreferencesEdge {
  """The item at the end of the edge."""
  node: UserNotificationChannelPreferences
  """A cursor for use in pagination."""
  cursor: Cursor!
}
"""
UserNotificationChannelPreferencesWhereInput is used for filtering UserNotificationChannelPreferences objects.
Input was generated by ent.
"""
input UserNotificationChannelPreferencesWhereInput {
  not: UserNotificationChannelPreferencesWhereInput
  and: [UserNotificationChannelPreferencesWhereInput!]
  or: [UserNotificationChannelPreferencesWhereInput!]
  """id field predicates"""
  id: ID
  idNEQ: ID
  idIn: [ID!]
  idNotIn: [ID!]
  idGT: ID
  idGTE: ID
  idLT: ID
  idLTE: ID
  """chanel field predicates"""
  chanel: UserNotificationChannelPreferencesChanel
  chanelNEQ: UserNotificationChannelPreferencesChanel
  chanelIn: [UserNotificationChannelPreferencesChanel!]
  chanelNotIn: [UserNotificationChannelPreferencesChanel!]
  """chanel_users edge predicates"""
  hasChanelUsers: Boolean
  hasChanelUsersWith: [UserWhereInput!]
}
"""UserOfferFrequency is enum for the field offer_frequency"""
enum UserOfferFrequency @goModel(model: "wallit/ent/user.OfferFrequency") {
  NO_OFFERS
  ASS_SOON_AS_POSSIBLE
  DAILY
  WEEKLY
  BI_WEEKLY
  MONTHLY
}
"""
UserWhereInput is used for filtering User objects.
Input was generated by ent.
"""
input UserWhereInput {
  not: UserWhereInput
  and: [UserWhereInput!]
  or: [UserWhereInput!]
  """id field predicates"""
  id: ID
  idNEQ: ID
  idIn: [ID!]
  idNotIn: [ID!]
  idGT: ID
  idGTE: ID
  idLT: ID
  idLTE: ID
  """identity_provider_id field predicates"""
  identityProviderID: String
  identityProviderIDNEQ: String
  identityProviderIDIn: [String!]
  identityProviderIDNotIn: [String!]
  identityProviderIDGT: String
  identityProviderIDGTE: String
  identityProviderIDLT: String
  identityProviderIDLTE: String
  identityProviderIDContains: String
  identityProviderIDHasPrefix: String
  identityProviderIDHasSuffix: String
  identityProviderIDIsNil: Boolean
  identityProviderIDNotNil: Boolean
  identityProviderIDEqualFold: String
  identityProviderIDContainsFold: String
  """offer_frequency field predicates"""
  offerFrequency: UserOfferFrequency
  offerFrequencyNEQ: UserOfferFrequency
  offerFrequencyIn: [UserOfferFrequency!]
  offerFrequencyNotIn: [UserOfferFrequency!]
  """home_country field predicates"""
  homeCountry: String
  homeCountryNEQ: String
  homeCountryIn: [String!]
  homeCountryNotIn: [String!]
  homeCountryGT: String
  homeCountryGTE: String
  homeCountryLT: String
  homeCountryLTE: String
  homeCountryContains: String
  homeCountryHasPrefix: String
  homeCountryHasSuffix: String
  homeCountryIsNil: Boolean
  homeCountryNotNil: Boolean
  homeCountryEqualFold: String
  homeCountryContainsFold: String
  """home_state field predicates"""
  homeState: String
  homeStateNEQ: String
  homeStateIn: [String!]
  homeStateNotIn: [String!]
  homeStateGT: String
  homeStateGTE: String
  homeStateLT: String
  homeStateLTE: String
  homeStateContains: String
  homeStateHasPrefix: String
  homeStateHasSuffix: String
  homeStateIsNil: Boolean
  homeStateNotNil: Boolean
  homeStateEqualFold: String
  homeStateContainsFold: String
  """home_city field predicates"""
  homeCity: String
  homeCityNEQ: String
  homeCityIn: [String!]
  homeCityNotIn: [String!]
  homeCityGT: String
  homeCityGTE: String
  homeCityLT: String
  homeCityLTE: String
  homeCityContains: String
  homeCityHasPrefix: String
  homeCityHasSuffix: String
  homeCityIsNil: Boolean
  homeCityNotNil: Boolean
  homeCityEqualFold: String
  homeCityContainsFold: String
  """plaid_items edge predicates"""
  hasPlaidItems: Boolean
  hasPlaidItemsWith: [PlaidItemWhereInput!]
  """spending_categories edge predicates"""
  hasSpendingCategories: Boolean
  hasSpendingCategoriesWith: [SpendingCategoryWhereInput!]
  """notification_channels edge predicates"""
  hasNotificationChannels: Boolean
  hasNotificationChannelsWith: [UserNotificationChannelPreferencesWhereInput!]
  """notifications edge predicates"""
  hasNotifications: Boolean
  hasNotificationsWith: [NotificationWhereInput!]
  """available_discount_offers edge predicates"""
  hasAvailableDiscountOffers: Boolean
  hasAvailableDiscountOffersWith: [DiscountOfferWhereInput!]
}
`, BuiltIn: false},
	{Name: "../api/graphql/merchant.graphql", Input: `extend type Mutation {
    createMerchant(input: CreateMerchantInput!): Merchant!
}
`, BuiltIn: false},
	{Name: "../api/graphql/notification.graphql", Input: `extend type Query {
    notifications(
        after: Cursor
        first: Int
        before: Cursor
        last: Int
        orderBy: NotificationOrder
        where: NotificationWhereInput
    ): NotificationConnection!
}

type Subscription {
    notification(ownerID: ID!): Notification!
}

extend type Mutation {
    markNotificationsAsCheckedInApp(ids: [ID!]!): Boolean!
}
`, BuiltIn: false},
	{Name: "../api/graphql/plaid.graphql", Input: `#extend type PlaidItem {
#    institutionId: String!
##    itemId: String!
#    error: Boolean!
#    institution: InstitutionInfo!
#    accounts: [PlaidAccountInfo!]!
#}

type InstitutionInfo {
    institutionId: String!
    name: String!
}

type PlaidAccountBalances {
    available: Float!
    current: Float!
    isoCurrencyCode: String!
}

type PlaidAccountInfo {
    accountId: String!
    balances: PlaidAccountBalances!
    mask: String!
    name: String!
    officialName: String!
    type: String!
    transactions(
        after: Cursor
        first: Int
        before: Cursor
        last: Int
        where: TransactionWhereInput
        orderBy: TransactionOrder
    ): TransactionConnection!
}

#type PlaidItemInfoConnection {
#    edges: [PlaidItemInfoEdge]
#    pageInfo: PageInfo!
#    totalCount: Int!
#}

#type PlaidItemInfoEdge {
#    node: PlaidItemInfo
#    cursor: Cursor!
#}

extend type Query {
    plaidItems(
        after: Cursor
        first: Int
        before: Cursor
        last: Int
        where: PlaidItemWhereInput
    ): PlaidItemConnection!
    transactions(
        after: Cursor
        first: Int
        before: Cursor
        last: Int
        orderBy: TransactionOrder
        where: TransactionWhereInput
    ): TransactionConnection!
    plaidInstitutionAccounts(
        after: Cursor
        first: Int
        before: Cursor
        last: Int
        where: PlaidInstitutionAccountWhereInput
    ): PlaidInstitutionAccountConnection
    plaidInstitutions(
        after: Cursor
        first: Int
        before: Cursor
        last: Int
        where: PlaidInstitutionWhereInput
    ): PlaidInstitutionConnection
}

type Mutation {
    createLinkToken(input: CreateLinkTokenParams!): LinkTokenHost!
    exchangePublicToken(input: ExchangePublicTokenParams!): String!
}`, BuiltIn: false},
	{Name: "../api/graphql/user.graphql", Input: `input ExchangeAuthTokenForUserProfileInput {
    identityProviderID: String!
}

extend type Mutation {
    exchangeAuthTokenForUserProfile(input: ExchangeAuthTokenForUserProfileInput!): User!
    updateUser(id: ID!, input: UpdateUserInput): User!
    setSpendingCategories(userID: ID!, spendingCategoryIDs: [ID!]!): User!
    setNotificationChannels(userID: ID!, notificationChannel: [UserNotificationChannelPreferencesChanel!]!): User!
    setOfferFrequency(userID: ID!, frequency: UserOfferFrequency!): User!
}

extend type Query {
    spendingCategories(
        after: Cursor
        first: Int
        before: Cursor
        last: Int
        where: SpendingCategoryWhereInput
    ): SpendingCategoryConnection!
    notificationChannels(
        after: Cursor
        first: Int
        before: Cursor
        last: Int
        where: UserNotificationChannelPreferencesWhereInput
    ): UserNotificationChannelPreferencesConnection!
}`, BuiltIn: false},
	{Name: "../api/graphql/schema.graphqls", Input: `input CreateLinkTokenParams {
    userId: ID!
}

type LinkTokenHost {
    linkToken: String!
}

input ExchangePublicTokenParams {
    userId: ID!
    publicToken: String!
}

#type User {
#    identityProviderId: String!
#}

#type Mutation {
#    exchangeAuthTokenForUserProfile(input: CreateUserInput!): User!
#    createLinkToken(input: CreateLinkTokenParams!): LinkTokenHost!
#    exchangePublicToken(input: ExchangePublicTokenParams!): String!
#}

#type Query {
#    none: String
#}
`, BuiltIn: false},
}
var parsedSchema = gqlparser.MustLoadSchema(sources...)

// endregion ************************** generated!.gotpl **************************

// region    ***************************** args.gotpl *****************************

func (ec *executionContext) field_Mutation_createDiscountOffer_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 ent.CreateDiscountOfferInput
	if tmp, ok := rawArgs["input"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
		arg0, err = ec.unmarshalNCreateDiscountOfferInput2wallitentCreateDiscountOfferInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["input"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_createLinkToken_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 model.CreateLinkTokenParams
	if tmp, ok := rawArgs["input"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
		arg0, err = ec.unmarshalNCreateLinkTokenParams2wallitgraphmodelCreateLinkTokenParams(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["input"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_createMerchant_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 ent.CreateMerchantInput
	if tmp, ok := rawArgs["input"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
		arg0, err = ec.unmarshalNCreateMerchantInput2wallitentCreateMerchantInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["input"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_exchangeAuthTokenForUserProfile_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 model.ExchangeAuthTokenForUserProfileInput
	if tmp, ok := rawArgs["input"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
		arg0, err = ec.unmarshalNExchangeAuthTokenForUserProfileInput2wallitgraphmodelExchangeAuthTokenForUserProfileInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["input"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_exchangePublicToken_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 model.ExchangePublicTokenParams
	if tmp, ok := rawArgs["input"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
		arg0, err = ec.unmarshalNExchangePublicTokenParams2wallitgraphmodelExchangePublicTokenParams(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["input"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_markNotificationsAsCheckedInApp_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 []int
	if tmp, ok := rawArgs["ids"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("ids"))
		arg0, err = ec.unmarshalNID2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["ids"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_setNotificationChannels_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 int
	if tmp, ok := rawArgs["userID"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("userID"))
		arg0, err = ec.unmarshalNID2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["userID"] = arg0
	var arg1 []usernotificationchannelpreferences.Chanel
	if tmp, ok := rawArgs["notificationChannel"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("notificationChannel"))
		arg1, err = ec.unmarshalNUserNotificationChannelPreferencesChanel2wallitentusernotificationchannelpreferencesChanel(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["notificationChannel"] = arg1
	return args, nil
}

func (ec *executionContext) field_Mutation_setOfferFrequency_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 int
	if tmp, ok := rawArgs["userID"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("userID"))
		arg0, err = ec.unmarshalNID2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["userID"] = arg0
	var arg1 user.OfferFrequency
	if tmp, ok := rawArgs["frequency"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("frequency"))
		arg1, err = ec.unmarshalNUserOfferFrequency2wallitentuserOfferFrequency(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["frequency"] = arg1
	return args, nil
}

func (ec *executionContext) field_Mutation_setSpendingCategories_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 int
	if tmp, ok := rawArgs["userID"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("userID"))
		arg0, err = ec.unmarshalNID2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["userID"] = arg0
	var arg1 []int
	if tmp, ok := rawArgs["spendingCategoryIDs"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("spendingCategoryIDs"))
		arg1, err = ec.unmarshalNID2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["spendingCategoryIDs"] = arg1
	return args, nil
}

func (ec *executionContext) field_Mutation_updateUser_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 int
	if tmp, ok := rawArgs["id"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
		arg0, err = ec.unmarshalNID2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["id"] = arg0
	var arg1 *ent.UpdateUserInput
	if tmp, ok := rawArgs["input"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
		arg1, err = ec.unmarshalOUpdateUserInput2wallitentUpdateUserInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["input"] = arg1
	return args, nil
}

func (ec *executionContext) field_PlaidAccountInfo_transactions_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *ent.Cursor
	if tmp, ok := rawArgs["after"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("after"))
		arg0, err = ec.unmarshalOCursor2wallitentCursor(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["after"] = arg0
	var arg1 *int
	if tmp, ok := rawArgs["first"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("first"))
		arg1, err = ec.unmarshalOInt2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["first"] = arg1
	var arg2 *ent.Cursor
	if tmp, ok := rawArgs["before"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("before"))
		arg2, err = ec.unmarshalOCursor2wallitentCursor(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["before"] = arg2
	var arg3 *int
	if tmp, ok := rawArgs["last"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("last"))
		arg3, err = ec.unmarshalOInt2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["last"] = arg3
	var arg4 *ent.TransactionWhereInput
	if tmp, ok := rawArgs["where"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("where"))
		arg4, err = ec.unmarshalOTransactionWhereInput2wallitentTransactionWhereInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["where"] = arg4
	var arg5 *ent.TransactionOrder
	if tmp, ok := rawArgs["orderBy"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("orderBy"))
		arg5, err = ec.unmarshalOTransactionOrder2wallitentTransactionOrder(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["orderBy"] = arg5
	return args, nil
}

func (ec *executionContext) field_PlaidInstitutionAccount_transactions_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *ent.Cursor
	if tmp, ok := rawArgs["after"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("after"))
		arg0, err = ec.unmarshalOCursor2wallitentCursor(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["after"] = arg0
	var arg1 *int
	if tmp, ok := rawArgs["first"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("first"))
		arg1, err = ec.unmarshalOInt2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["first"] = arg1
	var arg2 *ent.Cursor
	if tmp, ok := rawArgs["before"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("before"))
		arg2, err = ec.unmarshalOCursor2wallitentCursor(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["before"] = arg2
	var arg3 *int
	if tmp, ok := rawArgs["last"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("last"))
		arg3, err = ec.unmarshalOInt2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["last"] = arg3
	var arg4 *ent.TransactionOrder
	if tmp, ok := rawArgs["orderBy"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("orderBy"))
		arg4, err = ec.unmarshalOTransactionOrder2wallitentTransactionOrder(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["orderBy"] = arg4
	var arg5 *ent.TransactionWhereInput
	if tmp, ok := rawArgs["where"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("where"))
		arg5, err = ec.unmarshalOTransactionWhereInput2wallitentTransactionWhereInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["where"] = arg5
	return args, nil
}

func (ec *executionContext) field_Query___type_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["name"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
		arg0, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["name"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_discountOffers_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *ent.Cursor
	if tmp, ok := rawArgs["after"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("after"))
		arg0, err = ec.unmarshalOCursor2wallitentCursor(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["after"] = arg0
	var arg1 *int
	if tmp, ok := rawArgs["first"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("first"))
		arg1, err = ec.unmarshalOInt2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["first"] = arg1
	var arg2 *ent.Cursor
	if tmp, ok := rawArgs["before"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("before"))
		arg2, err = ec.unmarshalOCursor2wallitentCursor(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["before"] = arg2
	var arg3 *int
	if tmp, ok := rawArgs["last"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("last"))
		arg3, err = ec.unmarshalOInt2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["last"] = arg3
	var arg4 *ent.DiscountOfferOrder
	if tmp, ok := rawArgs["orderBy"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("orderBy"))
		arg4, err = ec.unmarshalODiscountOfferOrder2wallitentDiscountOfferOrder(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["orderBy"] = arg4
	var arg5 *ent.DiscountOfferWhereInput
	if tmp, ok := rawArgs["where"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("where"))
		arg5, err = ec.unmarshalODiscountOfferWhereInput2wallitentDiscountOfferWhereInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["where"] = arg5
	return args, nil
}

func (ec *executionContext) field_Query_node_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 int
	if tmp, ok := rawArgs["id"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
		arg0, err = ec.unmarshalNID2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["id"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_nodes_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 []int
	if tmp, ok := rawArgs["ids"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("ids"))
		arg0, err = ec.unmarshalNID2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["ids"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_notificationChannels_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *ent.Cursor
	if tmp, ok := rawArgs["after"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("after"))
		arg0, err = ec.unmarshalOCursor2wallitentCursor(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["after"] = arg0
	var arg1 *int
	if tmp, ok := rawArgs["first"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("first"))
		arg1, err = ec.unmarshalOInt2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["first"] = arg1
	var arg2 *ent.Cursor
	if tmp, ok := rawArgs["before"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("before"))
		arg2, err = ec.unmarshalOCursor2wallitentCursor(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["before"] = arg2
	var arg3 *int
	if tmp, ok := rawArgs["last"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("last"))
		arg3, err = ec.unmarshalOInt2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["last"] = arg3
	var arg4 *ent.UserNotificationChannelPreferencesWhereInput
	if tmp, ok := rawArgs["where"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("where"))
		arg4, err = ec.unmarshalOUserNotificationChannelPreferencesWhereInput2wallitentUserNotificationChannelPreferencesWhereInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["where"] = arg4
	return args, nil
}

func (ec *executionContext) field_Query_notifications_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *ent.Cursor
	if tmp, ok := rawArgs["after"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("after"))
		arg0, err = ec.unmarshalOCursor2wallitentCursor(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["after"] = arg0
	var arg1 *int
	if tmp, ok := rawArgs["first"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("first"))
		arg1, err = ec.unmarshalOInt2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["first"] = arg1
	var arg2 *ent.Cursor
	if tmp, ok := rawArgs["before"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("before"))
		arg2, err = ec.unmarshalOCursor2wallitentCursor(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["before"] = arg2
	var arg3 *int
	if tmp, ok := rawArgs["last"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("last"))
		arg3, err = ec.unmarshalOInt2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["last"] = arg3
	var arg4 *ent.NotificationOrder
	if tmp, ok := rawArgs["orderBy"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("orderBy"))
		arg4, err = ec.unmarshalONotificationOrder2wallitentNotificationOrder(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["orderBy"] = arg4
	var arg5 *ent.NotificationWhereInput
	if tmp, ok := rawArgs["where"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("where"))
		arg5, err = ec.unmarshalONotificationWhereInput2wallitentNotificationWhereInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["where"] = arg5
	return args, nil
}

func (ec *executionContext) field_Query_plaidInstitutionAccounts_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *ent.Cursor
	if tmp, ok := rawArgs["after"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("after"))
		arg0, err = ec.unmarshalOCursor2wallitentCursor(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["after"] = arg0
	var arg1 *int
	if tmp, ok := rawArgs["first"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("first"))
		arg1, err = ec.unmarshalOInt2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["first"] = arg1
	var arg2 *ent.Cursor
	if tmp, ok := rawArgs["before"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("before"))
		arg2, err = ec.unmarshalOCursor2wallitentCursor(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["before"] = arg2
	var arg3 *int
	if tmp, ok := rawArgs["last"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("last"))
		arg3, err = ec.unmarshalOInt2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["last"] = arg3
	var arg4 *ent.PlaidInstitutionAccountWhereInput
	if tmp, ok := rawArgs["where"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("where"))
		arg4, err = ec.unmarshalOPlaidInstitutionAccountWhereInput2wallitentPlaidInstitutionAccountWhereInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["where"] = arg4
	return args, nil
}

func (ec *executionContext) field_Query_plaidInstitutions_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *ent.Cursor
	if tmp, ok := rawArgs["after"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("after"))
		arg0, err = ec.unmarshalOCursor2wallitentCursor(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["after"] = arg0
	var arg1 *int
	if tmp, ok := rawArgs["first"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("first"))
		arg1, err = ec.unmarshalOInt2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["first"] = arg1
	var arg2 *ent.Cursor
	if tmp, ok := rawArgs["before"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("before"))
		arg2, err = ec.unmarshalOCursor2wallitentCursor(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["before"] = arg2
	var arg3 *int
	if tmp, ok := rawArgs["last"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("last"))
		arg3, err = ec.unmarshalOInt2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["last"] = arg3
	var arg4 *ent.PlaidInstitutionWhereInput
	if tmp, ok := rawArgs["where"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("where"))
		arg4, err = ec.unmarshalOPlaidInstitutionWhereInput2wallitentPlaidInstitutionWhereInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["where"] = arg4
	return args, nil
}

func (ec *executionContext) field_Query_plaidItems_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *ent.Cursor
	if tmp, ok := rawArgs["after"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("after"))
		arg0, err = ec.unmarshalOCursor2wallitentCursor(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["after"] = arg0
	var arg1 *int
	if tmp, ok := rawArgs["first"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("first"))
		arg1, err = ec.unmarshalOInt2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["first"] = arg1
	var arg2 *ent.Cursor
	if tmp, ok := rawArgs["before"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("before"))
		arg2, err = ec.unmarshalOCursor2wallitentCursor(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["before"] = arg2
	var arg3 *int
	if tmp, ok := rawArgs["last"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("last"))
		arg3, err = ec.unmarshalOInt2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["last"] = arg3
	var arg4 *ent.PlaidItemWhereInput
	if tmp, ok := rawArgs["where"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("where"))
		arg4, err = ec.unmarshalOPlaidItemWhereInput2wallitentPlaidItemWhereInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["where"] = arg4
	return args, nil
}

func (ec *executionContext) field_Query_spendingCategories_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *ent.Cursor
	if tmp, ok := rawArgs["after"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("after"))
		arg0, err = ec.unmarshalOCursor2wallitentCursor(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["after"] = arg0
	var arg1 *int
	if tmp, ok := rawArgs["first"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("first"))
		arg1, err = ec.unmarshalOInt2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["first"] = arg1
	var arg2 *ent.Cursor
	if tmp, ok := rawArgs["before"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("before"))
		arg2, err = ec.unmarshalOCursor2wallitentCursor(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["before"] = arg2
	var arg3 *int
	if tmp, ok := rawArgs["last"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("last"))
		arg3, err = ec.unmarshalOInt2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["last"] = arg3
	var arg4 *ent.SpendingCategoryWhereInput
	if tmp, ok := rawArgs["where"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("where"))
		arg4, err = ec.unmarshalOSpendingCategoryWhereInput2wallitentSpendingCategoryWhereInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["where"] = arg4
	return args, nil
}

func (ec *executionContext) field_Query_transactions_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *ent.Cursor
	if tmp, ok := rawArgs["after"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("after"))
		arg0, err = ec.unmarshalOCursor2wallitentCursor(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["after"] = arg0
	var arg1 *int
	if tmp, ok := rawArgs["first"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("first"))
		arg1, err = ec.unmarshalOInt2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["first"] = arg1
	var arg2 *ent.Cursor
	if tmp, ok := rawArgs["before"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("before"))
		arg2, err = ec.unmarshalOCursor2wallitentCursor(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["before"] = arg2
	var arg3 *int
	if tmp, ok := rawArgs["last"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("last"))
		arg3, err = ec.unmarshalOInt2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["last"] = arg3
	var arg4 *ent.TransactionOrder
	if tmp, ok := rawArgs["orderBy"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("orderBy"))
		arg4, err = ec.unmarshalOTransactionOrder2wallitentTransactionOrder(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["orderBy"] = arg4
	var arg5 *ent.TransactionWhereInput
	if tmp, ok := rawArgs["where"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("where"))
		arg5, err = ec.unmarshalOTransactionWhereInput2wallitentTransactionWhereInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["where"] = arg5
	return args, nil
}

func (ec *executionContext) field_Subscription_notification_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 int
	if tmp, ok := rawArgs["ownerID"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("ownerID"))
		arg0, err = ec.unmarshalNID2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["ownerID"] = arg0
	return args, nil
}

func (ec *executionContext) field___Type_enumValues_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 bool
	if tmp, ok := rawArgs["includeDeprecated"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("includeDeprecated"))
		arg0, err = ec.unmarshalOBoolean2bool(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["includeDeprecated"] = arg0
	return args, nil
}

func (ec *executionContext) field___Type_fields_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 bool
	if tmp, ok := rawArgs["includeDeprecated"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("includeDeprecated"))
		arg0, err = ec.unmarshalOBoolean2bool(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["includeDeprecated"] = arg0
	return args, nil
}

// endregion ***************************** args.gotpl *****************************

// region    ************************** directives.gotpl **************************

// endregion ************************** directives.gotpl **************************

// region    **************************** field.gotpl *****************************

func (ec *executionContext) _DiscountOffer_id(ctx context.Context, field graphql.CollectedField, obj *ent.DiscountOffer) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DiscountOffer_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNID2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DiscountOffer_id(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DiscountOffer",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _DiscountOffer_amount(ctx context.Context, field graphql.CollectedField, obj *ent.DiscountOffer) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DiscountOffer_amount(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Amount, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DiscountOffer_amount(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DiscountOffer",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _DiscountOffer_type(ctx context.Context, field graphql.CollectedField, obj *ent.DiscountOffer) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DiscountOffer_type(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Type, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(discountoffer.Type)
	fc.Result = res
	return ec.marshalNDiscountOfferType2wallitentdiscountofferType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DiscountOffer_type(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DiscountOffer",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type DiscountOfferType does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _DiscountOffer_currency(ctx context.Context, field graphql.CollectedField, obj *ent.DiscountOffer) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DiscountOffer_currency(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Currency, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DiscountOffer_currency(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DiscountOffer",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _DiscountOffer_description(ctx context.Context, field graphql.CollectedField, obj *ent.DiscountOffer) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DiscountOffer_description(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DiscountOffer_description(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DiscountOffer",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _DiscountOffer_merchantSpecificIdentification(ctx context.Context, field graphql.CollectedField, obj *ent.DiscountOffer) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DiscountOffer_merchantSpecificIdentification(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.MerchantSpecificIdentification, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DiscountOffer_merchantSpecificIdentification(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DiscountOffer",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _DiscountOffer_createdAt(ctx context.Context, field graphql.CollectedField, obj *ent.DiscountOffer) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DiscountOffer_createdAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CreatedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(time.Time)
	fc.Result = res
	return ec.marshalNTime2timeTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DiscountOffer_createdAt(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DiscountOffer",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _DiscountOffer_expiresAt(ctx context.Context, field graphql.CollectedField, obj *ent.DiscountOffer) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DiscountOffer_expiresAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ExpiresAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(time.Time)
	fc.Result = res
	return ec.marshalNTime2timeTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DiscountOffer_expiresAt(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DiscountOffer",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _DiscountOffer_ownerMerchant(ctx context.Context, field graphql.CollectedField, obj *ent.DiscountOffer) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DiscountOffer_ownerMerchant(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.OwnerMerchant(ctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*ent.Merchant)
	fc.Result = res
	return ec.marshalNMerchant2wallitentMerchant(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DiscountOffer_ownerMerchant(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DiscountOffer",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Merchant_id(ctx, field)
			case "name":
				return ec.fieldContext_Merchant_name(ctx, field)
			case "discountOffers":
				return ec.fieldContext_Merchant_discountOffers(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Merchant", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _DiscountOffer_discountEligibleUsers(ctx context.Context, field graphql.CollectedField, obj *ent.DiscountOffer) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DiscountOffer_discountEligibleUsers(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DiscountEligibleUsers(ctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*ent.User)
	fc.Result = res
	return ec.marshalNUser2wallitentUser(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DiscountOffer_discountEligibleUsers(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DiscountOffer",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_User_id(ctx, field)
			case "identityProviderID":
				return ec.fieldContext_User_identityProviderID(ctx, field)
			case "offerFrequency":
				return ec.fieldContext_User_offerFrequency(ctx, field)
			case "homeCountry":
				return ec.fieldContext_User_homeCountry(ctx, field)
			case "homeState":
				return ec.fieldContext_User_homeState(ctx, field)
			case "homeCity":
				return ec.fieldContext_User_homeCity(ctx, field)
			case "plaidItems":
				return ec.fieldContext_User_plaidItems(ctx, field)
			case "spendingCategories":
				return ec.fieldContext_User_spendingCategories(ctx, field)
			case "notificationChannels":
				return ec.fieldContext_User_notificationChannels(ctx, field)
			case "notifications":
				return ec.fieldContext_User_notifications(ctx, field)
			case "availableDiscountOffers":
				return ec.fieldContext_User_availableDiscountOffers(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type User", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _DiscountOffer_discountOfferNotification(ctx context.Context, field graphql.CollectedField, obj *ent.DiscountOffer) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DiscountOffer_discountOfferNotification(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DiscountOfferNotification(ctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*ent.Notification)
	fc.Result = res
	return ec.marshalONotification2wallitentNotification(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DiscountOffer_discountOfferNotification(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DiscountOffer",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Notification_id(ctx, field)
			case "checkedInApp":
				return ec.fieldContext_Notification_checkedInApp(ctx, field)
			case "type":
				return ec.fieldContext_Notification_type(ctx, field)
			case "createdAt":
				return ec.fieldContext_Notification_createdAt(ctx, field)
			case "includedInAggregatedOfferAt":
				return ec.fieldContext_Notification_includedInAggregatedOfferAt(ctx, field)
			case "notificationRecipient":
				return ec.fieldContext_Notification_notificationRecipient(ctx, field)
			case "notificationDiscountOffer":
				return ec.fieldContext_Notification_notificationDiscountOffer(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Notification", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _DiscountOfferConnection_edges(ctx context.Context, field graphql.CollectedField, obj *ent.DiscountOfferConnection) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DiscountOfferConnection_edges(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Edges, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*ent.DiscountOfferEdge)
	fc.Result = res
	return ec.marshalODiscountOfferEdge2wallitentDiscountOfferEdge(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DiscountOfferConnection_edges(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DiscountOfferConnection",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "node":
				return ec.fieldContext_DiscountOfferEdge_node(ctx, field)
			case "cursor":
				return ec.fieldContext_DiscountOfferEdge_cursor(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type DiscountOfferEdge", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _DiscountOfferConnection_pageInfo(ctx context.Context, field graphql.CollectedField, obj *ent.DiscountOfferConnection) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DiscountOfferConnection_pageInfo(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PageInfo, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(ent.PageInfo)
	fc.Result = res
	return ec.marshalNPageInfo2wallitentPageInfo(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DiscountOfferConnection_pageInfo(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DiscountOfferConnection",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "hasNextPage":
				return ec.fieldContext_PageInfo_hasNextPage(ctx, field)
			case "hasPreviousPage":
				return ec.fieldContext_PageInfo_hasPreviousPage(ctx, field)
			case "startCursor":
				return ec.fieldContext_PageInfo_startCursor(ctx, field)
			case "endCursor":
				return ec.fieldContext_PageInfo_endCursor(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type PageInfo", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _DiscountOfferConnection_totalCount(ctx context.Context, field graphql.CollectedField, obj *ent.DiscountOfferConnection) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DiscountOfferConnection_totalCount(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TotalCount, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DiscountOfferConnection_totalCount(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DiscountOfferConnection",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _DiscountOfferEdge_node(ctx context.Context, field graphql.CollectedField, obj *ent.DiscountOfferEdge) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DiscountOfferEdge_node(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Node, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*ent.DiscountOffer)
	fc.Result = res
	return ec.marshalODiscountOffer2wallitentDiscountOffer(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DiscountOfferEdge_node(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DiscountOfferEdge",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_DiscountOffer_id(ctx, field)
			case "amount":
				return ec.fieldContext_DiscountOffer_amount(ctx, field)
			case "type":
				return ec.fieldContext_DiscountOffer_type(ctx, field)
			case "currency":
				return ec.fieldContext_DiscountOffer_currency(ctx, field)
			case "description":
				return ec.fieldContext_DiscountOffer_description(ctx, field)
			case "merchantSpecificIdentification":
				return ec.fieldContext_DiscountOffer_merchantSpecificIdentification(ctx, field)
			case "createdAt":
				return ec.fieldContext_DiscountOffer_createdAt(ctx, field)
			case "expiresAt":
				return ec.fieldContext_DiscountOffer_expiresAt(ctx, field)
			case "ownerMerchant":
				return ec.fieldContext_DiscountOffer_ownerMerchant(ctx, field)
			case "discountEligibleUsers":
				return ec.fieldContext_DiscountOffer_discountEligibleUsers(ctx, field)
			case "discountOfferNotification":
				return ec.fieldContext_DiscountOffer_discountOfferNotification(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type DiscountOffer", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _DiscountOfferEdge_cursor(ctx context.Context, field graphql.CollectedField, obj *ent.DiscountOfferEdge) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DiscountOfferEdge_cursor(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Cursor, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(ent.Cursor)
	fc.Result = res
	return ec.marshalNCursor2wallitentCursor(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DiscountOfferEdge_cursor(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DiscountOfferEdge",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Cursor does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _InstitutionInfo_institutionId(ctx context.Context, field graphql.CollectedField, obj *model.InstitutionInfo) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_InstitutionInfo_institutionId(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.InstitutionID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_InstitutionInfo_institutionId(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "InstitutionInfo",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _InstitutionInfo_name(ctx context.Context, field graphql.CollectedField, obj *model.InstitutionInfo) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_InstitutionInfo_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_InstitutionInfo_name(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "InstitutionInfo",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _LinkTokenHost_linkToken(ctx context.Context, field graphql.CollectedField, obj *model.LinkTokenHost) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_LinkTokenHost_linkToken(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.LinkToken, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_LinkTokenHost_linkToken(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "LinkTokenHost",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Merchant_id(ctx context.Context, field graphql.CollectedField, obj *ent.Merchant) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Merchant_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNID2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Merchant_id(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Merchant",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Merchant_name(ctx context.Context, field graphql.CollectedField, obj *ent.Merchant) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Merchant_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Merchant_name(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Merchant",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Merchant_discountOffers(ctx context.Context, field graphql.CollectedField, obj *ent.Merchant) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Merchant_discountOffers(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DiscountOffers(ctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*ent.DiscountOffer)
	fc.Result = res
	return ec.marshalODiscountOffer2wallitentDiscountOffer(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Merchant_discountOffers(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Merchant",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_DiscountOffer_id(ctx, field)
			case "amount":
				return ec.fieldContext_DiscountOffer_amount(ctx, field)
			case "type":
				return ec.fieldContext_DiscountOffer_type(ctx, field)
			case "currency":
				return ec.fieldContext_DiscountOffer_currency(ctx, field)
			case "description":
				return ec.fieldContext_DiscountOffer_description(ctx, field)
			case "merchantSpecificIdentification":
				return ec.fieldContext_DiscountOffer_merchantSpecificIdentification(ctx, field)
			case "createdAt":
				return ec.fieldContext_DiscountOffer_createdAt(ctx, field)
			case "expiresAt":
				return ec.fieldContext_DiscountOffer_expiresAt(ctx, field)
			case "ownerMerchant":
				return ec.fieldContext_DiscountOffer_ownerMerchant(ctx, field)
			case "discountEligibleUsers":
				return ec.fieldContext_DiscountOffer_discountEligibleUsers(ctx, field)
			case "discountOfferNotification":
				return ec.fieldContext_DiscountOffer_discountOfferNotification(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type DiscountOffer", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_createLinkToken(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_createLinkToken(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().CreateLinkToken(rctx, fc.Args["input"].(model.CreateLinkTokenParams))
	})
	if err != nil {
		ec.Error(ctx, err)
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.LinkTokenHost)
	fc.Result = res
	return ec.marshalNLinkTokenHost2wallitgraphmodelLinkTokenHost(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_createLinkToken(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "linkToken":
				return ec.fieldContext_LinkTokenHost_linkToken(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type LinkTokenHost", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_createLinkToken_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_exchangePublicToken(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_exchangePublicToken(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().ExchangePublicToken(rctx, fc.Args["input"].(model.ExchangePublicTokenParams))
	})
	if err != nil {
		ec.Error(ctx, err)
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_exchangePublicToken(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_exchangePublicToken_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_createDiscountOffer(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_createDiscountOffer(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().CreateDiscountOffer(rctx, fc.Args["input"].(ent.CreateDiscountOfferInput))
	})
	if err != nil {
		ec.Error(ctx, err)
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*ent.DiscountOffer)
	fc.Result = res
	return ec.marshalNDiscountOffer2wallitentDiscountOffer(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_createDiscountOffer(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_DiscountOffer_id(ctx, field)
			case "amount":
				return ec.fieldContext_DiscountOffer_amount(ctx, field)
			case "type":
				return ec.fieldContext_DiscountOffer_type(ctx, field)
			case "currency":
				return ec.fieldContext_DiscountOffer_currency(ctx, field)
			case "description":
				return ec.fieldContext_DiscountOffer_description(ctx, field)
			case "merchantSpecificIdentification":
				return ec.fieldContext_DiscountOffer_merchantSpecificIdentification(ctx, field)
			case "createdAt":
				return ec.fieldContext_DiscountOffer_createdAt(ctx, field)
			case "expiresAt":
				return ec.fieldContext_DiscountOffer_expiresAt(ctx, field)
			case "ownerMerchant":
				return ec.fieldContext_DiscountOffer_ownerMerchant(ctx, field)
			case "discountEligibleUsers":
				return ec.fieldContext_DiscountOffer_discountEligibleUsers(ctx, field)
			case "discountOfferNotification":
				return ec.fieldContext_DiscountOffer_discountOfferNotification(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type DiscountOffer", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_createDiscountOffer_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_createMerchant(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_createMerchant(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().CreateMerchant(rctx, fc.Args["input"].(ent.CreateMerchantInput))
	})
	if err != nil {
		ec.Error(ctx, err)
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*ent.Merchant)
	fc.Result = res
	return ec.marshalNMerchant2wallitentMerchant(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_createMerchant(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Merchant_id(ctx, field)
			case "name":
				return ec.fieldContext_Merchant_name(ctx, field)
			case "discountOffers":
				return ec.fieldContext_Merchant_discountOffers(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Merchant", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_createMerchant_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_markNotificationsAsCheckedInApp(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_markNotificationsAsCheckedInApp(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().MarkNotificationsAsCheckedInApp(rctx, fc.Args["ids"].([]int))
	})
	if err != nil {
		ec.Error(ctx, err)
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_markNotificationsAsCheckedInApp(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_markNotificationsAsCheckedInApp_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_exchangeAuthTokenForUserProfile(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_exchangeAuthTokenForUserProfile(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().ExchangeAuthTokenForUserProfile(rctx, fc.Args["input"].(model.ExchangeAuthTokenForUserProfileInput))
	})
	if err != nil {
		ec.Error(ctx, err)
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*ent.User)
	fc.Result = res
	return ec.marshalNUser2wallitentUser(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_exchangeAuthTokenForUserProfile(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_User_id(ctx, field)
			case "identityProviderID":
				return ec.fieldContext_User_identityProviderID(ctx, field)
			case "offerFrequency":
				return ec.fieldContext_User_offerFrequency(ctx, field)
			case "homeCountry":
				return ec.fieldContext_User_homeCountry(ctx, field)
			case "homeState":
				return ec.fieldContext_User_homeState(ctx, field)
			case "homeCity":
				return ec.fieldContext_User_homeCity(ctx, field)
			case "plaidItems":
				return ec.fieldContext_User_plaidItems(ctx, field)
			case "spendingCategories":
				return ec.fieldContext_User_spendingCategories(ctx, field)
			case "notificationChannels":
				return ec.fieldContext_User_notificationChannels(ctx, field)
			case "notifications":
				return ec.fieldContext_User_notifications(ctx, field)
			case "availableDiscountOffers":
				return ec.fieldContext_User_availableDiscountOffers(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type User", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_exchangeAuthTokenForUserProfile_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_updateUser(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_updateUser(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().UpdateUser(rctx, fc.Args["id"].(int), fc.Args["input"].(*ent.UpdateUserInput))
	})
	if err != nil {
		ec.Error(ctx, err)
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*ent.User)
	fc.Result = res
	return ec.marshalNUser2wallitentUser(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_updateUser(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_User_id(ctx, field)
			case "identityProviderID":
				return ec.fieldContext_User_identityProviderID(ctx, field)
			case "offerFrequency":
				return ec.fieldContext_User_offerFrequency(ctx, field)
			case "homeCountry":
				return ec.fieldContext_User_homeCountry(ctx, field)
			case "homeState":
				return ec.fieldContext_User_homeState(ctx, field)
			case "homeCity":
				return ec.fieldContext_User_homeCity(ctx, field)
			case "plaidItems":
				return ec.fieldContext_User_plaidItems(ctx, field)
			case "spendingCategories":
				return ec.fieldContext_User_spendingCategories(ctx, field)
			case "notificationChannels":
				return ec.fieldContext_User_notificationChannels(ctx, field)
			case "notifications":
				return ec.fieldContext_User_notifications(ctx, field)
			case "availableDiscountOffers":
				return ec.fieldContext_User_availableDiscountOffers(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type User", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_updateUser_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_setSpendingCategories(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_setSpendingCategories(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().SetSpendingCategories(rctx, fc.Args["userID"].(int), fc.Args["spendingCategoryIDs"].([]int))
	})
	if err != nil {
		ec.Error(ctx, err)
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*ent.User)
	fc.Result = res
	return ec.marshalNUser2wallitentUser(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_setSpendingCategories(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_User_id(ctx, field)
			case "identityProviderID":
				return ec.fieldContext_User_identityProviderID(ctx, field)
			case "offerFrequency":
				return ec.fieldContext_User_offerFrequency(ctx, field)
			case "homeCountry":
				return ec.fieldContext_User_homeCountry(ctx, field)
			case "homeState":
				return ec.fieldContext_User_homeState(ctx, field)
			case "homeCity":
				return ec.fieldContext_User_homeCity(ctx, field)
			case "plaidItems":
				return ec.fieldContext_User_plaidItems(ctx, field)
			case "spendingCategories":
				return ec.fieldContext_User_spendingCategories(ctx, field)
			case "notificationChannels":
				return ec.fieldContext_User_notificationChannels(ctx, field)
			case "notifications":
				return ec.fieldContext_User_notifications(ctx, field)
			case "availableDiscountOffers":
				return ec.fieldContext_User_availableDiscountOffers(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type User", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_setSpendingCategories_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_setNotificationChannels(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_setNotificationChannels(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().SetNotificationChannels(rctx, fc.Args["userID"].(int), fc.Args["notificationChannel"].([]usernotificationchannelpreferences.Chanel))
	})
	if err != nil {
		ec.Error(ctx, err)
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*ent.User)
	fc.Result = res
	return ec.marshalNUser2wallitentUser(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_setNotificationChannels(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_User_id(ctx, field)
			case "identityProviderID":
				return ec.fieldContext_User_identityProviderID(ctx, field)
			case "offerFrequency":
				return ec.fieldContext_User_offerFrequency(ctx, field)
			case "homeCountry":
				return ec.fieldContext_User_homeCountry(ctx, field)
			case "homeState":
				return ec.fieldContext_User_homeState(ctx, field)
			case "homeCity":
				return ec.fieldContext_User_homeCity(ctx, field)
			case "plaidItems":
				return ec.fieldContext_User_plaidItems(ctx, field)
			case "spendingCategories":
				return ec.fieldContext_User_spendingCategories(ctx, field)
			case "notificationChannels":
				return ec.fieldContext_User_notificationChannels(ctx, field)
			case "notifications":
				return ec.fieldContext_User_notifications(ctx, field)
			case "availableDiscountOffers":
				return ec.fieldContext_User_availableDiscountOffers(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type User", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_setNotificationChannels_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_setOfferFrequency(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_setOfferFrequency(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().SetOfferFrequency(rctx, fc.Args["userID"].(int), fc.Args["frequency"].(user.OfferFrequency))
	})
	if err != nil {
		ec.Error(ctx, err)
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*ent.User)
	fc.Result = res
	return ec.marshalNUser2wallitentUser(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_setOfferFrequency(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_User_id(ctx, field)
			case "identityProviderID":
				return ec.fieldContext_User_identityProviderID(ctx, field)
			case "offerFrequency":
				return ec.fieldContext_User_offerFrequency(ctx, field)
			case "homeCountry":
				return ec.fieldContext_User_homeCountry(ctx, field)
			case "homeState":
				return ec.fieldContext_User_homeState(ctx, field)
			case "homeCity":
				return ec.fieldContext_User_homeCity(ctx, field)
			case "plaidItems":
				return ec.fieldContext_User_plaidItems(ctx, field)
			case "spendingCategories":
				return ec.fieldContext_User_spendingCategories(ctx, field)
			case "notificationChannels":
				return ec.fieldContext_User_notificationChannels(ctx, field)
			case "notifications":
				return ec.fieldContext_User_notifications(ctx, field)
			case "availableDiscountOffers":
				return ec.fieldContext_User_availableDiscountOffers(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type User", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_setOfferFrequency_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _Notification_id(ctx context.Context, field graphql.CollectedField, obj *ent.Notification) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Notification_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNID2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Notification_id(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Notification",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Notification_checkedInApp(ctx context.Context, field graphql.CollectedField, obj *ent.Notification) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Notification_checkedInApp(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CheckedInApp, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Notification_checkedInApp(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Notification",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Notification_type(ctx context.Context, field graphql.CollectedField, obj *ent.Notification) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Notification_type(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Type, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(notification.Type)
	fc.Result = res
	return ec.marshalNNotificationType2wallitentnotificationType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Notification_type(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Notification",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type NotificationType does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Notification_createdAt(ctx context.Context, field graphql.CollectedField, obj *ent.Notification) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Notification_createdAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CreatedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(time.Time)
	fc.Result = res
	return ec.marshalNTime2timeTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Notification_createdAt(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Notification",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Notification_includedInAggregatedOfferAt(ctx context.Context, field graphql.CollectedField, obj *ent.Notification) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Notification_includedInAggregatedOfferAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IncludedInAggregatedOfferAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(time.Time)
	fc.Result = res
	return ec.marshalOTime2timeTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Notification_includedInAggregatedOfferAt(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Notification",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Notification_notificationRecipient(ctx context.Context, field graphql.CollectedField, obj *ent.Notification) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Notification_notificationRecipient(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.NotificationRecipient(ctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*ent.User)
	fc.Result = res
	return ec.marshalNUser2wallitentUser(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Notification_notificationRecipient(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Notification",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_User_id(ctx, field)
			case "identityProviderID":
				return ec.fieldContext_User_identityProviderID(ctx, field)
			case "offerFrequency":
				return ec.fieldContext_User_offerFrequency(ctx, field)
			case "homeCountry":
				return ec.fieldContext_User_homeCountry(ctx, field)
			case "homeState":
				return ec.fieldContext_User_homeState(ctx, field)
			case "homeCity":
				return ec.fieldContext_User_homeCity(ctx, field)
			case "plaidItems":
				return ec.fieldContext_User_plaidItems(ctx, field)
			case "spendingCategories":
				return ec.fieldContext_User_spendingCategories(ctx, field)
			case "notificationChannels":
				return ec.fieldContext_User_notificationChannels(ctx, field)
			case "notifications":
				return ec.fieldContext_User_notifications(ctx, field)
			case "availableDiscountOffers":
				return ec.fieldContext_User_availableDiscountOffers(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type User", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Notification_notificationDiscountOffer(ctx context.Context, field graphql.CollectedField, obj *ent.Notification) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Notification_notificationDiscountOffer(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.NotificationDiscountOffer(ctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*ent.DiscountOffer)
	fc.Result = res
	return ec.marshalODiscountOffer2wallitentDiscountOffer(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Notification_notificationDiscountOffer(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Notification",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_DiscountOffer_id(ctx, field)
			case "amount":
				return ec.fieldContext_DiscountOffer_amount(ctx, field)
			case "type":
				return ec.fieldContext_DiscountOffer_type(ctx, field)
			case "currency":
				return ec.fieldContext_DiscountOffer_currency(ctx, field)
			case "description":
				return ec.fieldContext_DiscountOffer_description(ctx, field)
			case "merchantSpecificIdentification":
				return ec.fieldContext_DiscountOffer_merchantSpecificIdentification(ctx, field)
			case "createdAt":
				return ec.fieldContext_DiscountOffer_createdAt(ctx, field)
			case "expiresAt":
				return ec.fieldContext_DiscountOffer_expiresAt(ctx, field)
			case "ownerMerchant":
				return ec.fieldContext_DiscountOffer_ownerMerchant(ctx, field)
			case "discountEligibleUsers":
				return ec.fieldContext_DiscountOffer_discountEligibleUsers(ctx, field)
			case "discountOfferNotification":
				return ec.fieldContext_DiscountOffer_discountOfferNotification(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type DiscountOffer", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _NotificationConnection_edges(ctx context.Context, field graphql.CollectedField, obj *ent.NotificationConnection) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_NotificationConnection_edges(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Edges, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*ent.NotificationEdge)
	fc.Result = res
	return ec.marshalONotificationEdge2wallitentNotificationEdge(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_NotificationConnection_edges(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "NotificationConnection",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "node":
				return ec.fieldContext_NotificationEdge_node(ctx, field)
			case "cursor":
				return ec.fieldContext_NotificationEdge_cursor(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type NotificationEdge", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _NotificationConnection_pageInfo(ctx context.Context, field graphql.CollectedField, obj *ent.NotificationConnection) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_NotificationConnection_pageInfo(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PageInfo, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(ent.PageInfo)
	fc.Result = res
	return ec.marshalNPageInfo2wallitentPageInfo(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_NotificationConnection_pageInfo(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "NotificationConnection",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "hasNextPage":
				return ec.fieldContext_PageInfo_hasNextPage(ctx, field)
			case "hasPreviousPage":
				return ec.fieldContext_PageInfo_hasPreviousPage(ctx, field)
			case "startCursor":
				return ec.fieldContext_PageInfo_startCursor(ctx, field)
			case "endCursor":
				return ec.fieldContext_PageInfo_endCursor(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type PageInfo", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _NotificationConnection_totalCount(ctx context.Context, field graphql.CollectedField, obj *ent.NotificationConnection) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_NotificationConnection_totalCount(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TotalCount, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_NotificationConnection_totalCount(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "NotificationConnection",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _NotificationEdge_node(ctx context.Context, field graphql.CollectedField, obj *ent.NotificationEdge) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_NotificationEdge_node(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Node, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*ent.Notification)
	fc.Result = res
	return ec.marshalONotification2wallitentNotification(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_NotificationEdge_node(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "NotificationEdge",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Notification_id(ctx, field)
			case "checkedInApp":
				return ec.fieldContext_Notification_checkedInApp(ctx, field)
			case "type":
				return ec.fieldContext_Notification_type(ctx, field)
			case "createdAt":
				return ec.fieldContext_Notification_createdAt(ctx, field)
			case "includedInAggregatedOfferAt":
				return ec.fieldContext_Notification_includedInAggregatedOfferAt(ctx, field)
			case "notificationRecipient":
				return ec.fieldContext_Notification_notificationRecipient(ctx, field)
			case "notificationDiscountOffer":
				return ec.fieldContext_Notification_notificationDiscountOffer(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Notification", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _NotificationEdge_cursor(ctx context.Context, field graphql.CollectedField, obj *ent.NotificationEdge) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_NotificationEdge_cursor(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Cursor, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(ent.Cursor)
	fc.Result = res
	return ec.marshalNCursor2wallitentCursor(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_NotificationEdge_cursor(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "NotificationEdge",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Cursor does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _PageInfo_hasNextPage(ctx context.Context, field graphql.CollectedField, obj *ent.PageInfo) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PageInfo_hasNextPage(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.HasNextPage, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PageInfo_hasNextPage(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PageInfo",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _PageInfo_hasPreviousPage(ctx context.Context, field graphql.CollectedField, obj *ent.PageInfo) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PageInfo_hasPreviousPage(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.HasPreviousPage, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PageInfo_hasPreviousPage(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PageInfo",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _PageInfo_startCursor(ctx context.Context, field graphql.CollectedField, obj *ent.PageInfo) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PageInfo_startCursor(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.StartCursor, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*ent.Cursor)
	fc.Result = res
	return ec.marshalOCursor2wallitentCursor(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PageInfo_startCursor(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PageInfo",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Cursor does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _PageInfo_endCursor(ctx context.Context, field graphql.CollectedField, obj *ent.PageInfo) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PageInfo_endCursor(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.EndCursor, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*ent.Cursor)
	fc.Result = res
	return ec.marshalOCursor2wallitentCursor(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PageInfo_endCursor(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PageInfo",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Cursor does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _PlaidAccountBalances_available(ctx context.Context, field graphql.CollectedField, obj *model.PlaidAccountBalances) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PlaidAccountBalances_available(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Available, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(float64)
	fc.Result = res
	return ec.marshalNFloat2float64(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PlaidAccountBalances_available(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PlaidAccountBalances",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Float does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _PlaidAccountBalances_current(ctx context.Context, field graphql.CollectedField, obj *model.PlaidAccountBalances) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PlaidAccountBalances_current(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Current, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(float64)
	fc.Result = res
	return ec.marshalNFloat2float64(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PlaidAccountBalances_current(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PlaidAccountBalances",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Float does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _PlaidAccountBalances_isoCurrencyCode(ctx context.Context, field graphql.CollectedField, obj *model.PlaidAccountBalances) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PlaidAccountBalances_isoCurrencyCode(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IsoCurrencyCode, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PlaidAccountBalances_isoCurrencyCode(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PlaidAccountBalances",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _PlaidAccountInfo_accountId(ctx context.Context, field graphql.CollectedField, obj *model.PlaidAccountInfo) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PlaidAccountInfo_accountId(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.AccountID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PlaidAccountInfo_accountId(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PlaidAccountInfo",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _PlaidAccountInfo_balances(ctx context.Context, field graphql.CollectedField, obj *model.PlaidAccountInfo) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PlaidAccountInfo_balances(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Balances, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.PlaidAccountBalances)
	fc.Result = res
	return ec.marshalNPlaidAccountBalances2wallitgraphmodelPlaidAccountBalances(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PlaidAccountInfo_balances(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PlaidAccountInfo",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "available":
				return ec.fieldContext_PlaidAccountBalances_available(ctx, field)
			case "current":
				return ec.fieldContext_PlaidAccountBalances_current(ctx, field)
			case "isoCurrencyCode":
				return ec.fieldContext_PlaidAccountBalances_isoCurrencyCode(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type PlaidAccountBalances", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _PlaidAccountInfo_mask(ctx context.Context, field graphql.CollectedField, obj *model.PlaidAccountInfo) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PlaidAccountInfo_mask(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Mask, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PlaidAccountInfo_mask(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PlaidAccountInfo",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _PlaidAccountInfo_name(ctx context.Context, field graphql.CollectedField, obj *model.PlaidAccountInfo) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PlaidAccountInfo_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PlaidAccountInfo_name(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PlaidAccountInfo",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _PlaidAccountInfo_officialName(ctx context.Context, field graphql.CollectedField, obj *model.PlaidAccountInfo) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PlaidAccountInfo_officialName(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.OfficialName, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PlaidAccountInfo_officialName(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PlaidAccountInfo",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _PlaidAccountInfo_type(ctx context.Context, field graphql.CollectedField, obj *model.PlaidAccountInfo) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PlaidAccountInfo_type(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Type, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PlaidAccountInfo_type(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PlaidAccountInfo",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _PlaidAccountInfo_transactions(ctx context.Context, field graphql.CollectedField, obj *model.PlaidAccountInfo) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PlaidAccountInfo_transactions(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Transactions, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*ent.TransactionConnection)
	fc.Result = res
	return ec.marshalNTransactionConnection2wallitentTransactionConnection(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PlaidAccountInfo_transactions(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PlaidAccountInfo",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "edges":
				return ec.fieldContext_TransactionConnection_edges(ctx, field)
			case "pageInfo":
				return ec.fieldContext_TransactionConnection_pageInfo(ctx, field)
			case "totalCount":
				return ec.fieldContext_TransactionConnection_totalCount(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type TransactionConnection", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_PlaidAccountInfo_transactions_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _PlaidInstitution_id(ctx context.Context, field graphql.CollectedField, obj *ent.PlaidInstitution) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PlaidInstitution_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNID2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PlaidInstitution_id(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PlaidInstitution",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _PlaidInstitution_institutionID(ctx context.Context, field graphql.CollectedField, obj *ent.PlaidInstitution) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PlaidInstitution_institutionID(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.InstitutionID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PlaidInstitution_institutionID(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PlaidInstitution",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _PlaidInstitution_name(ctx context.Context, field graphql.CollectedField, obj *ent.PlaidInstitution) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PlaidInstitution_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PlaidInstitution_name(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PlaidInstitution",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _PlaidInstitution_plaidItem(ctx context.Context, field graphql.CollectedField, obj *ent.PlaidInstitution) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PlaidInstitution_plaidItem(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PlaidItem(ctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*ent.PlaidItem)
	fc.Result = res
	return ec.marshalOPlaidItem2wallitentPlaidItem(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PlaidInstitution_plaidItem(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PlaidInstitution",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_PlaidItem_id(ctx, field)
			case "itemID":
				return ec.fieldContext_PlaidItem_itemID(ctx, field)
			case "accessToken":
				return ec.fieldContext_PlaidItem_accessToken(ctx, field)
			case "createdAt":
				return ec.fieldContext_PlaidItem_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_PlaidItem_updatedAt(ctx, field)
			case "owner":
				return ec.fieldContext_PlaidItem_owner(ctx, field)
			case "transactionSyncs":
				return ec.fieldContext_PlaidItem_transactionSyncs(ctx, field)
			case "institution":
				return ec.fieldContext_PlaidItem_institution(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type PlaidItem", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _PlaidInstitution_accounts(ctx context.Context, field graphql.CollectedField, obj *ent.PlaidInstitution) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PlaidInstitution_accounts(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Accounts(ctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*ent.PlaidInstitutionAccount)
	fc.Result = res
	return ec.marshalOPlaidInstitutionAccount2wallitentPlaidInstitutionAccount(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PlaidInstitution_accounts(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PlaidInstitution",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_PlaidInstitutionAccount_id(ctx, field)
			case "accountID":
				return ec.fieldContext_PlaidInstitutionAccount_accountID(ctx, field)
			case "balanceAvailable":
				return ec.fieldContext_PlaidInstitutionAccount_balanceAvailable(ctx, field)
			case "balanceCurrent":
				return ec.fieldContext_PlaidInstitutionAccount_balanceCurrent(ctx, field)
			case "balanceIsoCurrencyCode":
				return ec.fieldContext_PlaidInstitutionAccount_balanceIsoCurrencyCode(ctx, field)
			case "mask":
				return ec.fieldContext_PlaidInstitutionAccount_mask(ctx, field)
			case "name":
				return ec.fieldContext_PlaidInstitutionAccount_name(ctx, field)
			case "officialName":
				return ec.fieldContext_PlaidInstitutionAccount_officialName(ctx, field)
			case "type":
				return ec.fieldContext_PlaidInstitutionAccount_type(ctx, field)
			case "parentInstitution":
				return ec.fieldContext_PlaidInstitutionAccount_parentInstitution(ctx, field)
			case "transactions":
				return ec.fieldContext_PlaidInstitutionAccount_transactions(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type PlaidInstitutionAccount", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _PlaidInstitutionAccount_id(ctx context.Context, field graphql.CollectedField, obj *ent.PlaidInstitutionAccount) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PlaidInstitutionAccount_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNID2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PlaidInstitutionAccount_id(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PlaidInstitutionAccount",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _PlaidInstitutionAccount_accountID(ctx context.Context, field graphql.CollectedField, obj *ent.PlaidInstitutionAccount) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PlaidInstitutionAccount_accountID(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.AccountID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PlaidInstitutionAccount_accountID(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PlaidInstitutionAccount",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _PlaidInstitutionAccount_balanceAvailable(ctx context.Context, field graphql.CollectedField, obj *ent.PlaidInstitutionAccount) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PlaidInstitutionAccount_balanceAvailable(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.BalanceAvailable, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(float64)
	fc.Result = res
	return ec.marshalNFloat2float64(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PlaidInstitutionAccount_balanceAvailable(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PlaidInstitutionAccount",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Float does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _PlaidInstitutionAccount_balanceCurrent(ctx context.Context, field graphql.CollectedField, obj *ent.PlaidInstitutionAccount) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PlaidInstitutionAccount_balanceCurrent(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.BalanceCurrent, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(float64)
	fc.Result = res
	return ec.marshalNFloat2float64(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PlaidInstitutionAccount_balanceCurrent(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PlaidInstitutionAccount",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Float does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _PlaidInstitutionAccount_balanceIsoCurrencyCode(ctx context.Context, field graphql.CollectedField, obj *ent.PlaidInstitutionAccount) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PlaidInstitutionAccount_balanceIsoCurrencyCode(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.BalanceIsoCurrencyCode, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PlaidInstitutionAccount_balanceIsoCurrencyCode(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PlaidInstitutionAccount",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _PlaidInstitutionAccount_mask(ctx context.Context, field graphql.CollectedField, obj *ent.PlaidInstitutionAccount) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PlaidInstitutionAccount_mask(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Mask, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PlaidInstitutionAccount_mask(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PlaidInstitutionAccount",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _PlaidInstitutionAccount_name(ctx context.Context, field graphql.CollectedField, obj *ent.PlaidInstitutionAccount) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PlaidInstitutionAccount_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PlaidInstitutionAccount_name(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PlaidInstitutionAccount",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _PlaidInstitutionAccount_officialName(ctx context.Context, field graphql.CollectedField, obj *ent.PlaidInstitutionAccount) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PlaidInstitutionAccount_officialName(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.OfficialName, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PlaidInstitutionAccount_officialName(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PlaidInstitutionAccount",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _PlaidInstitutionAccount_type(ctx context.Context, field graphql.CollectedField, obj *ent.PlaidInstitutionAccount) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PlaidInstitutionAccount_type(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Type, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PlaidInstitutionAccount_type(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PlaidInstitutionAccount",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _PlaidInstitutionAccount_parentInstitution(ctx context.Context, field graphql.CollectedField, obj *ent.PlaidInstitutionAccount) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PlaidInstitutionAccount_parentInstitution(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ParentInstitution(ctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*ent.PlaidInstitution)
	fc.Result = res
	return ec.marshalOPlaidInstitution2wallitentPlaidInstitution(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PlaidInstitutionAccount_parentInstitution(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PlaidInstitutionAccount",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_PlaidInstitution_id(ctx, field)
			case "institutionID":
				return ec.fieldContext_PlaidInstitution_institutionID(ctx, field)
			case "name":
				return ec.fieldContext_PlaidInstitution_name(ctx, field)
			case "plaidItem":
				return ec.fieldContext_PlaidInstitution_plaidItem(ctx, field)
			case "accounts":
				return ec.fieldContext_PlaidInstitution_accounts(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type PlaidInstitution", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _PlaidInstitutionAccount_transactions(ctx context.Context, field graphql.CollectedField, obj *ent.PlaidInstitutionAccount) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PlaidInstitutionAccount_transactions(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Transactions(ctx, fc.Args["after"].(*ent.Cursor), fc.Args["first"].(*int), fc.Args["before"].(*ent.Cursor), fc.Args["last"].(*int), fc.Args["orderBy"].(*ent.TransactionOrder), fc.Args["where"].(*ent.TransactionWhereInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*ent.TransactionConnection)
	fc.Result = res
	return ec.marshalNTransactionConnection2wallitentTransactionConnection(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PlaidInstitutionAccount_transactions(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PlaidInstitutionAccount",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "edges":
				return ec.fieldContext_TransactionConnection_edges(ctx, field)
			case "pageInfo":
				return ec.fieldContext_TransactionConnection_pageInfo(ctx, field)
			case "totalCount":
				return ec.fieldContext_TransactionConnection_totalCount(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type TransactionConnection", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_PlaidInstitutionAccount_transactions_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _PlaidInstitutionAccountConnection_edges(ctx context.Context, field graphql.CollectedField, obj *ent.PlaidInstitutionAccountConnection) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PlaidInstitutionAccountConnection_edges(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Edges, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*ent.PlaidInstitutionAccountEdge)
	fc.Result = res
	return ec.marshalOPlaidInstitutionAccountEdge2wallitentPlaidInstitutionAccountEdge(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PlaidInstitutionAccountConnection_edges(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PlaidInstitutionAccountConnection",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "node":
				return ec.fieldContext_PlaidInstitutionAccountEdge_node(ctx, field)
			case "cursor":
				return ec.fieldContext_PlaidInstitutionAccountEdge_cursor(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type PlaidInstitutionAccountEdge", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _PlaidInstitutionAccountConnection_pageInfo(ctx context.Context, field graphql.CollectedField, obj *ent.PlaidInstitutionAccountConnection) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PlaidInstitutionAccountConnection_pageInfo(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PageInfo, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(ent.PageInfo)
	fc.Result = res
	return ec.marshalNPageInfo2wallitentPageInfo(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PlaidInstitutionAccountConnection_pageInfo(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PlaidInstitutionAccountConnection",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "hasNextPage":
				return ec.fieldContext_PageInfo_hasNextPage(ctx, field)
			case "hasPreviousPage":
				return ec.fieldContext_PageInfo_hasPreviousPage(ctx, field)
			case "startCursor":
				return ec.fieldContext_PageInfo_startCursor(ctx, field)
			case "endCursor":
				return ec.fieldContext_PageInfo_endCursor(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type PageInfo", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _PlaidInstitutionAccountConnection_totalCount(ctx context.Context, field graphql.CollectedField, obj *ent.PlaidInstitutionAccountConnection) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PlaidInstitutionAccountConnection_totalCount(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TotalCount, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PlaidInstitutionAccountConnection_totalCount(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PlaidInstitutionAccountConnection",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _PlaidInstitutionAccountEdge_node(ctx context.Context, field graphql.CollectedField, obj *ent.PlaidInstitutionAccountEdge) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PlaidInstitutionAccountEdge_node(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Node, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*ent.PlaidInstitutionAccount)
	fc.Result = res
	return ec.marshalOPlaidInstitutionAccount2wallitentPlaidInstitutionAccount(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PlaidInstitutionAccountEdge_node(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PlaidInstitutionAccountEdge",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_PlaidInstitutionAccount_id(ctx, field)
			case "accountID":
				return ec.fieldContext_PlaidInstitutionAccount_accountID(ctx, field)
			case "balanceAvailable":
				return ec.fieldContext_PlaidInstitutionAccount_balanceAvailable(ctx, field)
			case "balanceCurrent":
				return ec.fieldContext_PlaidInstitutionAccount_balanceCurrent(ctx, field)
			case "balanceIsoCurrencyCode":
				return ec.fieldContext_PlaidInstitutionAccount_balanceIsoCurrencyCode(ctx, field)
			case "mask":
				return ec.fieldContext_PlaidInstitutionAccount_mask(ctx, field)
			case "name":
				return ec.fieldContext_PlaidInstitutionAccount_name(ctx, field)
			case "officialName":
				return ec.fieldContext_PlaidInstitutionAccount_officialName(ctx, field)
			case "type":
				return ec.fieldContext_PlaidInstitutionAccount_type(ctx, field)
			case "parentInstitution":
				return ec.fieldContext_PlaidInstitutionAccount_parentInstitution(ctx, field)
			case "transactions":
				return ec.fieldContext_PlaidInstitutionAccount_transactions(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type PlaidInstitutionAccount", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _PlaidInstitutionAccountEdge_cursor(ctx context.Context, field graphql.CollectedField, obj *ent.PlaidInstitutionAccountEdge) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PlaidInstitutionAccountEdge_cursor(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Cursor, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(ent.Cursor)
	fc.Result = res
	return ec.marshalNCursor2wallitentCursor(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PlaidInstitutionAccountEdge_cursor(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PlaidInstitutionAccountEdge",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Cursor does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _PlaidInstitutionConnection_edges(ctx context.Context, field graphql.CollectedField, obj *ent.PlaidInstitutionConnection) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PlaidInstitutionConnection_edges(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Edges, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*ent.PlaidInstitutionEdge)
	fc.Result = res
	return ec.marshalOPlaidInstitutionEdge2wallitentPlaidInstitutionEdge(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PlaidInstitutionConnection_edges(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PlaidInstitutionConnection",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "node":
				return ec.fieldContext_PlaidInstitutionEdge_node(ctx, field)
			case "cursor":
				return ec.fieldContext_PlaidInstitutionEdge_cursor(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type PlaidInstitutionEdge", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _PlaidInstitutionConnection_pageInfo(ctx context.Context, field graphql.CollectedField, obj *ent.PlaidInstitutionConnection) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PlaidInstitutionConnection_pageInfo(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PageInfo, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(ent.PageInfo)
	fc.Result = res
	return ec.marshalNPageInfo2wallitentPageInfo(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PlaidInstitutionConnection_pageInfo(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PlaidInstitutionConnection",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "hasNextPage":
				return ec.fieldContext_PageInfo_hasNextPage(ctx, field)
			case "hasPreviousPage":
				return ec.fieldContext_PageInfo_hasPreviousPage(ctx, field)
			case "startCursor":
				return ec.fieldContext_PageInfo_startCursor(ctx, field)
			case "endCursor":
				return ec.fieldContext_PageInfo_endCursor(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type PageInfo", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _PlaidInstitutionConnection_totalCount(ctx context.Context, field graphql.CollectedField, obj *ent.PlaidInstitutionConnection) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PlaidInstitutionConnection_totalCount(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TotalCount, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PlaidInstitutionConnection_totalCount(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PlaidInstitutionConnection",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _PlaidInstitutionEdge_node(ctx context.Context, field graphql.CollectedField, obj *ent.PlaidInstitutionEdge) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PlaidInstitutionEdge_node(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Node, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*ent.PlaidInstitution)
	fc.Result = res
	return ec.marshalOPlaidInstitution2wallitentPlaidInstitution(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PlaidInstitutionEdge_node(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PlaidInstitutionEdge",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_PlaidInstitution_id(ctx, field)
			case "institutionID":
				return ec.fieldContext_PlaidInstitution_institutionID(ctx, field)
			case "name":
				return ec.fieldContext_PlaidInstitution_name(ctx, field)
			case "plaidItem":
				return ec.fieldContext_PlaidInstitution_plaidItem(ctx, field)
			case "accounts":
				return ec.fieldContext_PlaidInstitution_accounts(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type PlaidInstitution", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _PlaidInstitutionEdge_cursor(ctx context.Context, field graphql.CollectedField, obj *ent.PlaidInstitutionEdge) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PlaidInstitutionEdge_cursor(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Cursor, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(ent.Cursor)
	fc.Result = res
	return ec.marshalNCursor2wallitentCursor(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PlaidInstitutionEdge_cursor(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PlaidInstitutionEdge",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Cursor does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _PlaidItem_id(ctx context.Context, field graphql.CollectedField, obj *ent.PlaidItem) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PlaidItem_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNID2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PlaidItem_id(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PlaidItem",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _PlaidItem_itemID(ctx context.Context, field graphql.CollectedField, obj *ent.PlaidItem) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PlaidItem_itemID(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ItemID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PlaidItem_itemID(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PlaidItem",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _PlaidItem_accessToken(ctx context.Context, field graphql.CollectedField, obj *ent.PlaidItem) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PlaidItem_accessToken(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.AccessToken, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PlaidItem_accessToken(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PlaidItem",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _PlaidItem_createdAt(ctx context.Context, field graphql.CollectedField, obj *ent.PlaidItem) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PlaidItem_createdAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CreatedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(time.Time)
	fc.Result = res
	return ec.marshalNTime2timeTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PlaidItem_createdAt(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PlaidItem",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _PlaidItem_updatedAt(ctx context.Context, field graphql.CollectedField, obj *ent.PlaidItem) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PlaidItem_updatedAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.UpdatedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(time.Time)
	fc.Result = res
	return ec.marshalNTime2timeTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PlaidItem_updatedAt(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PlaidItem",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _PlaidItem_owner(ctx context.Context, field graphql.CollectedField, obj *ent.PlaidItem) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PlaidItem_owner(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Owner(ctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*ent.User)
	fc.Result = res
	return ec.marshalOUser2wallitentUser(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PlaidItem_owner(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PlaidItem",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_User_id(ctx, field)
			case "identityProviderID":
				return ec.fieldContext_User_identityProviderID(ctx, field)
			case "offerFrequency":
				return ec.fieldContext_User_offerFrequency(ctx, field)
			case "homeCountry":
				return ec.fieldContext_User_homeCountry(ctx, field)
			case "homeState":
				return ec.fieldContext_User_homeState(ctx, field)
			case "homeCity":
				return ec.fieldContext_User_homeCity(ctx, field)
			case "plaidItems":
				return ec.fieldContext_User_plaidItems(ctx, field)
			case "spendingCategories":
				return ec.fieldContext_User_spendingCategories(ctx, field)
			case "notificationChannels":
				return ec.fieldContext_User_notificationChannels(ctx, field)
			case "notifications":
				return ec.fieldContext_User_notifications(ctx, field)
			case "availableDiscountOffers":
				return ec.fieldContext_User_availableDiscountOffers(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type User", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _PlaidItem_transactionSyncs(ctx context.Context, field graphql.CollectedField, obj *ent.PlaidItem) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PlaidItem_transactionSyncs(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TransactionSyncs(ctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*ent.TransactionSync)
	fc.Result = res
	return ec.marshalOTransactionSync2wallitentTransactionSync(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PlaidItem_transactionSyncs(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PlaidItem",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_TransactionSync_id(ctx, field)
			case "createdAt":
				return ec.fieldContext_TransactionSync_createdAt(ctx, field)
			case "cursor":
				return ec.fieldContext_TransactionSync_cursor(ctx, field)
			case "item":
				return ec.fieldContext_TransactionSync_item(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type TransactionSync", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _PlaidItem_institution(ctx context.Context, field graphql.CollectedField, obj *ent.PlaidItem) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PlaidItem_institution(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Institution(ctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*ent.PlaidInstitution)
	fc.Result = res
	return ec.marshalOPlaidInstitution2wallitentPlaidInstitution(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PlaidItem_institution(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PlaidItem",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_PlaidInstitution_id(ctx, field)
			case "institutionID":
				return ec.fieldContext_PlaidInstitution_institutionID(ctx, field)
			case "name":
				return ec.fieldContext_PlaidInstitution_name(ctx, field)
			case "plaidItem":
				return ec.fieldContext_PlaidInstitution_plaidItem(ctx, field)
			case "accounts":
				return ec.fieldContext_PlaidInstitution_accounts(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type PlaidInstitution", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _PlaidItemConnection_edges(ctx context.Context, field graphql.CollectedField, obj *ent.PlaidItemConnection) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PlaidItemConnection_edges(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Edges, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*ent.PlaidItemEdge)
	fc.Result = res
	return ec.marshalOPlaidItemEdge2wallitentPlaidItemEdge(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PlaidItemConnection_edges(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PlaidItemConnection",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "node":
				return ec.fieldContext_PlaidItemEdge_node(ctx, field)
			case "cursor":
				return ec.fieldContext_PlaidItemEdge_cursor(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type PlaidItemEdge", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _PlaidItemConnection_pageInfo(ctx context.Context, field graphql.CollectedField, obj *ent.PlaidItemConnection) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PlaidItemConnection_pageInfo(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PageInfo, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(ent.PageInfo)
	fc.Result = res
	return ec.marshalNPageInfo2wallitentPageInfo(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PlaidItemConnection_pageInfo(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PlaidItemConnection",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "hasNextPage":
				return ec.fieldContext_PageInfo_hasNextPage(ctx, field)
			case "hasPreviousPage":
				return ec.fieldContext_PageInfo_hasPreviousPage(ctx, field)
			case "startCursor":
				return ec.fieldContext_PageInfo_startCursor(ctx, field)
			case "endCursor":
				return ec.fieldContext_PageInfo_endCursor(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type PageInfo", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _PlaidItemConnection_totalCount(ctx context.Context, field graphql.CollectedField, obj *ent.PlaidItemConnection) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PlaidItemConnection_totalCount(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TotalCount, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PlaidItemConnection_totalCount(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PlaidItemConnection",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _PlaidItemEdge_node(ctx context.Context, field graphql.CollectedField, obj *ent.PlaidItemEdge) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PlaidItemEdge_node(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Node, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*ent.PlaidItem)
	fc.Result = res
	return ec.marshalOPlaidItem2wallitentPlaidItem(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PlaidItemEdge_node(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PlaidItemEdge",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_PlaidItem_id(ctx, field)
			case "itemID":
				return ec.fieldContext_PlaidItem_itemID(ctx, field)
			case "accessToken":
				return ec.fieldContext_PlaidItem_accessToken(ctx, field)
			case "createdAt":
				return ec.fieldContext_PlaidItem_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_PlaidItem_updatedAt(ctx, field)
			case "owner":
				return ec.fieldContext_PlaidItem_owner(ctx, field)
			case "transactionSyncs":
				return ec.fieldContext_PlaidItem_transactionSyncs(ctx, field)
			case "institution":
				return ec.fieldContext_PlaidItem_institution(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type PlaidItem", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _PlaidItemEdge_cursor(ctx context.Context, field graphql.CollectedField, obj *ent.PlaidItemEdge) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PlaidItemEdge_cursor(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Cursor, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(ent.Cursor)
	fc.Result = res
	return ec.marshalNCursor2wallitentCursor(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PlaidItemEdge_cursor(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PlaidItemEdge",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Cursor does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Query_node(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_node(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().Node(rctx, fc.Args["id"].(int))
	})
	if err != nil {
		ec.Error(ctx, err)
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(ent.Noder)
	fc.Result = res
	return ec.marshalONode2wallitentNoder(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_node(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("FieldContext.Child cannot be called on type INTERFACE")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_node_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _Query_nodes(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_nodes(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().Nodes(rctx, fc.Args["ids"].([]int))
	})
	if err != nil {
		ec.Error(ctx, err)
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]ent.Noder)
	fc.Result = res
	return ec.marshalNNode2wallitentNoder(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_nodes(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("FieldContext.Child cannot be called on type INTERFACE")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_nodes_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _Query_discountOffers(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_discountOffers(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().DiscountOffers(rctx, fc.Args["after"].(*ent.Cursor), fc.Args["first"].(*int), fc.Args["before"].(*ent.Cursor), fc.Args["last"].(*int), fc.Args["orderBy"].(*ent.DiscountOfferOrder), fc.Args["where"].(*ent.DiscountOfferWhereInput))
	})
	if err != nil {
		ec.Error(ctx, err)
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*ent.DiscountOfferConnection)
	fc.Result = res
	return ec.marshalNDiscountOfferConnection2wallitentDiscountOfferConnection(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_discountOffers(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "edges":
				return ec.fieldContext_DiscountOfferConnection_edges(ctx, field)
			case "pageInfo":
				return ec.fieldContext_DiscountOfferConnection_pageInfo(ctx, field)
			case "totalCount":
				return ec.fieldContext_DiscountOfferConnection_totalCount(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type DiscountOfferConnection", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_discountOffers_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _Query_notifications(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_notifications(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().Notifications(rctx, fc.Args["after"].(*ent.Cursor), fc.Args["first"].(*int), fc.Args["before"].(*ent.Cursor), fc.Args["last"].(*int), fc.Args["orderBy"].(*ent.NotificationOrder), fc.Args["where"].(*ent.NotificationWhereInput))
	})
	if err != nil {
		ec.Error(ctx, err)
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*ent.NotificationConnection)
	fc.Result = res
	return ec.marshalNNotificationConnection2wallitentNotificationConnection(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_notifications(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "edges":
				return ec.fieldContext_NotificationConnection_edges(ctx, field)
			case "pageInfo":
				return ec.fieldContext_NotificationConnection_pageInfo(ctx, field)
			case "totalCount":
				return ec.fieldContext_NotificationConnection_totalCount(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type NotificationConnection", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_notifications_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _Query_plaidItems(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_plaidItems(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().PlaidItems(rctx, fc.Args["after"].(*ent.Cursor), fc.Args["first"].(*int), fc.Args["before"].(*ent.Cursor), fc.Args["last"].(*int), fc.Args["where"].(*ent.PlaidItemWhereInput))
	})
	if err != nil {
		ec.Error(ctx, err)
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*ent.PlaidItemConnection)
	fc.Result = res
	return ec.marshalNPlaidItemConnection2wallitentPlaidItemConnection(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_plaidItems(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "edges":
				return ec.fieldContext_PlaidItemConnection_edges(ctx, field)
			case "pageInfo":
				return ec.fieldContext_PlaidItemConnection_pageInfo(ctx, field)
			case "totalCount":
				return ec.fieldContext_PlaidItemConnection_totalCount(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type PlaidItemConnection", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_plaidItems_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _Query_transactions(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_transactions(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().Transactions(rctx, fc.Args["after"].(*ent.Cursor), fc.Args["first"].(*int), fc.Args["before"].(*ent.Cursor), fc.Args["last"].(*int), fc.Args["orderBy"].(*ent.TransactionOrder), fc.Args["where"].(*ent.TransactionWhereInput))
	})
	if err != nil {
		ec.Error(ctx, err)
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*ent.TransactionConnection)
	fc.Result = res
	return ec.marshalNTransactionConnection2wallitentTransactionConnection(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_transactions(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "edges":
				return ec.fieldContext_TransactionConnection_edges(ctx, field)
			case "pageInfo":
				return ec.fieldContext_TransactionConnection_pageInfo(ctx, field)
			case "totalCount":
				return ec.fieldContext_TransactionConnection_totalCount(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type TransactionConnection", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_transactions_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _Query_plaidInstitutionAccounts(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_plaidInstitutionAccounts(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().PlaidInstitutionAccounts(rctx, fc.Args["after"].(*ent.Cursor), fc.Args["first"].(*int), fc.Args["before"].(*ent.Cursor), fc.Args["last"].(*int), fc.Args["where"].(*ent.PlaidInstitutionAccountWhereInput))
	})
	if err != nil {
		ec.Error(ctx, err)
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*ent.PlaidInstitutionAccountConnection)
	fc.Result = res
	return ec.marshalOPlaidInstitutionAccountConnection2wallitentPlaidInstitutionAccountConnection(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_plaidInstitutionAccounts(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "edges":
				return ec.fieldContext_PlaidInstitutionAccountConnection_edges(ctx, field)
			case "pageInfo":
				return ec.fieldContext_PlaidInstitutionAccountConnection_pageInfo(ctx, field)
			case "totalCount":
				return ec.fieldContext_PlaidInstitutionAccountConnection_totalCount(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type PlaidInstitutionAccountConnection", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_plaidInstitutionAccounts_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _Query_plaidInstitutions(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_plaidInstitutions(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().PlaidInstitutions(rctx, fc.Args["after"].(*ent.Cursor), fc.Args["first"].(*int), fc.Args["before"].(*ent.Cursor), fc.Args["last"].(*int), fc.Args["where"].(*ent.PlaidInstitutionWhereInput))
	})
	if err != nil {
		ec.Error(ctx, err)
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*ent.PlaidInstitutionConnection)
	fc.Result = res
	return ec.marshalOPlaidInstitutionConnection2wallitentPlaidInstitutionConnection(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_plaidInstitutions(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "edges":
				return ec.fieldContext_PlaidInstitutionConnection_edges(ctx, field)
			case "pageInfo":
				return ec.fieldContext_PlaidInstitutionConnection_pageInfo(ctx, field)
			case "totalCount":
				return ec.fieldContext_PlaidInstitutionConnection_totalCount(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type PlaidInstitutionConnection", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_plaidInstitutions_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _Query_spendingCategories(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_spendingCategories(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().SpendingCategories(rctx, fc.Args["after"].(*ent.Cursor), fc.Args["first"].(*int), fc.Args["before"].(*ent.Cursor), fc.Args["last"].(*int), fc.Args["where"].(*ent.SpendingCategoryWhereInput))
	})
	if err != nil {
		ec.Error(ctx, err)
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*ent.SpendingCategoryConnection)
	fc.Result = res
	return ec.marshalNSpendingCategoryConnection2wallitentSpendingCategoryConnection(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_spendingCategories(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "edges":
				return ec.fieldContext_SpendingCategoryConnection_edges(ctx, field)
			case "pageInfo":
				return ec.fieldContext_SpendingCategoryConnection_pageInfo(ctx, field)
			case "totalCount":
				return ec.fieldContext_SpendingCategoryConnection_totalCount(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type SpendingCategoryConnection", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_spendingCategories_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _Query_notificationChannels(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_notificationChannels(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().NotificationChannels(rctx, fc.Args["after"].(*ent.Cursor), fc.Args["first"].(*int), fc.Args["before"].(*ent.Cursor), fc.Args["last"].(*int), fc.Args["where"].(*ent.UserNotificationChannelPreferencesWhereInput))
	})
	if err != nil {
		ec.Error(ctx, err)
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*ent.UserNotificationChannelPreferencesConnection)
	fc.Result = res
	return ec.marshalNUserNotificationChannelPreferencesConnection2wallitentUserNotificationChannelPreferencesConnection(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_notificationChannels(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "edges":
				return ec.fieldContext_UserNotificationChannelPreferencesConnection_edges(ctx, field)
			case "pageInfo":
				return ec.fieldContext_UserNotificationChannelPreferencesConnection_pageInfo(ctx, field)
			case "totalCount":
				return ec.fieldContext_UserNotificationChannelPreferencesConnection_totalCount(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type UserNotificationChannelPreferencesConnection", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_notificationChannels_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _Query___type(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query___type(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.introspectType(fc.Args["name"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	fc.Result = res
	return ec.marshalO__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query___type(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query___type_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _Query___schema(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query___schema(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.introspectSchema()
	})
	if err != nil {
		ec.Error(ctx, err)
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*introspection.Schema)
	fc.Result = res
	return ec.marshalO__Schema2githubcom99designsgqlgengraphqlintrospectionSchema(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query___schema(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "description":
				return ec.fieldContext___Schema_description(ctx, field)
			case "types":
				return ec.fieldContext___Schema_types(ctx, field)
			case "queryType":
				return ec.fieldContext___Schema_queryType(ctx, field)
			case "mutationType":
				return ec.fieldContext___Schema_mutationType(ctx, field)
			case "subscriptionType":
				return ec.fieldContext___Schema_subscriptionType(ctx, field)
			case "directives":
				return ec.fieldContext___Schema_directives(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Schema", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _SpendingCategory_id(ctx context.Context, field graphql.CollectedField, obj *ent.SpendingCategory) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SpendingCategory_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNID2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SpendingCategory_id(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SpendingCategory",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _SpendingCategory_name(ctx context.Context, field graphql.CollectedField, obj *ent.SpendingCategory) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SpendingCategory_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SpendingCategory_name(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SpendingCategory",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _SpendingCategory_categoryID(ctx context.Context, field graphql.CollectedField, obj *ent.SpendingCategory) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SpendingCategory_categoryID(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CategoryID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SpendingCategory_categoryID(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SpendingCategory",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _SpendingCategory_createdAt(ctx context.Context, field graphql.CollectedField, obj *ent.SpendingCategory) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SpendingCategory_createdAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CreatedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(time.Time)
	fc.Result = res
	return ec.marshalNTime2timeTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SpendingCategory_createdAt(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SpendingCategory",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _SpendingCategory_categoryTransactions(ctx context.Context, field graphql.CollectedField, obj *ent.SpendingCategory) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SpendingCategory_categoryTransactions(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CategoryTransactions(ctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*ent.Transaction)
	fc.Result = res
	return ec.marshalOTransaction2wallitentTransaction(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SpendingCategory_categoryTransactions(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SpendingCategory",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Transaction_id(ctx, field)
			case "financialAccountID":
				return ec.fieldContext_Transaction_financialAccountID(ctx, field)
			case "amount":
				return ec.fieldContext_Transaction_amount(ctx, field)
			case "isoCurrencyCode":
				return ec.fieldContext_Transaction_isoCurrencyCode(ctx, field)
			case "unofficialCurrencyCode":
				return ec.fieldContext_Transaction_unofficialCurrencyCode(ctx, field)
			case "category":
				return ec.fieldContext_Transaction_category(ctx, field)
			case "categoryID":
				return ec.fieldContext_Transaction_categoryID(ctx, field)
			case "checkNumber":
				return ec.fieldContext_Transaction_checkNumber(ctx, field)
			case "date":
				return ec.fieldContext_Transaction_date(ctx, field)
			case "datetime":
				return ec.fieldContext_Transaction_datetime(ctx, field)
			case "authorizedDate":
				return ec.fieldContext_Transaction_authorizedDate(ctx, field)
			case "authorizedDatetime":
				return ec.fieldContext_Transaction_authorizedDatetime(ctx, field)
			case "locationAddress":
				return ec.fieldContext_Transaction_locationAddress(ctx, field)
			case "locationCity":
				return ec.fieldContext_Transaction_locationCity(ctx, field)
			case "locationRegion":
				return ec.fieldContext_Transaction_locationRegion(ctx, field)
			case "locationPostalCode":
				return ec.fieldContext_Transaction_locationPostalCode(ctx, field)
			case "locationLat":
				return ec.fieldContext_Transaction_locationLat(ctx, field)
			case "locationLon":
				return ec.fieldContext_Transaction_locationLon(ctx, field)
			case "locationStoreNumber":
				return ec.fieldContext_Transaction_locationStoreNumber(ctx, field)
			case "name":
				return ec.fieldContext_Transaction_name(ctx, field)
			case "merchantName":
				return ec.fieldContext_Transaction_merchantName(ctx, field)
			case "paymentChannel":
				return ec.fieldContext_Transaction_paymentChannel(ctx, field)
			case "pending":
				return ec.fieldContext_Transaction_pending(ctx, field)
			case "pendingTransactionID":
				return ec.fieldContext_Transaction_pendingTransactionID(ctx, field)
			case "accountOwner":
				return ec.fieldContext_Transaction_accountOwner(ctx, field)
			case "transactionID":
				return ec.fieldContext_Transaction_transactionID(ctx, field)
			case "transactionCode":
				return ec.fieldContext_Transaction_transactionCode(ctx, field)
			case "createdAt":
				return ec.fieldContext_Transaction_createdAt(ctx, field)
			case "institutionAccount":
				return ec.fieldContext_Transaction_institutionAccount(ctx, field)
			case "transactionCategories":
				return ec.fieldContext_Transaction_transactionCategories(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Transaction", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _SpendingCategory_interestedUsers(ctx context.Context, field graphql.CollectedField, obj *ent.SpendingCategory) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SpendingCategory_interestedUsers(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.InterestedUsers(ctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*ent.User)
	fc.Result = res
	return ec.marshalOUser2wallitentUser(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SpendingCategory_interestedUsers(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SpendingCategory",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_User_id(ctx, field)
			case "identityProviderID":
				return ec.fieldContext_User_identityProviderID(ctx, field)
			case "offerFrequency":
				return ec.fieldContext_User_offerFrequency(ctx, field)
			case "homeCountry":
				return ec.fieldContext_User_homeCountry(ctx, field)
			case "homeState":
				return ec.fieldContext_User_homeState(ctx, field)
			case "homeCity":
				return ec.fieldContext_User_homeCity(ctx, field)
			case "plaidItems":
				return ec.fieldContext_User_plaidItems(ctx, field)
			case "spendingCategories":
				return ec.fieldContext_User_spendingCategories(ctx, field)
			case "notificationChannels":
				return ec.fieldContext_User_notificationChannels(ctx, field)
			case "notifications":
				return ec.fieldContext_User_notifications(ctx, field)
			case "availableDiscountOffers":
				return ec.fieldContext_User_availableDiscountOffers(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type User", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _SpendingCategoryConnection_edges(ctx context.Context, field graphql.CollectedField, obj *ent.SpendingCategoryConnection) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SpendingCategoryConnection_edges(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Edges, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*ent.SpendingCategoryEdge)
	fc.Result = res
	return ec.marshalOSpendingCategoryEdge2wallitentSpendingCategoryEdge(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SpendingCategoryConnection_edges(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SpendingCategoryConnection",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "node":
				return ec.fieldContext_SpendingCategoryEdge_node(ctx, field)
			case "cursor":
				return ec.fieldContext_SpendingCategoryEdge_cursor(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type SpendingCategoryEdge", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _SpendingCategoryConnection_pageInfo(ctx context.Context, field graphql.CollectedField, obj *ent.SpendingCategoryConnection) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SpendingCategoryConnection_pageInfo(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PageInfo, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(ent.PageInfo)
	fc.Result = res
	return ec.marshalNPageInfo2wallitentPageInfo(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SpendingCategoryConnection_pageInfo(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SpendingCategoryConnection",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "hasNextPage":
				return ec.fieldContext_PageInfo_hasNextPage(ctx, field)
			case "hasPreviousPage":
				return ec.fieldContext_PageInfo_hasPreviousPage(ctx, field)
			case "startCursor":
				return ec.fieldContext_PageInfo_startCursor(ctx, field)
			case "endCursor":
				return ec.fieldContext_PageInfo_endCursor(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type PageInfo", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _SpendingCategoryConnection_totalCount(ctx context.Context, field graphql.CollectedField, obj *ent.SpendingCategoryConnection) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SpendingCategoryConnection_totalCount(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TotalCount, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SpendingCategoryConnection_totalCount(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SpendingCategoryConnection",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _SpendingCategoryEdge_node(ctx context.Context, field graphql.CollectedField, obj *ent.SpendingCategoryEdge) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SpendingCategoryEdge_node(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Node, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*ent.SpendingCategory)
	fc.Result = res
	return ec.marshalOSpendingCategory2wallitentSpendingCategory(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SpendingCategoryEdge_node(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SpendingCategoryEdge",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_SpendingCategory_id(ctx, field)
			case "name":
				return ec.fieldContext_SpendingCategory_name(ctx, field)
			case "categoryID":
				return ec.fieldContext_SpendingCategory_categoryID(ctx, field)
			case "createdAt":
				return ec.fieldContext_SpendingCategory_createdAt(ctx, field)
			case "categoryTransactions":
				return ec.fieldContext_SpendingCategory_categoryTransactions(ctx, field)
			case "interestedUsers":
				return ec.fieldContext_SpendingCategory_interestedUsers(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type SpendingCategory", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _SpendingCategoryEdge_cursor(ctx context.Context, field graphql.CollectedField, obj *ent.SpendingCategoryEdge) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SpendingCategoryEdge_cursor(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Cursor, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(ent.Cursor)
	fc.Result = res
	return ec.marshalNCursor2wallitentCursor(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SpendingCategoryEdge_cursor(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SpendingCategoryEdge",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Cursor does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Subscription_notification(ctx context.Context, field graphql.CollectedField) (ret func(ctx context.Context) graphql.Marshaler) {
	fc, err := ec.fieldContext_Subscription_notification(ctx, field)
	if err != nil {
		return nil
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = nil
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Subscription().Notification(rctx, fc.Args["ownerID"].(int))
	})
	if err != nil {
		ec.Error(ctx, err)
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return nil
	}
	return func(ctx context.Context) graphql.Marshaler {
		select {
		case res, ok := <-resTmp.(<-chan *ent.Notification):
			if !ok {
				return nil
			}
			return graphql.WriterFunc(func(w io.Writer) {
				w.Write([]byte{'{'})
				graphql.MarshalString(field.Alias).MarshalGQL(w)
				w.Write([]byte{':'})
				ec.marshalNNotification2wallitentNotification(ctx, field.Selections, res).MarshalGQL(w)
				w.Write([]byte{'}'})
			})
		case <-ctx.Done():
			return nil
		}
	}
}

func (ec *executionContext) fieldContext_Subscription_notification(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Subscription",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Notification_id(ctx, field)
			case "checkedInApp":
				return ec.fieldContext_Notification_checkedInApp(ctx, field)
			case "type":
				return ec.fieldContext_Notification_type(ctx, field)
			case "createdAt":
				return ec.fieldContext_Notification_createdAt(ctx, field)
			case "includedInAggregatedOfferAt":
				return ec.fieldContext_Notification_includedInAggregatedOfferAt(ctx, field)
			case "notificationRecipient":
				return ec.fieldContext_Notification_notificationRecipient(ctx, field)
			case "notificationDiscountOffer":
				return ec.fieldContext_Notification_notificationDiscountOffer(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Notification", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Subscription_notification_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _Transaction_id(ctx context.Context, field graphql.CollectedField, obj *ent.Transaction) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Transaction_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNID2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Transaction_id(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Transaction",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Transaction_financialAccountID(ctx context.Context, field graphql.CollectedField, obj *ent.Transaction) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Transaction_financialAccountID(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.FinancialAccountID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Transaction_financialAccountID(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Transaction",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Transaction_amount(ctx context.Context, field graphql.CollectedField, obj *ent.Transaction) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Transaction_amount(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Amount, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(float64)
	fc.Result = res
	return ec.marshalNFloat2float64(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Transaction_amount(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Transaction",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Float does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Transaction_isoCurrencyCode(ctx context.Context, field graphql.CollectedField, obj *ent.Transaction) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Transaction_isoCurrencyCode(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IsoCurrencyCode, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Transaction_isoCurrencyCode(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Transaction",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Transaction_unofficialCurrencyCode(ctx context.Context, field graphql.CollectedField, obj *ent.Transaction) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Transaction_unofficialCurrencyCode(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.UnofficialCurrencyCode, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Transaction_unofficialCurrencyCode(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Transaction",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Transaction_category(ctx context.Context, field graphql.CollectedField, obj *ent.Transaction) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Transaction_category(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Category, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Transaction_category(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Transaction",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Transaction_categoryID(ctx context.Context, field graphql.CollectedField, obj *ent.Transaction) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Transaction_categoryID(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CategoryID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Transaction_categoryID(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Transaction",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Transaction_checkNumber(ctx context.Context, field graphql.CollectedField, obj *ent.Transaction) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Transaction_checkNumber(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CheckNumber, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Transaction_checkNumber(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Transaction",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Transaction_date(ctx context.Context, field graphql.CollectedField, obj *ent.Transaction) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Transaction_date(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Date, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Transaction_date(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Transaction",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Transaction_datetime(ctx context.Context, field graphql.CollectedField, obj *ent.Transaction) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Transaction_datetime(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Datetime, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(time.Time)
	fc.Result = res
	return ec.marshalOTime2timeTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Transaction_datetime(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Transaction",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Transaction_authorizedDate(ctx context.Context, field graphql.CollectedField, obj *ent.Transaction) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Transaction_authorizedDate(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.AuthorizedDate, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Transaction_authorizedDate(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Transaction",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Transaction_authorizedDatetime(ctx context.Context, field graphql.CollectedField, obj *ent.Transaction) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Transaction_authorizedDatetime(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.AuthorizedDatetime, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(time.Time)
	fc.Result = res
	return ec.marshalOTime2timeTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Transaction_authorizedDatetime(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Transaction",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Transaction_locationAddress(ctx context.Context, field graphql.CollectedField, obj *ent.Transaction) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Transaction_locationAddress(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.LocationAddress, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Transaction_locationAddress(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Transaction",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Transaction_locationCity(ctx context.Context, field graphql.CollectedField, obj *ent.Transaction) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Transaction_locationCity(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.LocationCity, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Transaction_locationCity(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Transaction",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Transaction_locationRegion(ctx context.Context, field graphql.CollectedField, obj *ent.Transaction) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Transaction_locationRegion(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.LocationRegion, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Transaction_locationRegion(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Transaction",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Transaction_locationPostalCode(ctx context.Context, field graphql.CollectedField, obj *ent.Transaction) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Transaction_locationPostalCode(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.LocationPostalCode, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Transaction_locationPostalCode(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Transaction",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Transaction_locationLat(ctx context.Context, field graphql.CollectedField, obj *ent.Transaction) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Transaction_locationLat(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.LocationLat, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(float64)
	fc.Result = res
	return ec.marshalNFloat2float64(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Transaction_locationLat(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Transaction",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Float does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Transaction_locationLon(ctx context.Context, field graphql.CollectedField, obj *ent.Transaction) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Transaction_locationLon(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.LocationLon, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(float64)
	fc.Result = res
	return ec.marshalNFloat2float64(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Transaction_locationLon(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Transaction",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Float does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Transaction_locationStoreNumber(ctx context.Context, field graphql.CollectedField, obj *ent.Transaction) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Transaction_locationStoreNumber(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.LocationStoreNumber, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Transaction_locationStoreNumber(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Transaction",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Transaction_name(ctx context.Context, field graphql.CollectedField, obj *ent.Transaction) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Transaction_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Transaction_name(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Transaction",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Transaction_merchantName(ctx context.Context, field graphql.CollectedField, obj *ent.Transaction) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Transaction_merchantName(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.MerchantName, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Transaction_merchantName(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Transaction",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Transaction_paymentChannel(ctx context.Context, field graphql.CollectedField, obj *ent.Transaction) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Transaction_paymentChannel(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PaymentChannel, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Transaction_paymentChannel(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Transaction",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Transaction_pending(ctx context.Context, field graphql.CollectedField, obj *ent.Transaction) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Transaction_pending(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Pending, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Transaction_pending(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Transaction",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Transaction_pendingTransactionID(ctx context.Context, field graphql.CollectedField, obj *ent.Transaction) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Transaction_pendingTransactionID(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PendingTransactionID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Transaction_pendingTransactionID(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Transaction",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Transaction_accountOwner(ctx context.Context, field graphql.CollectedField, obj *ent.Transaction) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Transaction_accountOwner(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.AccountOwner, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Transaction_accountOwner(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Transaction",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Transaction_transactionID(ctx context.Context, field graphql.CollectedField, obj *ent.Transaction) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Transaction_transactionID(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TransactionID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Transaction_transactionID(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Transaction",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Transaction_transactionCode(ctx context.Context, field graphql.CollectedField, obj *ent.Transaction) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Transaction_transactionCode(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TransactionCode, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Transaction_transactionCode(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Transaction",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Transaction_createdAt(ctx context.Context, field graphql.CollectedField, obj *ent.Transaction) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Transaction_createdAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CreatedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(time.Time)
	fc.Result = res
	return ec.marshalNTime2timeTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Transaction_createdAt(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Transaction",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Transaction_institutionAccount(ctx context.Context, field graphql.CollectedField, obj *ent.Transaction) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Transaction_institutionAccount(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.InstitutionAccount(ctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*ent.PlaidInstitutionAccount)
	fc.Result = res
	return ec.marshalOPlaidInstitutionAccount2wallitentPlaidInstitutionAccount(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Transaction_institutionAccount(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Transaction",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_PlaidInstitutionAccount_id(ctx, field)
			case "accountID":
				return ec.fieldContext_PlaidInstitutionAccount_accountID(ctx, field)
			case "balanceAvailable":
				return ec.fieldContext_PlaidInstitutionAccount_balanceAvailable(ctx, field)
			case "balanceCurrent":
				return ec.fieldContext_PlaidInstitutionAccount_balanceCurrent(ctx, field)
			case "balanceIsoCurrencyCode":
				return ec.fieldContext_PlaidInstitutionAccount_balanceIsoCurrencyCode(ctx, field)
			case "mask":
				return ec.fieldContext_PlaidInstitutionAccount_mask(ctx, field)
			case "name":
				return ec.fieldContext_PlaidInstitutionAccount_name(ctx, field)
			case "officialName":
				return ec.fieldContext_PlaidInstitutionAccount_officialName(ctx, field)
			case "type":
				return ec.fieldContext_PlaidInstitutionAccount_type(ctx, field)
			case "parentInstitution":
				return ec.fieldContext_PlaidInstitutionAccount_parentInstitution(ctx, field)
			case "transactions":
				return ec.fieldContext_PlaidInstitutionAccount_transactions(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type PlaidInstitutionAccount", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Transaction_transactionCategories(ctx context.Context, field graphql.CollectedField, obj *ent.Transaction) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Transaction_transactionCategories(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TransactionCategories(ctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*ent.SpendingCategory)
	fc.Result = res
	return ec.marshalOSpendingCategory2wallitentSpendingCategory(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Transaction_transactionCategories(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Transaction",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_SpendingCategory_id(ctx, field)
			case "name":
				return ec.fieldContext_SpendingCategory_name(ctx, field)
			case "categoryID":
				return ec.fieldContext_SpendingCategory_categoryID(ctx, field)
			case "createdAt":
				return ec.fieldContext_SpendingCategory_createdAt(ctx, field)
			case "categoryTransactions":
				return ec.fieldContext_SpendingCategory_categoryTransactions(ctx, field)
			case "interestedUsers":
				return ec.fieldContext_SpendingCategory_interestedUsers(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type SpendingCategory", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _TransactionConnection_edges(ctx context.Context, field graphql.CollectedField, obj *ent.TransactionConnection) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TransactionConnection_edges(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Edges, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*ent.TransactionEdge)
	fc.Result = res
	return ec.marshalOTransactionEdge2wallitentTransactionEdge(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TransactionConnection_edges(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TransactionConnection",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "node":
				return ec.fieldContext_TransactionEdge_node(ctx, field)
			case "cursor":
				return ec.fieldContext_TransactionEdge_cursor(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type TransactionEdge", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _TransactionConnection_pageInfo(ctx context.Context, field graphql.CollectedField, obj *ent.TransactionConnection) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TransactionConnection_pageInfo(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PageInfo, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(ent.PageInfo)
	fc.Result = res
	return ec.marshalNPageInfo2wallitentPageInfo(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TransactionConnection_pageInfo(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TransactionConnection",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "hasNextPage":
				return ec.fieldContext_PageInfo_hasNextPage(ctx, field)
			case "hasPreviousPage":
				return ec.fieldContext_PageInfo_hasPreviousPage(ctx, field)
			case "startCursor":
				return ec.fieldContext_PageInfo_startCursor(ctx, field)
			case "endCursor":
				return ec.fieldContext_PageInfo_endCursor(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type PageInfo", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _TransactionConnection_totalCount(ctx context.Context, field graphql.CollectedField, obj *ent.TransactionConnection) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TransactionConnection_totalCount(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TotalCount, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TransactionConnection_totalCount(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TransactionConnection",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TransactionEdge_node(ctx context.Context, field graphql.CollectedField, obj *ent.TransactionEdge) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TransactionEdge_node(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Node, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*ent.Transaction)
	fc.Result = res
	return ec.marshalOTransaction2wallitentTransaction(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TransactionEdge_node(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TransactionEdge",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Transaction_id(ctx, field)
			case "financialAccountID":
				return ec.fieldContext_Transaction_financialAccountID(ctx, field)
			case "amount":
				return ec.fieldContext_Transaction_amount(ctx, field)
			case "isoCurrencyCode":
				return ec.fieldContext_Transaction_isoCurrencyCode(ctx, field)
			case "unofficialCurrencyCode":
				return ec.fieldContext_Transaction_unofficialCurrencyCode(ctx, field)
			case "category":
				return ec.fieldContext_Transaction_category(ctx, field)
			case "categoryID":
				return ec.fieldContext_Transaction_categoryID(ctx, field)
			case "checkNumber":
				return ec.fieldContext_Transaction_checkNumber(ctx, field)
			case "date":
				return ec.fieldContext_Transaction_date(ctx, field)
			case "datetime":
				return ec.fieldContext_Transaction_datetime(ctx, field)
			case "authorizedDate":
				return ec.fieldContext_Transaction_authorizedDate(ctx, field)
			case "authorizedDatetime":
				return ec.fieldContext_Transaction_authorizedDatetime(ctx, field)
			case "locationAddress":
				return ec.fieldContext_Transaction_locationAddress(ctx, field)
			case "locationCity":
				return ec.fieldContext_Transaction_locationCity(ctx, field)
			case "locationRegion":
				return ec.fieldContext_Transaction_locationRegion(ctx, field)
			case "locationPostalCode":
				return ec.fieldContext_Transaction_locationPostalCode(ctx, field)
			case "locationLat":
				return ec.fieldContext_Transaction_locationLat(ctx, field)
			case "locationLon":
				return ec.fieldContext_Transaction_locationLon(ctx, field)
			case "locationStoreNumber":
				return ec.fieldContext_Transaction_locationStoreNumber(ctx, field)
			case "name":
				return ec.fieldContext_Transaction_name(ctx, field)
			case "merchantName":
				return ec.fieldContext_Transaction_merchantName(ctx, field)
			case "paymentChannel":
				return ec.fieldContext_Transaction_paymentChannel(ctx, field)
			case "pending":
				return ec.fieldContext_Transaction_pending(ctx, field)
			case "pendingTransactionID":
				return ec.fieldContext_Transaction_pendingTransactionID(ctx, field)
			case "accountOwner":
				return ec.fieldContext_Transaction_accountOwner(ctx, field)
			case "transactionID":
				return ec.fieldContext_Transaction_transactionID(ctx, field)
			case "transactionCode":
				return ec.fieldContext_Transaction_transactionCode(ctx, field)
			case "createdAt":
				return ec.fieldContext_Transaction_createdAt(ctx, field)
			case "institutionAccount":
				return ec.fieldContext_Transaction_institutionAccount(ctx, field)
			case "transactionCategories":
				return ec.fieldContext_Transaction_transactionCategories(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Transaction", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _TransactionEdge_cursor(ctx context.Context, field graphql.CollectedField, obj *ent.TransactionEdge) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TransactionEdge_cursor(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Cursor, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(ent.Cursor)
	fc.Result = res
	return ec.marshalNCursor2wallitentCursor(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TransactionEdge_cursor(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TransactionEdge",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Cursor does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TransactionSync_id(ctx context.Context, field graphql.CollectedField, obj *ent.TransactionSync) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TransactionSync_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNID2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TransactionSync_id(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TransactionSync",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TransactionSync_createdAt(ctx context.Context, field graphql.CollectedField, obj *ent.TransactionSync) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TransactionSync_createdAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CreatedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(time.Time)
	fc.Result = res
	return ec.marshalNTime2timeTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TransactionSync_createdAt(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TransactionSync",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TransactionSync_cursor(ctx context.Context, field graphql.CollectedField, obj *ent.TransactionSync) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TransactionSync_cursor(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Cursor, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TransactionSync_cursor(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TransactionSync",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TransactionSync_item(ctx context.Context, field graphql.CollectedField, obj *ent.TransactionSync) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TransactionSync_item(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Item(ctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*ent.PlaidItem)
	fc.Result = res
	return ec.marshalOPlaidItem2wallitentPlaidItem(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TransactionSync_item(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TransactionSync",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_PlaidItem_id(ctx, field)
			case "itemID":
				return ec.fieldContext_PlaidItem_itemID(ctx, field)
			case "accessToken":
				return ec.fieldContext_PlaidItem_accessToken(ctx, field)
			case "createdAt":
				return ec.fieldContext_PlaidItem_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_PlaidItem_updatedAt(ctx, field)
			case "owner":
				return ec.fieldContext_PlaidItem_owner(ctx, field)
			case "transactionSyncs":
				return ec.fieldContext_PlaidItem_transactionSyncs(ctx, field)
			case "institution":
				return ec.fieldContext_PlaidItem_institution(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type PlaidItem", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _User_id(ctx context.Context, field graphql.CollectedField, obj *ent.User) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_User_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNID2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_User_id(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "User",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _User_identityProviderID(ctx context.Context, field graphql.CollectedField, obj *ent.User) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_User_identityProviderID(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IdentityProviderID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_User_identityProviderID(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "User",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _User_offerFrequency(ctx context.Context, field graphql.CollectedField, obj *ent.User) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_User_offerFrequency(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.OfferFrequency, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(user.OfferFrequency)
	fc.Result = res
	return ec.marshalNUserOfferFrequency2wallitentuserOfferFrequency(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_User_offerFrequency(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "User",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type UserOfferFrequency does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _User_homeCountry(ctx context.Context, field graphql.CollectedField, obj *ent.User) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_User_homeCountry(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.HomeCountry, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_User_homeCountry(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "User",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _User_homeState(ctx context.Context, field graphql.CollectedField, obj *ent.User) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_User_homeState(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.HomeState, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_User_homeState(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "User",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _User_homeCity(ctx context.Context, field graphql.CollectedField, obj *ent.User) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_User_homeCity(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.HomeCity, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_User_homeCity(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "User",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _User_plaidItems(ctx context.Context, field graphql.CollectedField, obj *ent.User) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_User_plaidItems(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PlaidItems(ctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*ent.PlaidItem)
	fc.Result = res
	return ec.marshalOPlaidItem2wallitentPlaidItem(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_User_plaidItems(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "User",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_PlaidItem_id(ctx, field)
			case "itemID":
				return ec.fieldContext_PlaidItem_itemID(ctx, field)
			case "accessToken":
				return ec.fieldContext_PlaidItem_accessToken(ctx, field)
			case "createdAt":
				return ec.fieldContext_PlaidItem_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_PlaidItem_updatedAt(ctx, field)
			case "owner":
				return ec.fieldContext_PlaidItem_owner(ctx, field)
			case "transactionSyncs":
				return ec.fieldContext_PlaidItem_transactionSyncs(ctx, field)
			case "institution":
				return ec.fieldContext_PlaidItem_institution(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type PlaidItem", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _User_spendingCategories(ctx context.Context, field graphql.CollectedField, obj *ent.User) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_User_spendingCategories(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SpendingCategories(ctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*ent.SpendingCategory)
	fc.Result = res
	return ec.marshalOSpendingCategory2wallitentSpendingCategory(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_User_spendingCategories(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "User",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_SpendingCategory_id(ctx, field)
			case "name":
				return ec.fieldContext_SpendingCategory_name(ctx, field)
			case "categoryID":
				return ec.fieldContext_SpendingCategory_categoryID(ctx, field)
			case "createdAt":
				return ec.fieldContext_SpendingCategory_createdAt(ctx, field)
			case "categoryTransactions":
				return ec.fieldContext_SpendingCategory_categoryTransactions(ctx, field)
			case "interestedUsers":
				return ec.fieldContext_SpendingCategory_interestedUsers(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type SpendingCategory", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _User_notificationChannels(ctx context.Context, field graphql.CollectedField, obj *ent.User) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_User_notificationChannels(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.NotificationChannels(ctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*ent.UserNotificationChannelPreferences)
	fc.Result = res
	return ec.marshalOUserNotificationChannelPreferences2wallitentUserNotificationChannelPreferences(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_User_notificationChannels(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "User",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_UserNotificationChannelPreferences_id(ctx, field)
			case "chanel":
				return ec.fieldContext_UserNotificationChannelPreferences_chanel(ctx, field)
			case "chanelUsers":
				return ec.fieldContext_UserNotificationChannelPreferences_chanelUsers(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type UserNotificationChannelPreferences", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _User_notifications(ctx context.Context, field graphql.CollectedField, obj *ent.User) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_User_notifications(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Notifications(ctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*ent.Notification)
	fc.Result = res
	return ec.marshalONotification2wallitentNotification(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_User_notifications(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "User",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Notification_id(ctx, field)
			case "checkedInApp":
				return ec.fieldContext_Notification_checkedInApp(ctx, field)
			case "type":
				return ec.fieldContext_Notification_type(ctx, field)
			case "createdAt":
				return ec.fieldContext_Notification_createdAt(ctx, field)
			case "includedInAggregatedOfferAt":
				return ec.fieldContext_Notification_includedInAggregatedOfferAt(ctx, field)
			case "notificationRecipient":
				return ec.fieldContext_Notification_notificationRecipient(ctx, field)
			case "notificationDiscountOffer":
				return ec.fieldContext_Notification_notificationDiscountOffer(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Notification", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _User_availableDiscountOffers(ctx context.Context, field graphql.CollectedField, obj *ent.User) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_User_availableDiscountOffers(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.AvailableDiscountOffers(ctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*ent.DiscountOffer)
	fc.Result = res
	return ec.marshalODiscountOffer2wallitentDiscountOffer(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_User_availableDiscountOffers(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "User",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_DiscountOffer_id(ctx, field)
			case "amount":
				return ec.fieldContext_DiscountOffer_amount(ctx, field)
			case "type":
				return ec.fieldContext_DiscountOffer_type(ctx, field)
			case "currency":
				return ec.fieldContext_DiscountOffer_currency(ctx, field)
			case "description":
				return ec.fieldContext_DiscountOffer_description(ctx, field)
			case "merchantSpecificIdentification":
				return ec.fieldContext_DiscountOffer_merchantSpecificIdentification(ctx, field)
			case "createdAt":
				return ec.fieldContext_DiscountOffer_createdAt(ctx, field)
			case "expiresAt":
				return ec.fieldContext_DiscountOffer_expiresAt(ctx, field)
			case "ownerMerchant":
				return ec.fieldContext_DiscountOffer_ownerMerchant(ctx, field)
			case "discountEligibleUsers":
				return ec.fieldContext_DiscountOffer_discountEligibleUsers(ctx, field)
			case "discountOfferNotification":
				return ec.fieldContext_DiscountOffer_discountOfferNotification(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type DiscountOffer", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _UserNotificationChannelPreferences_id(ctx context.Context, field graphql.CollectedField, obj *ent.UserNotificationChannelPreferences) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_UserNotificationChannelPreferences_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNID2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_UserNotificationChannelPreferences_id(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "UserNotificationChannelPreferences",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _UserNotificationChannelPreferences_chanel(ctx context.Context, field graphql.CollectedField, obj *ent.UserNotificationChannelPreferences) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_UserNotificationChannelPreferences_chanel(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Chanel, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(usernotificationchannelpreferences.Chanel)
	fc.Result = res
	return ec.marshalNUserNotificationChannelPreferencesChanel2wallitentusernotificationchannelpreferencesChanel(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_UserNotificationChannelPreferences_chanel(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "UserNotificationChannelPreferences",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type UserNotificationChannelPreferencesChanel does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _UserNotificationChannelPreferences_chanelUsers(ctx context.Context, field graphql.CollectedField, obj *ent.UserNotificationChannelPreferences) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_UserNotificationChannelPreferences_chanelUsers(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ChanelUsers(ctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*ent.User)
	fc.Result = res
	return ec.marshalOUser2wallitentUser(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_UserNotificationChannelPreferences_chanelUsers(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "UserNotificationChannelPreferences",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_User_id(ctx, field)
			case "identityProviderID":
				return ec.fieldContext_User_identityProviderID(ctx, field)
			case "offerFrequency":
				return ec.fieldContext_User_offerFrequency(ctx, field)
			case "homeCountry":
				return ec.fieldContext_User_homeCountry(ctx, field)
			case "homeState":
				return ec.fieldContext_User_homeState(ctx, field)
			case "homeCity":
				return ec.fieldContext_User_homeCity(ctx, field)
			case "plaidItems":
				return ec.fieldContext_User_plaidItems(ctx, field)
			case "spendingCategories":
				return ec.fieldContext_User_spendingCategories(ctx, field)
			case "notificationChannels":
				return ec.fieldContext_User_notificationChannels(ctx, field)
			case "notifications":
				return ec.fieldContext_User_notifications(ctx, field)
			case "availableDiscountOffers":
				return ec.fieldContext_User_availableDiscountOffers(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type User", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _UserNotificationChannelPreferencesConnection_edges(ctx context.Context, field graphql.CollectedField, obj *ent.UserNotificationChannelPreferencesConnection) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_UserNotificationChannelPreferencesConnection_edges(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Edges, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*ent.UserNotificationChannelPreferencesEdge)
	fc.Result = res
	return ec.marshalOUserNotificationChannelPreferencesEdge2wallitentUserNotificationChannelPreferencesEdge(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_UserNotificationChannelPreferencesConnection_edges(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "UserNotificationChannelPreferencesConnection",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "node":
				return ec.fieldContext_UserNotificationChannelPreferencesEdge_node(ctx, field)
			case "cursor":
				return ec.fieldContext_UserNotificationChannelPreferencesEdge_cursor(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type UserNotificationChannelPreferencesEdge", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _UserNotificationChannelPreferencesConnection_pageInfo(ctx context.Context, field graphql.CollectedField, obj *ent.UserNotificationChannelPreferencesConnection) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_UserNotificationChannelPreferencesConnection_pageInfo(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PageInfo, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(ent.PageInfo)
	fc.Result = res
	return ec.marshalNPageInfo2wallitentPageInfo(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_UserNotificationChannelPreferencesConnection_pageInfo(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "UserNotificationChannelPreferencesConnection",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "hasNextPage":
				return ec.fieldContext_PageInfo_hasNextPage(ctx, field)
			case "hasPreviousPage":
				return ec.fieldContext_PageInfo_hasPreviousPage(ctx, field)
			case "startCursor":
				return ec.fieldContext_PageInfo_startCursor(ctx, field)
			case "endCursor":
				return ec.fieldContext_PageInfo_endCursor(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type PageInfo", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _UserNotificationChannelPreferencesConnection_totalCount(ctx context.Context, field graphql.CollectedField, obj *ent.UserNotificationChannelPreferencesConnection) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_UserNotificationChannelPreferencesConnection_totalCount(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TotalCount, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_UserNotificationChannelPreferencesConnection_totalCount(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "UserNotificationChannelPreferencesConnection",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _UserNotificationChannelPreferencesEdge_node(ctx context.Context, field graphql.CollectedField, obj *ent.UserNotificationChannelPreferencesEdge) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_UserNotificationChannelPreferencesEdge_node(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Node, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*ent.UserNotificationChannelPreferences)
	fc.Result = res
	return ec.marshalOUserNotificationChannelPreferences2wallitentUserNotificationChannelPreferences(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_UserNotificationChannelPreferencesEdge_node(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "UserNotificationChannelPreferencesEdge",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_UserNotificationChannelPreferences_id(ctx, field)
			case "chanel":
				return ec.fieldContext_UserNotificationChannelPreferences_chanel(ctx, field)
			case "chanelUsers":
				return ec.fieldContext_UserNotificationChannelPreferences_chanelUsers(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type UserNotificationChannelPreferences", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _UserNotificationChannelPreferencesEdge_cursor(ctx context.Context, field graphql.CollectedField, obj *ent.UserNotificationChannelPreferencesEdge) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_UserNotificationChannelPreferencesEdge_cursor(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Cursor, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(ent.Cursor)
	fc.Result = res
	return ec.marshalNCursor2wallitentCursor(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_UserNotificationChannelPreferencesEdge_cursor(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "UserNotificationChannelPreferencesEdge",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Cursor does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Directive_name(ctx context.Context, field graphql.CollectedField, obj *introspection.Directive) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Directive_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Directive_name(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Directive",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Directive_description(ctx context.Context, field graphql.CollectedField, obj *introspection.Directive) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Directive_description(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Directive_description(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Directive",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Directive_locations(ctx context.Context, field graphql.CollectedField, obj *introspection.Directive) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Directive_locations(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Locations, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]string)
	fc.Result = res
	return ec.marshalN__DirectiveLocation2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Directive_locations(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Directive",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type __DirectiveLocation does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Directive_args(ctx context.Context, field graphql.CollectedField, obj *introspection.Directive) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Directive_args(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Args, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]introspection.InputValue)
	fc.Result = res
	return ec.marshalN__InputValue2githubcom99designsgqlgengraphqlintrospectionInputValue(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Directive_args(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Directive",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext___InputValue_name(ctx, field)
			case "description":
				return ec.fieldContext___InputValue_description(ctx, field)
			case "type":
				return ec.fieldContext___InputValue_type(ctx, field)
			case "defaultValue":
				return ec.fieldContext___InputValue_defaultValue(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __InputValue", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Directive_isRepeatable(ctx context.Context, field graphql.CollectedField, obj *introspection.Directive) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Directive_isRepeatable(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IsRepeatable, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Directive_isRepeatable(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Directive",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___EnumValue_name(ctx context.Context, field graphql.CollectedField, obj *introspection.EnumValue) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___EnumValue_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___EnumValue_name(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__EnumValue",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___EnumValue_description(ctx context.Context, field graphql.CollectedField, obj *introspection.EnumValue) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___EnumValue_description(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___EnumValue_description(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__EnumValue",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___EnumValue_isDeprecated(ctx context.Context, field graphql.CollectedField, obj *introspection.EnumValue) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___EnumValue_isDeprecated(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IsDeprecated(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___EnumValue_isDeprecated(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__EnumValue",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___EnumValue_deprecationReason(ctx context.Context, field graphql.CollectedField, obj *introspection.EnumValue) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___EnumValue_deprecationReason(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DeprecationReason(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___EnumValue_deprecationReason(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__EnumValue",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Field_name(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Field_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Field_name(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Field",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Field_description(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Field_description(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Field_description(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Field",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Field_args(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Field_args(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Args, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]introspection.InputValue)
	fc.Result = res
	return ec.marshalN__InputValue2githubcom99designsgqlgengraphqlintrospectionInputValue(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Field_args(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Field",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext___InputValue_name(ctx, field)
			case "description":
				return ec.fieldContext___InputValue_description(ctx, field)
			case "type":
				return ec.fieldContext___InputValue_type(ctx, field)
			case "defaultValue":
				return ec.fieldContext___InputValue_defaultValue(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __InputValue", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Field_type(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Field_type(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Type, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	fc.Result = res
	return ec.marshalN__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Field_type(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Field",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Field_isDeprecated(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Field_isDeprecated(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IsDeprecated(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Field_isDeprecated(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Field",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Field_deprecationReason(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Field_deprecationReason(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DeprecationReason(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Field_deprecationReason(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Field",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___InputValue_name(ctx context.Context, field graphql.CollectedField, obj *introspection.InputValue) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___InputValue_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___InputValue_name(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__InputValue",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___InputValue_description(ctx context.Context, field graphql.CollectedField, obj *introspection.InputValue) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___InputValue_description(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___InputValue_description(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__InputValue",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___InputValue_type(ctx context.Context, field graphql.CollectedField, obj *introspection.InputValue) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___InputValue_type(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Type, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	fc.Result = res
	return ec.marshalN__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___InputValue_type(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__InputValue",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___InputValue_defaultValue(ctx context.Context, field graphql.CollectedField, obj *introspection.InputValue) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___InputValue_defaultValue(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DefaultValue, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___InputValue_defaultValue(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__InputValue",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Schema_description(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Schema_description(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Schema_description(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Schema",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Schema_types(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Schema_types(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Types(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]introspection.Type)
	fc.Result = res
	return ec.marshalN__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Schema_types(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Schema",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Schema_queryType(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Schema_queryType(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.QueryType(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	fc.Result = res
	return ec.marshalN__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Schema_queryType(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Schema",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Schema_mutationType(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Schema_mutationType(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.MutationType(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	fc.Result = res
	return ec.marshalO__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Schema_mutationType(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Schema",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Schema_subscriptionType(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Schema_subscriptionType(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SubscriptionType(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	fc.Result = res
	return ec.marshalO__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Schema_subscriptionType(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Schema",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Schema_directives(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Schema_directives(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Directives(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]introspection.Directive)
	fc.Result = res
	return ec.marshalN__Directive2githubcom99designsgqlgengraphqlintrospectionDirective(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Schema_directives(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Schema",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext___Directive_name(ctx, field)
			case "description":
				return ec.fieldContext___Directive_description(ctx, field)
			case "locations":
				return ec.fieldContext___Directive_locations(ctx, field)
			case "args":
				return ec.fieldContext___Directive_args(ctx, field)
			case "isRepeatable":
				return ec.fieldContext___Directive_isRepeatable(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Directive", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Type_kind(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_kind(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Kind(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalN__TypeKind2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_kind(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type __TypeKind does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Type_name(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_name(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Type_description(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_description(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_description(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Type_fields(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_fields(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Fields(fc.Args["includeDeprecated"].(bool)), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]introspection.Field)
	fc.Result = res
	return ec.marshalO__Field2githubcom99designsgqlgengraphqlintrospectionField(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_fields(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext___Field_name(ctx, field)
			case "description":
				return ec.fieldContext___Field_description(ctx, field)
			case "args":
				return ec.fieldContext___Field_args(ctx, field)
			case "type":
				return ec.fieldContext___Field_type(ctx, field)
			case "isDeprecated":
				return ec.fieldContext___Field_isDeprecated(ctx, field)
			case "deprecationReason":
				return ec.fieldContext___Field_deprecationReason(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Field", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field___Type_fields_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) ___Type_interfaces(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_interfaces(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Interfaces(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]introspection.Type)
	fc.Result = res
	return ec.marshalO__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_interfaces(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Type_possibleTypes(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_possibleTypes(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PossibleTypes(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]introspection.Type)
	fc.Result = res
	return ec.marshalO__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_possibleTypes(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Type_enumValues(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_enumValues(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.EnumValues(fc.Args["includeDeprecated"].(bool)), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]introspection.EnumValue)
	fc.Result = res
	return ec.marshalO__EnumValue2githubcom99designsgqlgengraphqlintrospectionEnumValue(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_enumValues(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext___EnumValue_name(ctx, field)
			case "description":
				return ec.fieldContext___EnumValue_description(ctx, field)
			case "isDeprecated":
				return ec.fieldContext___EnumValue_isDeprecated(ctx, field)
			case "deprecationReason":
				return ec.fieldContext___EnumValue_deprecationReason(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __EnumValue", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field___Type_enumValues_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) ___Type_inputFields(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_inputFields(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.InputFields(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]introspection.InputValue)
	fc.Result = res
	return ec.marshalO__InputValue2githubcom99designsgqlgengraphqlintrospectionInputValue(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_inputFields(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext___InputValue_name(ctx, field)
			case "description":
				return ec.fieldContext___InputValue_description(ctx, field)
			case "type":
				return ec.fieldContext___InputValue_type(ctx, field)
			case "defaultValue":
				return ec.fieldContext___InputValue_defaultValue(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __InputValue", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Type_ofType(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_ofType(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.OfType(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	fc.Result = res
	return ec.marshalO__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_ofType(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Type_specifiedByURL(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_specifiedByURL(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SpecifiedByURL(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_specifiedByURL(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

// endregion **************************** field.gotpl *****************************

// region    **************************** input.gotpl *****************************

func (ec *executionContext) unmarshalInputCreateDiscountOfferInput(ctx context.Context, obj interface{}) (ent.CreateDiscountOfferInput, error) {
	var it ent.CreateDiscountOfferInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"amount", "type", "currency", "description", "merchantSpecificIdentification", "expiresAt", "ownerMerchantID", "discountEligibleUserIDs", "discountOfferNotificationID"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "amount":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("amount"))
			it.Amount, err = ec.unmarshalNInt2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "type":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("type"))
			it.Type, err = ec.unmarshalODiscountOfferType2wallitentdiscountofferType(ctx, v)
			if err != nil {
				return it, err
			}
		case "currency":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("currency"))
			it.Currency, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "description":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("description"))
			it.Description, err = ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "merchantSpecificIdentification":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("merchantSpecificIdentification"))
			it.MerchantSpecificIdentification, err = ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "expiresAt":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("expiresAt"))
			it.ExpiresAt, err = ec.unmarshalNTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
		case "ownerMerchantID":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("ownerMerchantID"))
			it.OwnerMerchantID, err = ec.unmarshalNID2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "discountEligibleUserIDs":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("discountEligibleUserIDs"))
			it.DiscountEligibleUserIDs, err = ec.unmarshalNID2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "discountOfferNotificationID":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("discountOfferNotificationID"))
			it.DiscountOfferNotificationID, err = ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputCreateLinkTokenParams(ctx context.Context, obj interface{}) (model.CreateLinkTokenParams, error) {
	var it model.CreateLinkTokenParams
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"userId"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "userId":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("userId"))
			it.UserID, err = ec.unmarshalNID2int(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputCreateMerchantInput(ctx context.Context, obj interface{}) (ent.CreateMerchantInput, error) {
	var it ent.CreateMerchantInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"name", "discountOfferIDs"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "name":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
			it.Name, err = ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "discountOfferIDs":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("discountOfferIDs"))
			it.DiscountOfferIDs, err = ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputCreateUserInput(ctx context.Context, obj interface{}) (ent.CreateUserInput, error) {
	var it ent.CreateUserInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"identityProviderID", "offerFrequency", "homeCountry", "homeState", "homeCity"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "identityProviderID":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("identityProviderID"))
			it.IdentityProviderID, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "offerFrequency":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("offerFrequency"))
			it.OfferFrequency, err = ec.unmarshalOUserOfferFrequency2wallitentuserOfferFrequency(ctx, v)
			if err != nil {
				return it, err
			}
		case "homeCountry":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("homeCountry"))
			it.HomeCountry, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "homeState":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("homeState"))
			it.HomeState, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "homeCity":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("homeCity"))
			it.HomeCity, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputDiscountOfferOrder(ctx context.Context, obj interface{}) (ent.DiscountOfferOrder, error) {
	var it ent.DiscountOfferOrder
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	if _, present := asMap["direction"]; !present {
		asMap["direction"] = "ASC"
	}

	fieldsInOrder := [...]string{"direction", "field"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "direction":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("direction"))
			it.Direction, err = ec.unmarshalNOrderDirection2wallitentOrderDirection(ctx, v)
			if err != nil {
				return it, err
			}
		case "field":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("field"))
			it.Field, err = ec.unmarshalNDiscountOfferOrderField2wallitentDiscountOfferOrderField(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputDiscountOfferWhereInput(ctx context.Context, obj interface{}) (ent.DiscountOfferWhereInput, error) {
	var it ent.DiscountOfferWhereInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"not", "and", "or", "id", "idNEQ", "idIn", "idNotIn", "idGT", "idGTE", "idLT", "idLTE", "amount", "amountNEQ", "amountIn", "amountNotIn", "amountGT", "amountGTE", "amountLT", "amountLTE", "type", "typeNEQ", "typeIn", "typeNotIn", "currency", "currencyNEQ", "currencyIn", "currencyNotIn", "currencyGT", "currencyGTE", "currencyLT", "currencyLTE", "currencyContains", "currencyHasPrefix", "currencyHasSuffix", "currencyIsNil", "currencyNotNil", "currencyEqualFold", "currencyContainsFold", "description", "descriptionNEQ", "descriptionIn", "descriptionNotIn", "descriptionGT", "descriptionGTE", "descriptionLT", "descriptionLTE", "descriptionContains", "descriptionHasPrefix", "descriptionHasSuffix", "descriptionEqualFold", "descriptionContainsFold", "merchantSpecificIdentification", "merchantSpecificIdentificationNEQ", "merchantSpecificIdentificationIn", "merchantSpecificIdentificationNotIn", "merchantSpecificIdentificationGT", "merchantSpecificIdentificationGTE", "merchantSpecificIdentificationLT", "merchantSpecificIdentificationLTE", "merchantSpecificIdentificationContains", "merchantSpecificIdentificationHasPrefix", "merchantSpecificIdentificationHasSuffix", "merchantSpecificIdentificationEqualFold", "merchantSpecificIdentificationContainsFold", "createdAt", "createdAtNEQ", "createdAtIn", "createdAtNotIn", "createdAtGT", "createdAtGTE", "createdAtLT", "createdAtLTE", "expiresAt", "expiresAtNEQ", "expiresAtIn", "expiresAtNotIn", "expiresAtGT", "expiresAtGTE", "expiresAtLT", "expiresAtLTE", "hasOwnerMerchant", "hasOwnerMerchantWith", "hasDiscountEligibleUsers", "hasDiscountEligibleUsersWith", "hasDiscountOfferNotification", "hasDiscountOfferNotificationWith"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "not":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("not"))
			it.Not, err = ec.unmarshalODiscountOfferWhereInput2wallitentDiscountOfferWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
		case "and":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("and"))
			it.And, err = ec.unmarshalODiscountOfferWhereInput2wallitentDiscountOfferWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
		case "or":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("or"))
			it.Or, err = ec.unmarshalODiscountOfferWhereInput2wallitentDiscountOfferWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
		case "id":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
			it.ID, err = ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "idNEQ":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idNEQ"))
			it.IDNEQ, err = ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "idIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idIn"))
			it.IDIn, err = ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "idNotIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idNotIn"))
			it.IDNotIn, err = ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "idGT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idGT"))
			it.IDGT, err = ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "idGTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idGTE"))
			it.IDGTE, err = ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "idLT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idLT"))
			it.IDLT, err = ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "idLTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idLTE"))
			it.IDLTE, err = ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "amount":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("amount"))
			it.Amount, err = ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "amountNEQ":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("amountNEQ"))
			it.AmountNEQ, err = ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "amountIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("amountIn"))
			it.AmountIn, err = ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "amountNotIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("amountNotIn"))
			it.AmountNotIn, err = ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "amountGT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("amountGT"))
			it.AmountGT, err = ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "amountGTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("amountGTE"))
			it.AmountGTE, err = ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "amountLT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("amountLT"))
			it.AmountLT, err = ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "amountLTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("amountLTE"))
			it.AmountLTE, err = ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "type":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("type"))
			it.Type, err = ec.unmarshalODiscountOfferType2wallitentdiscountofferType(ctx, v)
			if err != nil {
				return it, err
			}
		case "typeNEQ":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("typeNEQ"))
			it.TypeNEQ, err = ec.unmarshalODiscountOfferType2wallitentdiscountofferType(ctx, v)
			if err != nil {
				return it, err
			}
		case "typeIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("typeIn"))
			it.TypeIn, err = ec.unmarshalODiscountOfferType2wallitentdiscountofferType(ctx, v)
			if err != nil {
				return it, err
			}
		case "typeNotIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("typeNotIn"))
			it.TypeNotIn, err = ec.unmarshalODiscountOfferType2wallitentdiscountofferType(ctx, v)
			if err != nil {
				return it, err
			}
		case "currency":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("currency"))
			it.Currency, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "currencyNEQ":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("currencyNEQ"))
			it.CurrencyNEQ, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "currencyIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("currencyIn"))
			it.CurrencyIn, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "currencyNotIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("currencyNotIn"))
			it.CurrencyNotIn, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "currencyGT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("currencyGT"))
			it.CurrencyGT, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "currencyGTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("currencyGTE"))
			it.CurrencyGTE, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "currencyLT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("currencyLT"))
			it.CurrencyLT, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "currencyLTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("currencyLTE"))
			it.CurrencyLTE, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "currencyContains":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("currencyContains"))
			it.CurrencyContains, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "currencyHasPrefix":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("currencyHasPrefix"))
			it.CurrencyHasPrefix, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "currencyHasSuffix":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("currencyHasSuffix"))
			it.CurrencyHasSuffix, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "currencyIsNil":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("currencyIsNil"))
			it.CurrencyIsNil, err = ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
		case "currencyNotNil":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("currencyNotNil"))
			it.CurrencyNotNil, err = ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
		case "currencyEqualFold":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("currencyEqualFold"))
			it.CurrencyEqualFold, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "currencyContainsFold":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("currencyContainsFold"))
			it.CurrencyContainsFold, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "description":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("description"))
			it.Description, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "descriptionNEQ":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("descriptionNEQ"))
			it.DescriptionNEQ, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "descriptionIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("descriptionIn"))
			it.DescriptionIn, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "descriptionNotIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("descriptionNotIn"))
			it.DescriptionNotIn, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "descriptionGT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("descriptionGT"))
			it.DescriptionGT, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "descriptionGTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("descriptionGTE"))
			it.DescriptionGTE, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "descriptionLT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("descriptionLT"))
			it.DescriptionLT, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "descriptionLTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("descriptionLTE"))
			it.DescriptionLTE, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "descriptionContains":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("descriptionContains"))
			it.DescriptionContains, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "descriptionHasPrefix":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("descriptionHasPrefix"))
			it.DescriptionHasPrefix, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "descriptionHasSuffix":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("descriptionHasSuffix"))
			it.DescriptionHasSuffix, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "descriptionEqualFold":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("descriptionEqualFold"))
			it.DescriptionEqualFold, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "descriptionContainsFold":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("descriptionContainsFold"))
			it.DescriptionContainsFold, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "merchantSpecificIdentification":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("merchantSpecificIdentification"))
			it.MerchantSpecificIdentification, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "merchantSpecificIdentificationNEQ":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("merchantSpecificIdentificationNEQ"))
			it.MerchantSpecificIdentificationNEQ, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "merchantSpecificIdentificationIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("merchantSpecificIdentificationIn"))
			it.MerchantSpecificIdentificationIn, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "merchantSpecificIdentificationNotIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("merchantSpecificIdentificationNotIn"))
			it.MerchantSpecificIdentificationNotIn, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "merchantSpecificIdentificationGT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("merchantSpecificIdentificationGT"))
			it.MerchantSpecificIdentificationGT, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "merchantSpecificIdentificationGTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("merchantSpecificIdentificationGTE"))
			it.MerchantSpecificIdentificationGTE, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "merchantSpecificIdentificationLT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("merchantSpecificIdentificationLT"))
			it.MerchantSpecificIdentificationLT, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "merchantSpecificIdentificationLTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("merchantSpecificIdentificationLTE"))
			it.MerchantSpecificIdentificationLTE, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "merchantSpecificIdentificationContains":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("merchantSpecificIdentificationContains"))
			it.MerchantSpecificIdentificationContains, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "merchantSpecificIdentificationHasPrefix":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("merchantSpecificIdentificationHasPrefix"))
			it.MerchantSpecificIdentificationHasPrefix, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "merchantSpecificIdentificationHasSuffix":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("merchantSpecificIdentificationHasSuffix"))
			it.MerchantSpecificIdentificationHasSuffix, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "merchantSpecificIdentificationEqualFold":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("merchantSpecificIdentificationEqualFold"))
			it.MerchantSpecificIdentificationEqualFold, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "merchantSpecificIdentificationContainsFold":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("merchantSpecificIdentificationContainsFold"))
			it.MerchantSpecificIdentificationContainsFold, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "createdAt":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createdAt"))
			it.CreatedAt, err = ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
		case "createdAtNEQ":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createdAtNEQ"))
			it.CreatedAtNEQ, err = ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
		case "createdAtIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createdAtIn"))
			it.CreatedAtIn, err = ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
		case "createdAtNotIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createdAtNotIn"))
			it.CreatedAtNotIn, err = ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
		case "createdAtGT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createdAtGT"))
			it.CreatedAtGT, err = ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
		case "createdAtGTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createdAtGTE"))
			it.CreatedAtGTE, err = ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
		case "createdAtLT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createdAtLT"))
			it.CreatedAtLT, err = ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
		case "createdAtLTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createdAtLTE"))
			it.CreatedAtLTE, err = ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
		case "expiresAt":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("expiresAt"))
			it.ExpiresAt, err = ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
		case "expiresAtNEQ":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("expiresAtNEQ"))
			it.ExpiresAtNEQ, err = ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
		case "expiresAtIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("expiresAtIn"))
			it.ExpiresAtIn, err = ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
		case "expiresAtNotIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("expiresAtNotIn"))
			it.ExpiresAtNotIn, err = ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
		case "expiresAtGT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("expiresAtGT"))
			it.ExpiresAtGT, err = ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
		case "expiresAtGTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("expiresAtGTE"))
			it.ExpiresAtGTE, err = ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
		case "expiresAtLT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("expiresAtLT"))
			it.ExpiresAtLT, err = ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
		case "expiresAtLTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("expiresAtLTE"))
			it.ExpiresAtLTE, err = ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
		case "hasOwnerMerchant":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasOwnerMerchant"))
			it.HasOwnerMerchant, err = ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
		case "hasOwnerMerchantWith":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasOwnerMerchantWith"))
			it.HasOwnerMerchantWith, err = ec.unmarshalOMerchantWhereInput2wallitentMerchantWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
		case "hasDiscountEligibleUsers":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasDiscountEligibleUsers"))
			it.HasDiscountEligibleUsers, err = ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
		case "hasDiscountEligibleUsersWith":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasDiscountEligibleUsersWith"))
			it.HasDiscountEligibleUsersWith, err = ec.unmarshalOUserWhereInput2wallitentUserWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
		case "hasDiscountOfferNotification":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasDiscountOfferNotification"))
			it.HasDiscountOfferNotification, err = ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
		case "hasDiscountOfferNotificationWith":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasDiscountOfferNotificationWith"))
			it.HasDiscountOfferNotificationWith, err = ec.unmarshalONotificationWhereInput2wallitentNotificationWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputExchangeAuthTokenForUserProfileInput(ctx context.Context, obj interface{}) (model.ExchangeAuthTokenForUserProfileInput, error) {
	var it model.ExchangeAuthTokenForUserProfileInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"identityProviderID"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "identityProviderID":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("identityProviderID"))
			it.IdentityProviderID, err = ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputExchangePublicTokenParams(ctx context.Context, obj interface{}) (model.ExchangePublicTokenParams, error) {
	var it model.ExchangePublicTokenParams
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"userId", "publicToken"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "userId":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("userId"))
			it.UserID, err = ec.unmarshalNID2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "publicToken":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("publicToken"))
			it.PublicToken, err = ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputMerchantWhereInput(ctx context.Context, obj interface{}) (ent.MerchantWhereInput, error) {
	var it ent.MerchantWhereInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"not", "and", "or", "id", "idNEQ", "idIn", "idNotIn", "idGT", "idGTE", "idLT", "idLTE", "name", "nameNEQ", "nameIn", "nameNotIn", "nameGT", "nameGTE", "nameLT", "nameLTE", "nameContains", "nameHasPrefix", "nameHasSuffix", "nameEqualFold", "nameContainsFold", "hasDiscountOffers", "hasDiscountOffersWith"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "not":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("not"))
			it.Not, err = ec.unmarshalOMerchantWhereInput2wallitentMerchantWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
		case "and":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("and"))
			it.And, err = ec.unmarshalOMerchantWhereInput2wallitentMerchantWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
		case "or":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("or"))
			it.Or, err = ec.unmarshalOMerchantWhereInput2wallitentMerchantWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
		case "id":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
			it.ID, err = ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "idNEQ":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idNEQ"))
			it.IDNEQ, err = ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "idIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idIn"))
			it.IDIn, err = ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "idNotIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idNotIn"))
			it.IDNotIn, err = ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "idGT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idGT"))
			it.IDGT, err = ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "idGTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idGTE"))
			it.IDGTE, err = ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "idLT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idLT"))
			it.IDLT, err = ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "idLTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idLTE"))
			it.IDLTE, err = ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "name":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
			it.Name, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "nameNEQ":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameNEQ"))
			it.NameNEQ, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "nameIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameIn"))
			it.NameIn, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "nameNotIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameNotIn"))
			it.NameNotIn, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "nameGT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameGT"))
			it.NameGT, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "nameGTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameGTE"))
			it.NameGTE, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "nameLT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameLT"))
			it.NameLT, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "nameLTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameLTE"))
			it.NameLTE, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "nameContains":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameContains"))
			it.NameContains, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "nameHasPrefix":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameHasPrefix"))
			it.NameHasPrefix, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "nameHasSuffix":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameHasSuffix"))
			it.NameHasSuffix, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "nameEqualFold":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameEqualFold"))
			it.NameEqualFold, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "nameContainsFold":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameContainsFold"))
			it.NameContainsFold, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "hasDiscountOffers":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasDiscountOffers"))
			it.HasDiscountOffers, err = ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
		case "hasDiscountOffersWith":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasDiscountOffersWith"))
			it.HasDiscountOffersWith, err = ec.unmarshalODiscountOfferWhereInput2wallitentDiscountOfferWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputNotificationOrder(ctx context.Context, obj interface{}) (ent.NotificationOrder, error) {
	var it ent.NotificationOrder
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	if _, present := asMap["direction"]; !present {
		asMap["direction"] = "ASC"
	}

	fieldsInOrder := [...]string{"direction", "field"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "direction":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("direction"))
			it.Direction, err = ec.unmarshalNOrderDirection2wallitentOrderDirection(ctx, v)
			if err != nil {
				return it, err
			}
		case "field":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("field"))
			it.Field, err = ec.unmarshalNNotificationOrderField2wallitentNotificationOrderField(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputNotificationWhereInput(ctx context.Context, obj interface{}) (ent.NotificationWhereInput, error) {
	var it ent.NotificationWhereInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"not", "and", "or", "id", "idNEQ", "idIn", "idNotIn", "idGT", "idGTE", "idLT", "idLTE", "checkedInApp", "checkedInAppNEQ", "type", "typeNEQ", "typeIn", "typeNotIn", "createdAt", "createdAtNEQ", "createdAtIn", "createdAtNotIn", "createdAtGT", "createdAtGTE", "createdAtLT", "createdAtLTE", "includedInAggregatedOfferAt", "includedInAggregatedOfferAtNEQ", "includedInAggregatedOfferAtIn", "includedInAggregatedOfferAtNotIn", "includedInAggregatedOfferAtGT", "includedInAggregatedOfferAtGTE", "includedInAggregatedOfferAtLT", "includedInAggregatedOfferAtLTE", "includedInAggregatedOfferAtIsNil", "includedInAggregatedOfferAtNotNil", "hasNotificationRecipient", "hasNotificationRecipientWith", "hasNotificationDiscountOffer", "hasNotificationDiscountOfferWith"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "not":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("not"))
			it.Not, err = ec.unmarshalONotificationWhereInput2wallitentNotificationWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
		case "and":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("and"))
			it.And, err = ec.unmarshalONotificationWhereInput2wallitentNotificationWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
		case "or":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("or"))
			it.Or, err = ec.unmarshalONotificationWhereInput2wallitentNotificationWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
		case "id":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
			it.ID, err = ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "idNEQ":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idNEQ"))
			it.IDNEQ, err = ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "idIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idIn"))
			it.IDIn, err = ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "idNotIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idNotIn"))
			it.IDNotIn, err = ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "idGT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idGT"))
			it.IDGT, err = ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "idGTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idGTE"))
			it.IDGTE, err = ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "idLT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idLT"))
			it.IDLT, err = ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "idLTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idLTE"))
			it.IDLTE, err = ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "checkedInApp":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("checkedInApp"))
			it.CheckedInApp, err = ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
		case "checkedInAppNEQ":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("checkedInAppNEQ"))
			it.CheckedInAppNEQ, err = ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
		case "type":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("type"))
			it.Type, err = ec.unmarshalONotificationType2wallitentnotificationType(ctx, v)
			if err != nil {
				return it, err
			}
		case "typeNEQ":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("typeNEQ"))
			it.TypeNEQ, err = ec.unmarshalONotificationType2wallitentnotificationType(ctx, v)
			if err != nil {
				return it, err
			}
		case "typeIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("typeIn"))
			it.TypeIn, err = ec.unmarshalONotificationType2wallitentnotificationType(ctx, v)
			if err != nil {
				return it, err
			}
		case "typeNotIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("typeNotIn"))
			it.TypeNotIn, err = ec.unmarshalONotificationType2wallitentnotificationType(ctx, v)
			if err != nil {
				return it, err
			}
		case "createdAt":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createdAt"))
			it.CreatedAt, err = ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
		case "createdAtNEQ":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createdAtNEQ"))
			it.CreatedAtNEQ, err = ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
		case "createdAtIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createdAtIn"))
			it.CreatedAtIn, err = ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
		case "createdAtNotIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createdAtNotIn"))
			it.CreatedAtNotIn, err = ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
		case "createdAtGT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createdAtGT"))
			it.CreatedAtGT, err = ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
		case "createdAtGTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createdAtGTE"))
			it.CreatedAtGTE, err = ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
		case "createdAtLT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createdAtLT"))
			it.CreatedAtLT, err = ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
		case "createdAtLTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createdAtLTE"))
			it.CreatedAtLTE, err = ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
		case "includedInAggregatedOfferAt":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("includedInAggregatedOfferAt"))
			it.IncludedInAggregatedOfferAt, err = ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
		case "includedInAggregatedOfferAtNEQ":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("includedInAggregatedOfferAtNEQ"))
			it.IncludedInAggregatedOfferAtNEQ, err = ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
		case "includedInAggregatedOfferAtIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("includedInAggregatedOfferAtIn"))
			it.IncludedInAggregatedOfferAtIn, err = ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
		case "includedInAggregatedOfferAtNotIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("includedInAggregatedOfferAtNotIn"))
			it.IncludedInAggregatedOfferAtNotIn, err = ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
		case "includedInAggregatedOfferAtGT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("includedInAggregatedOfferAtGT"))
			it.IncludedInAggregatedOfferAtGT, err = ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
		case "includedInAggregatedOfferAtGTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("includedInAggregatedOfferAtGTE"))
			it.IncludedInAggregatedOfferAtGTE, err = ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
		case "includedInAggregatedOfferAtLT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("includedInAggregatedOfferAtLT"))
			it.IncludedInAggregatedOfferAtLT, err = ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
		case "includedInAggregatedOfferAtLTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("includedInAggregatedOfferAtLTE"))
			it.IncludedInAggregatedOfferAtLTE, err = ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
		case "includedInAggregatedOfferAtIsNil":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("includedInAggregatedOfferAtIsNil"))
			it.IncludedInAggregatedOfferAtIsNil, err = ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
		case "includedInAggregatedOfferAtNotNil":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("includedInAggregatedOfferAtNotNil"))
			it.IncludedInAggregatedOfferAtNotNil, err = ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
		case "hasNotificationRecipient":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasNotificationRecipient"))
			it.HasNotificationRecipient, err = ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
		case "hasNotificationRecipientWith":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasNotificationRecipientWith"))
			it.HasNotificationRecipientWith, err = ec.unmarshalOUserWhereInput2wallitentUserWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
		case "hasNotificationDiscountOffer":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasNotificationDiscountOffer"))
			it.HasNotificationDiscountOffer, err = ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
		case "hasNotificationDiscountOfferWith":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasNotificationDiscountOfferWith"))
			it.HasNotificationDiscountOfferWith, err = ec.unmarshalODiscountOfferWhereInput2wallitentDiscountOfferWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputPlaidInstitutionAccountWhereInput(ctx context.Context, obj interface{}) (ent.PlaidInstitutionAccountWhereInput, error) {
	var it ent.PlaidInstitutionAccountWhereInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"not", "and", "or", "id", "idNEQ", "idIn", "idNotIn", "idGT", "idGTE", "idLT", "idLTE", "accountID", "accountIDNEQ", "accountIDIn", "accountIDNotIn", "accountIDGT", "accountIDGTE", "accountIDLT", "accountIDLTE", "accountIDContains", "accountIDHasPrefix", "accountIDHasSuffix", "accountIDEqualFold", "accountIDContainsFold", "balanceAvailable", "balanceAvailableNEQ", "balanceAvailableIn", "balanceAvailableNotIn", "balanceAvailableGT", "balanceAvailableGTE", "balanceAvailableLT", "balanceAvailableLTE", "balanceCurrent", "balanceCurrentNEQ", "balanceCurrentIn", "balanceCurrentNotIn", "balanceCurrentGT", "balanceCurrentGTE", "balanceCurrentLT", "balanceCurrentLTE", "balanceIsoCurrencyCode", "balanceIsoCurrencyCodeNEQ", "balanceIsoCurrencyCodeIn", "balanceIsoCurrencyCodeNotIn", "balanceIsoCurrencyCodeGT", "balanceIsoCurrencyCodeGTE", "balanceIsoCurrencyCodeLT", "balanceIsoCurrencyCodeLTE", "balanceIsoCurrencyCodeContains", "balanceIsoCurrencyCodeHasPrefix", "balanceIsoCurrencyCodeHasSuffix", "balanceIsoCurrencyCodeEqualFold", "balanceIsoCurrencyCodeContainsFold", "mask", "maskNEQ", "maskIn", "maskNotIn", "maskGT", "maskGTE", "maskLT", "maskLTE", "maskContains", "maskHasPrefix", "maskHasSuffix", "maskEqualFold", "maskContainsFold", "name", "nameNEQ", "nameIn", "nameNotIn", "nameGT", "nameGTE", "nameLT", "nameLTE", "nameContains", "nameHasPrefix", "nameHasSuffix", "nameEqualFold", "nameContainsFold", "officialName", "officialNameNEQ", "officialNameIn", "officialNameNotIn", "officialNameGT", "officialNameGTE", "officialNameLT", "officialNameLTE", "officialNameContains", "officialNameHasPrefix", "officialNameHasSuffix", "officialNameIsNil", "officialNameNotNil", "officialNameEqualFold", "officialNameContainsFold", "type", "typeNEQ", "typeIn", "typeNotIn", "typeGT", "typeGTE", "typeLT", "typeLTE", "typeContains", "typeHasPrefix", "typeHasSuffix", "typeEqualFold", "typeContainsFold", "hasParentInstitution", "hasParentInstitutionWith", "hasTransactions", "hasTransactionsWith"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "not":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("not"))
			it.Not, err = ec.unmarshalOPlaidInstitutionAccountWhereInput2wallitentPlaidInstitutionAccountWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
		case "and":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("and"))
			it.And, err = ec.unmarshalOPlaidInstitutionAccountWhereInput2wallitentPlaidInstitutionAccountWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
		case "or":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("or"))
			it.Or, err = ec.unmarshalOPlaidInstitutionAccountWhereInput2wallitentPlaidInstitutionAccountWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
		case "id":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
			it.ID, err = ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "idNEQ":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idNEQ"))
			it.IDNEQ, err = ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "idIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idIn"))
			it.IDIn, err = ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "idNotIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idNotIn"))
			it.IDNotIn, err = ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "idGT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idGT"))
			it.IDGT, err = ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "idGTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idGTE"))
			it.IDGTE, err = ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "idLT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idLT"))
			it.IDLT, err = ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "idLTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idLTE"))
			it.IDLTE, err = ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "accountID":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("accountID"))
			it.AccountID, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "accountIDNEQ":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("accountIDNEQ"))
			it.AccountIDNEQ, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "accountIDIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("accountIDIn"))
			it.AccountIDIn, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "accountIDNotIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("accountIDNotIn"))
			it.AccountIDNotIn, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "accountIDGT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("accountIDGT"))
			it.AccountIDGT, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "accountIDGTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("accountIDGTE"))
			it.AccountIDGTE, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "accountIDLT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("accountIDLT"))
			it.AccountIDLT, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "accountIDLTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("accountIDLTE"))
			it.AccountIDLTE, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "accountIDContains":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("accountIDContains"))
			it.AccountIDContains, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "accountIDHasPrefix":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("accountIDHasPrefix"))
			it.AccountIDHasPrefix, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "accountIDHasSuffix":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("accountIDHasSuffix"))
			it.AccountIDHasSuffix, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "accountIDEqualFold":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("accountIDEqualFold"))
			it.AccountIDEqualFold, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "accountIDContainsFold":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("accountIDContainsFold"))
			it.AccountIDContainsFold, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "balanceAvailable":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("balanceAvailable"))
			it.BalanceAvailable, err = ec.unmarshalOFloat2float64(ctx, v)
			if err != nil {
				return it, err
			}
		case "balanceAvailableNEQ":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("balanceAvailableNEQ"))
			it.BalanceAvailableNEQ, err = ec.unmarshalOFloat2float64(ctx, v)
			if err != nil {
				return it, err
			}
		case "balanceAvailableIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("balanceAvailableIn"))
			it.BalanceAvailableIn, err = ec.unmarshalOFloat2float64(ctx, v)
			if err != nil {
				return it, err
			}
		case "balanceAvailableNotIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("balanceAvailableNotIn"))
			it.BalanceAvailableNotIn, err = ec.unmarshalOFloat2float64(ctx, v)
			if err != nil {
				return it, err
			}
		case "balanceAvailableGT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("balanceAvailableGT"))
			it.BalanceAvailableGT, err = ec.unmarshalOFloat2float64(ctx, v)
			if err != nil {
				return it, err
			}
		case "balanceAvailableGTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("balanceAvailableGTE"))
			it.BalanceAvailableGTE, err = ec.unmarshalOFloat2float64(ctx, v)
			if err != nil {
				return it, err
			}
		case "balanceAvailableLT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("balanceAvailableLT"))
			it.BalanceAvailableLT, err = ec.unmarshalOFloat2float64(ctx, v)
			if err != nil {
				return it, err
			}
		case "balanceAvailableLTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("balanceAvailableLTE"))
			it.BalanceAvailableLTE, err = ec.unmarshalOFloat2float64(ctx, v)
			if err != nil {
				return it, err
			}
		case "balanceCurrent":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("balanceCurrent"))
			it.BalanceCurrent, err = ec.unmarshalOFloat2float64(ctx, v)
			if err != nil {
				return it, err
			}
		case "balanceCurrentNEQ":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("balanceCurrentNEQ"))
			it.BalanceCurrentNEQ, err = ec.unmarshalOFloat2float64(ctx, v)
			if err != nil {
				return it, err
			}
		case "balanceCurrentIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("balanceCurrentIn"))
			it.BalanceCurrentIn, err = ec.unmarshalOFloat2float64(ctx, v)
			if err != nil {
				return it, err
			}
		case "balanceCurrentNotIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("balanceCurrentNotIn"))
			it.BalanceCurrentNotIn, err = ec.unmarshalOFloat2float64(ctx, v)
			if err != nil {
				return it, err
			}
		case "balanceCurrentGT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("balanceCurrentGT"))
			it.BalanceCurrentGT, err = ec.unmarshalOFloat2float64(ctx, v)
			if err != nil {
				return it, err
			}
		case "balanceCurrentGTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("balanceCurrentGTE"))
			it.BalanceCurrentGTE, err = ec.unmarshalOFloat2float64(ctx, v)
			if err != nil {
				return it, err
			}
		case "balanceCurrentLT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("balanceCurrentLT"))
			it.BalanceCurrentLT, err = ec.unmarshalOFloat2float64(ctx, v)
			if err != nil {
				return it, err
			}
		case "balanceCurrentLTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("balanceCurrentLTE"))
			it.BalanceCurrentLTE, err = ec.unmarshalOFloat2float64(ctx, v)
			if err != nil {
				return it, err
			}
		case "balanceIsoCurrencyCode":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("balanceIsoCurrencyCode"))
			it.BalanceIsoCurrencyCode, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "balanceIsoCurrencyCodeNEQ":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("balanceIsoCurrencyCodeNEQ"))
			it.BalanceIsoCurrencyCodeNEQ, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "balanceIsoCurrencyCodeIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("balanceIsoCurrencyCodeIn"))
			it.BalanceIsoCurrencyCodeIn, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "balanceIsoCurrencyCodeNotIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("balanceIsoCurrencyCodeNotIn"))
			it.BalanceIsoCurrencyCodeNotIn, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "balanceIsoCurrencyCodeGT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("balanceIsoCurrencyCodeGT"))
			it.BalanceIsoCurrencyCodeGT, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "balanceIsoCurrencyCodeGTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("balanceIsoCurrencyCodeGTE"))
			it.BalanceIsoCurrencyCodeGTE, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "balanceIsoCurrencyCodeLT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("balanceIsoCurrencyCodeLT"))
			it.BalanceIsoCurrencyCodeLT, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "balanceIsoCurrencyCodeLTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("balanceIsoCurrencyCodeLTE"))
			it.BalanceIsoCurrencyCodeLTE, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "balanceIsoCurrencyCodeContains":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("balanceIsoCurrencyCodeContains"))
			it.BalanceIsoCurrencyCodeContains, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "balanceIsoCurrencyCodeHasPrefix":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("balanceIsoCurrencyCodeHasPrefix"))
			it.BalanceIsoCurrencyCodeHasPrefix, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "balanceIsoCurrencyCodeHasSuffix":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("balanceIsoCurrencyCodeHasSuffix"))
			it.BalanceIsoCurrencyCodeHasSuffix, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "balanceIsoCurrencyCodeEqualFold":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("balanceIsoCurrencyCodeEqualFold"))
			it.BalanceIsoCurrencyCodeEqualFold, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "balanceIsoCurrencyCodeContainsFold":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("balanceIsoCurrencyCodeContainsFold"))
			it.BalanceIsoCurrencyCodeContainsFold, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "mask":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("mask"))
			it.Mask, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "maskNEQ":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("maskNEQ"))
			it.MaskNEQ, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "maskIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("maskIn"))
			it.MaskIn, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "maskNotIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("maskNotIn"))
			it.MaskNotIn, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "maskGT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("maskGT"))
			it.MaskGT, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "maskGTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("maskGTE"))
			it.MaskGTE, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "maskLT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("maskLT"))
			it.MaskLT, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "maskLTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("maskLTE"))
			it.MaskLTE, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "maskContains":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("maskContains"))
			it.MaskContains, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "maskHasPrefix":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("maskHasPrefix"))
			it.MaskHasPrefix, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "maskHasSuffix":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("maskHasSuffix"))
			it.MaskHasSuffix, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "maskEqualFold":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("maskEqualFold"))
			it.MaskEqualFold, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "maskContainsFold":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("maskContainsFold"))
			it.MaskContainsFold, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "name":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
			it.Name, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "nameNEQ":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameNEQ"))
			it.NameNEQ, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "nameIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameIn"))
			it.NameIn, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "nameNotIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameNotIn"))
			it.NameNotIn, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "nameGT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameGT"))
			it.NameGT, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "nameGTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameGTE"))
			it.NameGTE, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "nameLT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameLT"))
			it.NameLT, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "nameLTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameLTE"))
			it.NameLTE, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "nameContains":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameContains"))
			it.NameContains, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "nameHasPrefix":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameHasPrefix"))
			it.NameHasPrefix, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "nameHasSuffix":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameHasSuffix"))
			it.NameHasSuffix, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "nameEqualFold":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameEqualFold"))
			it.NameEqualFold, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "nameContainsFold":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameContainsFold"))
			it.NameContainsFold, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "officialName":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("officialName"))
			it.OfficialName, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "officialNameNEQ":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("officialNameNEQ"))
			it.OfficialNameNEQ, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "officialNameIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("officialNameIn"))
			it.OfficialNameIn, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "officialNameNotIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("officialNameNotIn"))
			it.OfficialNameNotIn, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "officialNameGT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("officialNameGT"))
			it.OfficialNameGT, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "officialNameGTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("officialNameGTE"))
			it.OfficialNameGTE, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "officialNameLT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("officialNameLT"))
			it.OfficialNameLT, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "officialNameLTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("officialNameLTE"))
			it.OfficialNameLTE, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "officialNameContains":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("officialNameContains"))
			it.OfficialNameContains, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "officialNameHasPrefix":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("officialNameHasPrefix"))
			it.OfficialNameHasPrefix, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "officialNameHasSuffix":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("officialNameHasSuffix"))
			it.OfficialNameHasSuffix, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "officialNameIsNil":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("officialNameIsNil"))
			it.OfficialNameIsNil, err = ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
		case "officialNameNotNil":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("officialNameNotNil"))
			it.OfficialNameNotNil, err = ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
		case "officialNameEqualFold":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("officialNameEqualFold"))
			it.OfficialNameEqualFold, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "officialNameContainsFold":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("officialNameContainsFold"))
			it.OfficialNameContainsFold, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "type":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("type"))
			it.Type, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "typeNEQ":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("typeNEQ"))
			it.TypeNEQ, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "typeIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("typeIn"))
			it.TypeIn, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "typeNotIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("typeNotIn"))
			it.TypeNotIn, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "typeGT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("typeGT"))
			it.TypeGT, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "typeGTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("typeGTE"))
			it.TypeGTE, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "typeLT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("typeLT"))
			it.TypeLT, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "typeLTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("typeLTE"))
			it.TypeLTE, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "typeContains":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("typeContains"))
			it.TypeContains, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "typeHasPrefix":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("typeHasPrefix"))
			it.TypeHasPrefix, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "typeHasSuffix":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("typeHasSuffix"))
			it.TypeHasSuffix, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "typeEqualFold":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("typeEqualFold"))
			it.TypeEqualFold, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "typeContainsFold":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("typeContainsFold"))
			it.TypeContainsFold, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "hasParentInstitution":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasParentInstitution"))
			it.HasParentInstitution, err = ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
		case "hasParentInstitutionWith":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasParentInstitutionWith"))
			it.HasParentInstitutionWith, err = ec.unmarshalOPlaidInstitutionWhereInput2wallitentPlaidInstitutionWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
		case "hasTransactions":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasTransactions"))
			it.HasTransactions, err = ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
		case "hasTransactionsWith":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasTransactionsWith"))
			it.HasTransactionsWith, err = ec.unmarshalOTransactionWhereInput2wallitentTransactionWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputPlaidInstitutionWhereInput(ctx context.Context, obj interface{}) (ent.PlaidInstitutionWhereInput, error) {
	var it ent.PlaidInstitutionWhereInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"not", "and", "or", "id", "idNEQ", "idIn", "idNotIn", "idGT", "idGTE", "idLT", "idLTE", "institutionID", "institutionIDNEQ", "institutionIDIn", "institutionIDNotIn", "institutionIDGT", "institutionIDGTE", "institutionIDLT", "institutionIDLTE", "institutionIDContains", "institutionIDHasPrefix", "institutionIDHasSuffix", "institutionIDEqualFold", "institutionIDContainsFold", "name", "nameNEQ", "nameIn", "nameNotIn", "nameGT", "nameGTE", "nameLT", "nameLTE", "nameContains", "nameHasPrefix", "nameHasSuffix", "nameEqualFold", "nameContainsFold", "hasPlaidItem", "hasPlaidItemWith", "hasAccounts", "hasAccountsWith"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "not":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("not"))
			it.Not, err = ec.unmarshalOPlaidInstitutionWhereInput2wallitentPlaidInstitutionWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
		case "and":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("and"))
			it.And, err = ec.unmarshalOPlaidInstitutionWhereInput2wallitentPlaidInstitutionWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
		case "or":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("or"))
			it.Or, err = ec.unmarshalOPlaidInstitutionWhereInput2wallitentPlaidInstitutionWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
		case "id":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
			it.ID, err = ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "idNEQ":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idNEQ"))
			it.IDNEQ, err = ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "idIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idIn"))
			it.IDIn, err = ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "idNotIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idNotIn"))
			it.IDNotIn, err = ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "idGT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idGT"))
			it.IDGT, err = ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "idGTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idGTE"))
			it.IDGTE, err = ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "idLT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idLT"))
			it.IDLT, err = ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "idLTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idLTE"))
			it.IDLTE, err = ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "institutionID":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("institutionID"))
			it.InstitutionID, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "institutionIDNEQ":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("institutionIDNEQ"))
			it.InstitutionIDNEQ, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "institutionIDIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("institutionIDIn"))
			it.InstitutionIDIn, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "institutionIDNotIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("institutionIDNotIn"))
			it.InstitutionIDNotIn, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "institutionIDGT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("institutionIDGT"))
			it.InstitutionIDGT, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "institutionIDGTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("institutionIDGTE"))
			it.InstitutionIDGTE, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "institutionIDLT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("institutionIDLT"))
			it.InstitutionIDLT, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "institutionIDLTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("institutionIDLTE"))
			it.InstitutionIDLTE, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "institutionIDContains":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("institutionIDContains"))
			it.InstitutionIDContains, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "institutionIDHasPrefix":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("institutionIDHasPrefix"))
			it.InstitutionIDHasPrefix, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "institutionIDHasSuffix":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("institutionIDHasSuffix"))
			it.InstitutionIDHasSuffix, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "institutionIDEqualFold":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("institutionIDEqualFold"))
			it.InstitutionIDEqualFold, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "institutionIDContainsFold":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("institutionIDContainsFold"))
			it.InstitutionIDContainsFold, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "name":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
			it.Name, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "nameNEQ":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameNEQ"))
			it.NameNEQ, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "nameIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameIn"))
			it.NameIn, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "nameNotIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameNotIn"))
			it.NameNotIn, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "nameGT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameGT"))
			it.NameGT, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "nameGTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameGTE"))
			it.NameGTE, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "nameLT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameLT"))
			it.NameLT, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "nameLTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameLTE"))
			it.NameLTE, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "nameContains":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameContains"))
			it.NameContains, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "nameHasPrefix":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameHasPrefix"))
			it.NameHasPrefix, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "nameHasSuffix":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameHasSuffix"))
			it.NameHasSuffix, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "nameEqualFold":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameEqualFold"))
			it.NameEqualFold, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "nameContainsFold":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameContainsFold"))
			it.NameContainsFold, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "hasPlaidItem":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasPlaidItem"))
			it.HasPlaidItem, err = ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
		case "hasPlaidItemWith":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasPlaidItemWith"))
			it.HasPlaidItemWith, err = ec.unmarshalOPlaidItemWhereInput2wallitentPlaidItemWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
		case "hasAccounts":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasAccounts"))
			it.HasAccounts, err = ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
		case "hasAccountsWith":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasAccountsWith"))
			it.HasAccountsWith, err = ec.unmarshalOPlaidInstitutionAccountWhereInput2wallitentPlaidInstitutionAccountWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputPlaidItemOrder(ctx context.Context, obj interface{}) (ent.PlaidItemOrder, error) {
	var it ent.PlaidItemOrder
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	if _, present := asMap["direction"]; !present {
		asMap["direction"] = "ASC"
	}

	fieldsInOrder := [...]string{"direction", "field"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "direction":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("direction"))
			it.Direction, err = ec.unmarshalNOrderDirection2wallitentOrderDirection(ctx, v)
			if err != nil {
				return it, err
			}
		case "field":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("field"))
			it.Field, err = ec.unmarshalNPlaidItemOrderField2wallitentPlaidItemOrderField(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputPlaidItemWhereInput(ctx context.Context, obj interface{}) (ent.PlaidItemWhereInput, error) {
	var it ent.PlaidItemWhereInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"not", "and", "or", "id", "idNEQ", "idIn", "idNotIn", "idGT", "idGTE", "idLT", "idLTE", "itemID", "itemIDNEQ", "itemIDIn", "itemIDNotIn", "itemIDGT", "itemIDGTE", "itemIDLT", "itemIDLTE", "itemIDContains", "itemIDHasPrefix", "itemIDHasSuffix", "itemIDEqualFold", "itemIDContainsFold", "accessToken", "accessTokenNEQ", "accessTokenIn", "accessTokenNotIn", "accessTokenGT", "accessTokenGTE", "accessTokenLT", "accessTokenLTE", "accessTokenContains", "accessTokenHasPrefix", "accessTokenHasSuffix", "accessTokenEqualFold", "accessTokenContainsFold", "createdAt", "createdAtNEQ", "createdAtIn", "createdAtNotIn", "createdAtGT", "createdAtGTE", "createdAtLT", "createdAtLTE", "updatedAt", "updatedAtNEQ", "updatedAtIn", "updatedAtNotIn", "updatedAtGT", "updatedAtGTE", "updatedAtLT", "updatedAtLTE", "hasOwner", "hasOwnerWith", "hasTransactionSyncs", "hasTransactionSyncsWith", "hasInstitution", "hasInstitutionWith"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "not":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("not"))
			it.Not, err = ec.unmarshalOPlaidItemWhereInput2wallitentPlaidItemWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
		case "and":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("and"))
			it.And, err = ec.unmarshalOPlaidItemWhereInput2wallitentPlaidItemWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
		case "or":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("or"))
			it.Or, err = ec.unmarshalOPlaidItemWhereInput2wallitentPlaidItemWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
		case "id":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
			it.ID, err = ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "idNEQ":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idNEQ"))
			it.IDNEQ, err = ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "idIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idIn"))
			it.IDIn, err = ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "idNotIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idNotIn"))
			it.IDNotIn, err = ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "idGT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idGT"))
			it.IDGT, err = ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "idGTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idGTE"))
			it.IDGTE, err = ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "idLT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idLT"))
			it.IDLT, err = ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "idLTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idLTE"))
			it.IDLTE, err = ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "itemID":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("itemID"))
			it.ItemID, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "itemIDNEQ":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("itemIDNEQ"))
			it.ItemIDNEQ, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "itemIDIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("itemIDIn"))
			it.ItemIDIn, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "itemIDNotIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("itemIDNotIn"))
			it.ItemIDNotIn, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "itemIDGT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("itemIDGT"))
			it.ItemIDGT, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "itemIDGTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("itemIDGTE"))
			it.ItemIDGTE, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "itemIDLT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("itemIDLT"))
			it.ItemIDLT, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "itemIDLTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("itemIDLTE"))
			it.ItemIDLTE, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "itemIDContains":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("itemIDContains"))
			it.ItemIDContains, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "itemIDHasPrefix":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("itemIDHasPrefix"))
			it.ItemIDHasPrefix, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "itemIDHasSuffix":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("itemIDHasSuffix"))
			it.ItemIDHasSuffix, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "itemIDEqualFold":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("itemIDEqualFold"))
			it.ItemIDEqualFold, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "itemIDContainsFold":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("itemIDContainsFold"))
			it.ItemIDContainsFold, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "accessToken":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("accessToken"))
			it.AccessToken, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "accessTokenNEQ":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("accessTokenNEQ"))
			it.AccessTokenNEQ, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "accessTokenIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("accessTokenIn"))
			it.AccessTokenIn, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "accessTokenNotIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("accessTokenNotIn"))
			it.AccessTokenNotIn, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "accessTokenGT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("accessTokenGT"))
			it.AccessTokenGT, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "accessTokenGTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("accessTokenGTE"))
			it.AccessTokenGTE, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "accessTokenLT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("accessTokenLT"))
			it.AccessTokenLT, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "accessTokenLTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("accessTokenLTE"))
			it.AccessTokenLTE, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "accessTokenContains":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("accessTokenContains"))
			it.AccessTokenContains, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "accessTokenHasPrefix":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("accessTokenHasPrefix"))
			it.AccessTokenHasPrefix, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "accessTokenHasSuffix":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("accessTokenHasSuffix"))
			it.AccessTokenHasSuffix, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "accessTokenEqualFold":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("accessTokenEqualFold"))
			it.AccessTokenEqualFold, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "accessTokenContainsFold":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("accessTokenContainsFold"))
			it.AccessTokenContainsFold, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "createdAt":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createdAt"))
			it.CreatedAt, err = ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
		case "createdAtNEQ":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createdAtNEQ"))
			it.CreatedAtNEQ, err = ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
		case "createdAtIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createdAtIn"))
			it.CreatedAtIn, err = ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
		case "createdAtNotIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createdAtNotIn"))
			it.CreatedAtNotIn, err = ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
		case "createdAtGT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createdAtGT"))
			it.CreatedAtGT, err = ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
		case "createdAtGTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createdAtGTE"))
			it.CreatedAtGTE, err = ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
		case "createdAtLT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createdAtLT"))
			it.CreatedAtLT, err = ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
		case "createdAtLTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createdAtLTE"))
			it.CreatedAtLTE, err = ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
		case "updatedAt":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("updatedAt"))
			it.UpdatedAt, err = ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
		case "updatedAtNEQ":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("updatedAtNEQ"))
			it.UpdatedAtNEQ, err = ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
		case "updatedAtIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("updatedAtIn"))
			it.UpdatedAtIn, err = ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
		case "updatedAtNotIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("updatedAtNotIn"))
			it.UpdatedAtNotIn, err = ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
		case "updatedAtGT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("updatedAtGT"))
			it.UpdatedAtGT, err = ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
		case "updatedAtGTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("updatedAtGTE"))
			it.UpdatedAtGTE, err = ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
		case "updatedAtLT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("updatedAtLT"))
			it.UpdatedAtLT, err = ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
		case "updatedAtLTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("updatedAtLTE"))
			it.UpdatedAtLTE, err = ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
		case "hasOwner":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasOwner"))
			it.HasOwner, err = ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
		case "hasOwnerWith":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasOwnerWith"))
			it.HasOwnerWith, err = ec.unmarshalOUserWhereInput2wallitentUserWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
		case "hasTransactionSyncs":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasTransactionSyncs"))
			it.HasTransactionSyncs, err = ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
		case "hasTransactionSyncsWith":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasTransactionSyncsWith"))
			it.HasTransactionSyncsWith, err = ec.unmarshalOTransactionSyncWhereInput2wallitentTransactionSyncWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
		case "hasInstitution":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasInstitution"))
			it.HasInstitution, err = ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
		case "hasInstitutionWith":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasInstitutionWith"))
			it.HasInstitutionWith, err = ec.unmarshalOPlaidInstitutionWhereInput2wallitentPlaidInstitutionWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputSpendingCategoryWhereInput(ctx context.Context, obj interface{}) (ent.SpendingCategoryWhereInput, error) {
	var it ent.SpendingCategoryWhereInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"not", "and", "or", "id", "idNEQ", "idIn", "idNotIn", "idGT", "idGTE", "idLT", "idLTE", "name", "nameNEQ", "nameIn", "nameNotIn", "nameGT", "nameGTE", "nameLT", "nameLTE", "nameContains", "nameHasPrefix", "nameHasSuffix", "nameEqualFold", "nameContainsFold", "categoryID", "categoryIDNEQ", "categoryIDIn", "categoryIDNotIn", "categoryIDGT", "categoryIDGTE", "categoryIDLT", "categoryIDLTE", "categoryIDContains", "categoryIDHasPrefix", "categoryIDHasSuffix", "categoryIDEqualFold", "categoryIDContainsFold", "createdAt", "createdAtNEQ", "createdAtIn", "createdAtNotIn", "createdAtGT", "createdAtGTE", "createdAtLT", "createdAtLTE", "hasCategoryTransactions", "hasCategoryTransactionsWith", "hasInterestedUsers", "hasInterestedUsersWith"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "not":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("not"))
			it.Not, err = ec.unmarshalOSpendingCategoryWhereInput2wallitentSpendingCategoryWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
		case "and":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("and"))
			it.And, err = ec.unmarshalOSpendingCategoryWhereInput2wallitentSpendingCategoryWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
		case "or":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("or"))
			it.Or, err = ec.unmarshalOSpendingCategoryWhereInput2wallitentSpendingCategoryWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
		case "id":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
			it.ID, err = ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "idNEQ":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idNEQ"))
			it.IDNEQ, err = ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "idIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idIn"))
			it.IDIn, err = ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "idNotIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idNotIn"))
			it.IDNotIn, err = ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "idGT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idGT"))
			it.IDGT, err = ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "idGTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idGTE"))
			it.IDGTE, err = ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "idLT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idLT"))
			it.IDLT, err = ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "idLTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idLTE"))
			it.IDLTE, err = ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "name":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
			it.Name, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "nameNEQ":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameNEQ"))
			it.NameNEQ, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "nameIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameIn"))
			it.NameIn, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "nameNotIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameNotIn"))
			it.NameNotIn, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "nameGT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameGT"))
			it.NameGT, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "nameGTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameGTE"))
			it.NameGTE, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "nameLT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameLT"))
			it.NameLT, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "nameLTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameLTE"))
			it.NameLTE, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "nameContains":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameContains"))
			it.NameContains, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "nameHasPrefix":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameHasPrefix"))
			it.NameHasPrefix, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "nameHasSuffix":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameHasSuffix"))
			it.NameHasSuffix, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "nameEqualFold":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameEqualFold"))
			it.NameEqualFold, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "nameContainsFold":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameContainsFold"))
			it.NameContainsFold, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "categoryID":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("categoryID"))
			it.CategoryID, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "categoryIDNEQ":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("categoryIDNEQ"))
			it.CategoryIDNEQ, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "categoryIDIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("categoryIDIn"))
			it.CategoryIDIn, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "categoryIDNotIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("categoryIDNotIn"))
			it.CategoryIDNotIn, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "categoryIDGT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("categoryIDGT"))
			it.CategoryIDGT, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "categoryIDGTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("categoryIDGTE"))
			it.CategoryIDGTE, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "categoryIDLT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("categoryIDLT"))
			it.CategoryIDLT, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "categoryIDLTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("categoryIDLTE"))
			it.CategoryIDLTE, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "categoryIDContains":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("categoryIDContains"))
			it.CategoryIDContains, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "categoryIDHasPrefix":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("categoryIDHasPrefix"))
			it.CategoryIDHasPrefix, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "categoryIDHasSuffix":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("categoryIDHasSuffix"))
			it.CategoryIDHasSuffix, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "categoryIDEqualFold":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("categoryIDEqualFold"))
			it.CategoryIDEqualFold, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "categoryIDContainsFold":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("categoryIDContainsFold"))
			it.CategoryIDContainsFold, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "createdAt":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createdAt"))
			it.CreatedAt, err = ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
		case "createdAtNEQ":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createdAtNEQ"))
			it.CreatedAtNEQ, err = ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
		case "createdAtIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createdAtIn"))
			it.CreatedAtIn, err = ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
		case "createdAtNotIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createdAtNotIn"))
			it.CreatedAtNotIn, err = ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
		case "createdAtGT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createdAtGT"))
			it.CreatedAtGT, err = ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
		case "createdAtGTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createdAtGTE"))
			it.CreatedAtGTE, err = ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
		case "createdAtLT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createdAtLT"))
			it.CreatedAtLT, err = ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
		case "createdAtLTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createdAtLTE"))
			it.CreatedAtLTE, err = ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
		case "hasCategoryTransactions":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasCategoryTransactions"))
			it.HasCategoryTransactions, err = ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
		case "hasCategoryTransactionsWith":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasCategoryTransactionsWith"))
			it.HasCategoryTransactionsWith, err = ec.unmarshalOTransactionWhereInput2wallitentTransactionWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
		case "hasInterestedUsers":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasInterestedUsers"))
			it.HasInterestedUsers, err = ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
		case "hasInterestedUsersWith":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasInterestedUsersWith"))
			it.HasInterestedUsersWith, err = ec.unmarshalOUserWhereInput2wallitentUserWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputTransactionOrder(ctx context.Context, obj interface{}) (ent.TransactionOrder, error) {
	var it ent.TransactionOrder
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	if _, present := asMap["direction"]; !present {
		asMap["direction"] = "ASC"
	}

	fieldsInOrder := [...]string{"direction", "field"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "direction":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("direction"))
			it.Direction, err = ec.unmarshalNOrderDirection2wallitentOrderDirection(ctx, v)
			if err != nil {
				return it, err
			}
		case "field":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("field"))
			it.Field, err = ec.unmarshalNTransactionOrderField2wallitentTransactionOrderField(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputTransactionSyncWhereInput(ctx context.Context, obj interface{}) (ent.TransactionSyncWhereInput, error) {
	var it ent.TransactionSyncWhereInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"not", "and", "or", "id", "idNEQ", "idIn", "idNotIn", "idGT", "idGTE", "idLT", "idLTE", "createdAt", "createdAtNEQ", "createdAtIn", "createdAtNotIn", "createdAtGT", "createdAtGTE", "createdAtLT", "createdAtLTE", "cursor", "cursorNEQ", "cursorIn", "cursorNotIn", "cursorGT", "cursorGTE", "cursorLT", "cursorLTE", "cursorContains", "cursorHasPrefix", "cursorHasSuffix", "cursorEqualFold", "cursorContainsFold", "hasItem", "hasItemWith"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "not":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("not"))
			it.Not, err = ec.unmarshalOTransactionSyncWhereInput2wallitentTransactionSyncWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
		case "and":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("and"))
			it.And, err = ec.unmarshalOTransactionSyncWhereInput2wallitentTransactionSyncWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
		case "or":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("or"))
			it.Or, err = ec.unmarshalOTransactionSyncWhereInput2wallitentTransactionSyncWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
		case "id":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
			it.ID, err = ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "idNEQ":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idNEQ"))
			it.IDNEQ, err = ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "idIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idIn"))
			it.IDIn, err = ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "idNotIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idNotIn"))
			it.IDNotIn, err = ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "idGT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idGT"))
			it.IDGT, err = ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "idGTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idGTE"))
			it.IDGTE, err = ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "idLT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idLT"))
			it.IDLT, err = ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "idLTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idLTE"))
			it.IDLTE, err = ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "createdAt":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createdAt"))
			it.CreatedAt, err = ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
		case "createdAtNEQ":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createdAtNEQ"))
			it.CreatedAtNEQ, err = ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
		case "createdAtIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createdAtIn"))
			it.CreatedAtIn, err = ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
		case "createdAtNotIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createdAtNotIn"))
			it.CreatedAtNotIn, err = ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
		case "createdAtGT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createdAtGT"))
			it.CreatedAtGT, err = ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
		case "createdAtGTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createdAtGTE"))
			it.CreatedAtGTE, err = ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
		case "createdAtLT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createdAtLT"))
			it.CreatedAtLT, err = ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
		case "createdAtLTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createdAtLTE"))
			it.CreatedAtLTE, err = ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
		case "cursor":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("cursor"))
			it.Cursor, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "cursorNEQ":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("cursorNEQ"))
			it.CursorNEQ, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "cursorIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("cursorIn"))
			it.CursorIn, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "cursorNotIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("cursorNotIn"))
			it.CursorNotIn, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "cursorGT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("cursorGT"))
			it.CursorGT, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "cursorGTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("cursorGTE"))
			it.CursorGTE, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "cursorLT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("cursorLT"))
			it.CursorLT, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "cursorLTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("cursorLTE"))
			it.CursorLTE, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "cursorContains":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("cursorContains"))
			it.CursorContains, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "cursorHasPrefix":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("cursorHasPrefix"))
			it.CursorHasPrefix, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "cursorHasSuffix":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("cursorHasSuffix"))
			it.CursorHasSuffix, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "cursorEqualFold":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("cursorEqualFold"))
			it.CursorEqualFold, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "cursorContainsFold":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("cursorContainsFold"))
			it.CursorContainsFold, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "hasItem":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasItem"))
			it.HasItem, err = ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
		case "hasItemWith":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasItemWith"))
			it.HasItemWith, err = ec.unmarshalOPlaidItemWhereInput2wallitentPlaidItemWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputTransactionWhereInput(ctx context.Context, obj interface{}) (ent.TransactionWhereInput, error) {
	var it ent.TransactionWhereInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"not", "and", "or", "id", "idNEQ", "idIn", "idNotIn", "idGT", "idGTE", "idLT", "idLTE", "financialAccountID", "financialAccountIDNEQ", "financialAccountIDIn", "financialAccountIDNotIn", "financialAccountIDGT", "financialAccountIDGTE", "financialAccountIDLT", "financialAccountIDLTE", "financialAccountIDContains", "financialAccountIDHasPrefix", "financialAccountIDHasSuffix", "financialAccountIDEqualFold", "financialAccountIDContainsFold", "amount", "amountNEQ", "amountIn", "amountNotIn", "amountGT", "amountGTE", "amountLT", "amountLTE", "isoCurrencyCode", "isoCurrencyCodeNEQ", "isoCurrencyCodeIn", "isoCurrencyCodeNotIn", "isoCurrencyCodeGT", "isoCurrencyCodeGTE", "isoCurrencyCodeLT", "isoCurrencyCodeLTE", "isoCurrencyCodeContains", "isoCurrencyCodeHasPrefix", "isoCurrencyCodeHasSuffix", "isoCurrencyCodeEqualFold", "isoCurrencyCodeContainsFold", "unofficialCurrencyCode", "unofficialCurrencyCodeNEQ", "unofficialCurrencyCodeIn", "unofficialCurrencyCodeNotIn", "unofficialCurrencyCodeGT", "unofficialCurrencyCodeGTE", "unofficialCurrencyCodeLT", "unofficialCurrencyCodeLTE", "unofficialCurrencyCodeContains", "unofficialCurrencyCodeHasPrefix", "unofficialCurrencyCodeHasSuffix", "unofficialCurrencyCodeEqualFold", "unofficialCurrencyCodeContainsFold", "category", "categoryNEQ", "categoryIn", "categoryNotIn", "categoryGT", "categoryGTE", "categoryLT", "categoryLTE", "categoryContains", "categoryHasPrefix", "categoryHasSuffix", "categoryIsNil", "categoryNotNil", "categoryEqualFold", "categoryContainsFold", "categoryID", "categoryIDNEQ", "categoryIDIn", "categoryIDNotIn", "categoryIDGT", "categoryIDGTE", "categoryIDLT", "categoryIDLTE", "categoryIDContains", "categoryIDHasPrefix", "categoryIDHasSuffix", "categoryIDIsNil", "categoryIDNotNil", "categoryIDEqualFold", "categoryIDContainsFold", "checkNumber", "checkNumberNEQ", "checkNumberIn", "checkNumberNotIn", "checkNumberGT", "checkNumberGTE", "checkNumberLT", "checkNumberLTE", "checkNumberContains", "checkNumberHasPrefix", "checkNumberHasSuffix", "checkNumberEqualFold", "checkNumberContainsFold", "date", "dateNEQ", "dateIn", "dateNotIn", "dateGT", "dateGTE", "dateLT", "dateLTE", "dateContains", "dateHasPrefix", "dateHasSuffix", "dateEqualFold", "dateContainsFold", "datetime", "datetimeNEQ", "datetimeIn", "datetimeNotIn", "datetimeGT", "datetimeGTE", "datetimeLT", "datetimeLTE", "datetimeIsNil", "datetimeNotNil", "authorizedDate", "authorizedDateNEQ", "authorizedDateIn", "authorizedDateNotIn", "authorizedDateGT", "authorizedDateGTE", "authorizedDateLT", "authorizedDateLTE", "authorizedDateContains", "authorizedDateHasPrefix", "authorizedDateHasSuffix", "authorizedDateIsNil", "authorizedDateNotNil", "authorizedDateEqualFold", "authorizedDateContainsFold", "authorizedDatetime", "authorizedDatetimeNEQ", "authorizedDatetimeIn", "authorizedDatetimeNotIn", "authorizedDatetimeGT", "authorizedDatetimeGTE", "authorizedDatetimeLT", "authorizedDatetimeLTE", "authorizedDatetimeIsNil", "authorizedDatetimeNotNil", "locationAddress", "locationAddressNEQ", "locationAddressIn", "locationAddressNotIn", "locationAddressGT", "locationAddressGTE", "locationAddressLT", "locationAddressLTE", "locationAddressContains", "locationAddressHasPrefix", "locationAddressHasSuffix", "locationAddressEqualFold", "locationAddressContainsFold", "locationCity", "locationCityNEQ", "locationCityIn", "locationCityNotIn", "locationCityGT", "locationCityGTE", "locationCityLT", "locationCityLTE", "locationCityContains", "locationCityHasPrefix", "locationCityHasSuffix", "locationCityEqualFold", "locationCityContainsFold", "locationRegion", "locationRegionNEQ", "locationRegionIn", "locationRegionNotIn", "locationRegionGT", "locationRegionGTE", "locationRegionLT", "locationRegionLTE", "locationRegionContains", "locationRegionHasPrefix", "locationRegionHasSuffix", "locationRegionEqualFold", "locationRegionContainsFold", "locationPostalCode", "locationPostalCodeNEQ", "locationPostalCodeIn", "locationPostalCodeNotIn", "locationPostalCodeGT", "locationPostalCodeGTE", "locationPostalCodeLT", "locationPostalCodeLTE", "locationPostalCodeContains", "locationPostalCodeHasPrefix", "locationPostalCodeHasSuffix", "locationPostalCodeEqualFold", "locationPostalCodeContainsFold", "locationLat", "locationLatNEQ", "locationLatIn", "locationLatNotIn", "locationLatGT", "locationLatGTE", "locationLatLT", "locationLatLTE", "locationLon", "locationLonNEQ", "locationLonIn", "locationLonNotIn", "locationLonGT", "locationLonGTE", "locationLonLT", "locationLonLTE", "locationStoreNumber", "locationStoreNumberNEQ", "locationStoreNumberIn", "locationStoreNumberNotIn", "locationStoreNumberGT", "locationStoreNumberGTE", "locationStoreNumberLT", "locationStoreNumberLTE", "locationStoreNumberContains", "locationStoreNumberHasPrefix", "locationStoreNumberHasSuffix", "locationStoreNumberEqualFold", "locationStoreNumberContainsFold", "name", "nameNEQ", "nameIn", "nameNotIn", "nameGT", "nameGTE", "nameLT", "nameLTE", "nameContains", "nameHasPrefix", "nameHasSuffix", "nameEqualFold", "nameContainsFold", "merchantName", "merchantNameNEQ", "merchantNameIn", "merchantNameNotIn", "merchantNameGT", "merchantNameGTE", "merchantNameLT", "merchantNameLTE", "merchantNameContains", "merchantNameHasPrefix", "merchantNameHasSuffix", "merchantNameEqualFold", "merchantNameContainsFold", "paymentChannel", "paymentChannelNEQ", "paymentChannelIn", "paymentChannelNotIn", "paymentChannelGT", "paymentChannelGTE", "paymentChannelLT", "paymentChannelLTE", "paymentChannelContains", "paymentChannelHasPrefix", "paymentChannelHasSuffix", "paymentChannelEqualFold", "paymentChannelContainsFold", "pending", "pendingNEQ", "pendingTransactionID", "pendingTransactionIDNEQ", "pendingTransactionIDIn", "pendingTransactionIDNotIn", "pendingTransactionIDGT", "pendingTransactionIDGTE", "pendingTransactionIDLT", "pendingTransactionIDLTE", "pendingTransactionIDContains", "pendingTransactionIDHasPrefix", "pendingTransactionIDHasSuffix", "pendingTransactionIDEqualFold", "pendingTransactionIDContainsFold", "accountOwner", "accountOwnerNEQ", "accountOwnerIn", "accountOwnerNotIn", "accountOwnerGT", "accountOwnerGTE", "accountOwnerLT", "accountOwnerLTE", "accountOwnerContains", "accountOwnerHasPrefix", "accountOwnerHasSuffix", "accountOwnerEqualFold", "accountOwnerContainsFold", "transactionID", "transactionIDNEQ", "transactionIDIn", "transactionIDNotIn", "transactionIDGT", "transactionIDGTE", "transactionIDLT", "transactionIDLTE", "transactionIDContains", "transactionIDHasPrefix", "transactionIDHasSuffix", "transactionIDEqualFold", "transactionIDContainsFold", "transactionCode", "transactionCodeNEQ", "transactionCodeIn", "transactionCodeNotIn", "transactionCodeGT", "transactionCodeGTE", "transactionCodeLT", "transactionCodeLTE", "transactionCodeContains", "transactionCodeHasPrefix", "transactionCodeHasSuffix", "transactionCodeEqualFold", "transactionCodeContainsFold", "createdAt", "createdAtNEQ", "createdAtIn", "createdAtNotIn", "createdAtGT", "createdAtGTE", "createdAtLT", "createdAtLTE", "hasInstitutionAccount", "hasInstitutionAccountWith", "hasTransactionCategories", "hasTransactionCategoriesWith"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "not":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("not"))
			it.Not, err = ec.unmarshalOTransactionWhereInput2wallitentTransactionWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
		case "and":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("and"))
			it.And, err = ec.unmarshalOTransactionWhereInput2wallitentTransactionWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
		case "or":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("or"))
			it.Or, err = ec.unmarshalOTransactionWhereInput2wallitentTransactionWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
		case "id":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
			it.ID, err = ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "idNEQ":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idNEQ"))
			it.IDNEQ, err = ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "idIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idIn"))
			it.IDIn, err = ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "idNotIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idNotIn"))
			it.IDNotIn, err = ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "idGT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idGT"))
			it.IDGT, err = ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "idGTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idGTE"))
			it.IDGTE, err = ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "idLT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idLT"))
			it.IDLT, err = ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "idLTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idLTE"))
			it.IDLTE, err = ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "financialAccountID":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("financialAccountID"))
			it.FinancialAccountID, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "financialAccountIDNEQ":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("financialAccountIDNEQ"))
			it.FinancialAccountIDNEQ, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "financialAccountIDIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("financialAccountIDIn"))
			it.FinancialAccountIDIn, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "financialAccountIDNotIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("financialAccountIDNotIn"))
			it.FinancialAccountIDNotIn, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "financialAccountIDGT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("financialAccountIDGT"))
			it.FinancialAccountIDGT, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "financialAccountIDGTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("financialAccountIDGTE"))
			it.FinancialAccountIDGTE, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "financialAccountIDLT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("financialAccountIDLT"))
			it.FinancialAccountIDLT, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "financialAccountIDLTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("financialAccountIDLTE"))
			it.FinancialAccountIDLTE, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "financialAccountIDContains":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("financialAccountIDContains"))
			it.FinancialAccountIDContains, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "financialAccountIDHasPrefix":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("financialAccountIDHasPrefix"))
			it.FinancialAccountIDHasPrefix, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "financialAccountIDHasSuffix":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("financialAccountIDHasSuffix"))
			it.FinancialAccountIDHasSuffix, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "financialAccountIDEqualFold":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("financialAccountIDEqualFold"))
			it.FinancialAccountIDEqualFold, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "financialAccountIDContainsFold":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("financialAccountIDContainsFold"))
			it.FinancialAccountIDContainsFold, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "amount":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("amount"))
			it.Amount, err = ec.unmarshalOFloat2float64(ctx, v)
			if err != nil {
				return it, err
			}
		case "amountNEQ":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("amountNEQ"))
			it.AmountNEQ, err = ec.unmarshalOFloat2float64(ctx, v)
			if err != nil {
				return it, err
			}
		case "amountIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("amountIn"))
			it.AmountIn, err = ec.unmarshalOFloat2float64(ctx, v)
			if err != nil {
				return it, err
			}
		case "amountNotIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("amountNotIn"))
			it.AmountNotIn, err = ec.unmarshalOFloat2float64(ctx, v)
			if err != nil {
				return it, err
			}
		case "amountGT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("amountGT"))
			it.AmountGT, err = ec.unmarshalOFloat2float64(ctx, v)
			if err != nil {
				return it, err
			}
		case "amountGTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("amountGTE"))
			it.AmountGTE, err = ec.unmarshalOFloat2float64(ctx, v)
			if err != nil {
				return it, err
			}
		case "amountLT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("amountLT"))
			it.AmountLT, err = ec.unmarshalOFloat2float64(ctx, v)
			if err != nil {
				return it, err
			}
		case "amountLTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("amountLTE"))
			it.AmountLTE, err = ec.unmarshalOFloat2float64(ctx, v)
			if err != nil {
				return it, err
			}
		case "isoCurrencyCode":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("isoCurrencyCode"))
			it.IsoCurrencyCode, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "isoCurrencyCodeNEQ":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("isoCurrencyCodeNEQ"))
			it.IsoCurrencyCodeNEQ, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "isoCurrencyCodeIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("isoCurrencyCodeIn"))
			it.IsoCurrencyCodeIn, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "isoCurrencyCodeNotIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("isoCurrencyCodeNotIn"))
			it.IsoCurrencyCodeNotIn, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "isoCurrencyCodeGT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("isoCurrencyCodeGT"))
			it.IsoCurrencyCodeGT, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "isoCurrencyCodeGTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("isoCurrencyCodeGTE"))
			it.IsoCurrencyCodeGTE, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "isoCurrencyCodeLT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("isoCurrencyCodeLT"))
			it.IsoCurrencyCodeLT, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "isoCurrencyCodeLTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("isoCurrencyCodeLTE"))
			it.IsoCurrencyCodeLTE, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "isoCurrencyCodeContains":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("isoCurrencyCodeContains"))
			it.IsoCurrencyCodeContains, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "isoCurrencyCodeHasPrefix":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("isoCurrencyCodeHasPrefix"))
			it.IsoCurrencyCodeHasPrefix, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "isoCurrencyCodeHasSuffix":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("isoCurrencyCodeHasSuffix"))
			it.IsoCurrencyCodeHasSuffix, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "isoCurrencyCodeEqualFold":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("isoCurrencyCodeEqualFold"))
			it.IsoCurrencyCodeEqualFold, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "isoCurrencyCodeContainsFold":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("isoCurrencyCodeContainsFold"))
			it.IsoCurrencyCodeContainsFold, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "unofficialCurrencyCode":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("unofficialCurrencyCode"))
			it.UnofficialCurrencyCode, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "unofficialCurrencyCodeNEQ":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("unofficialCurrencyCodeNEQ"))
			it.UnofficialCurrencyCodeNEQ, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "unofficialCurrencyCodeIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("unofficialCurrencyCodeIn"))
			it.UnofficialCurrencyCodeIn, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "unofficialCurrencyCodeNotIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("unofficialCurrencyCodeNotIn"))
			it.UnofficialCurrencyCodeNotIn, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "unofficialCurrencyCodeGT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("unofficialCurrencyCodeGT"))
			it.UnofficialCurrencyCodeGT, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "unofficialCurrencyCodeGTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("unofficialCurrencyCodeGTE"))
			it.UnofficialCurrencyCodeGTE, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "unofficialCurrencyCodeLT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("unofficialCurrencyCodeLT"))
			it.UnofficialCurrencyCodeLT, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "unofficialCurrencyCodeLTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("unofficialCurrencyCodeLTE"))
			it.UnofficialCurrencyCodeLTE, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "unofficialCurrencyCodeContains":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("unofficialCurrencyCodeContains"))
			it.UnofficialCurrencyCodeContains, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "unofficialCurrencyCodeHasPrefix":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("unofficialCurrencyCodeHasPrefix"))
			it.UnofficialCurrencyCodeHasPrefix, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "unofficialCurrencyCodeHasSuffix":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("unofficialCurrencyCodeHasSuffix"))
			it.UnofficialCurrencyCodeHasSuffix, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "unofficialCurrencyCodeEqualFold":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("unofficialCurrencyCodeEqualFold"))
			it.UnofficialCurrencyCodeEqualFold, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "unofficialCurrencyCodeContainsFold":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("unofficialCurrencyCodeContainsFold"))
			it.UnofficialCurrencyCodeContainsFold, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "category":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("category"))
			it.Category, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "categoryNEQ":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("categoryNEQ"))
			it.CategoryNEQ, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "categoryIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("categoryIn"))
			it.CategoryIn, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "categoryNotIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("categoryNotIn"))
			it.CategoryNotIn, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "categoryGT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("categoryGT"))
			it.CategoryGT, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "categoryGTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("categoryGTE"))
			it.CategoryGTE, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "categoryLT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("categoryLT"))
			it.CategoryLT, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "categoryLTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("categoryLTE"))
			it.CategoryLTE, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "categoryContains":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("categoryContains"))
			it.CategoryContains, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "categoryHasPrefix":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("categoryHasPrefix"))
			it.CategoryHasPrefix, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "categoryHasSuffix":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("categoryHasSuffix"))
			it.CategoryHasSuffix, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "categoryIsNil":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("categoryIsNil"))
			it.CategoryIsNil, err = ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
		case "categoryNotNil":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("categoryNotNil"))
			it.CategoryNotNil, err = ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
		case "categoryEqualFold":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("categoryEqualFold"))
			it.CategoryEqualFold, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "categoryContainsFold":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("categoryContainsFold"))
			it.CategoryContainsFold, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "categoryID":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("categoryID"))
			it.CategoryID, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "categoryIDNEQ":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("categoryIDNEQ"))
			it.CategoryIDNEQ, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "categoryIDIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("categoryIDIn"))
			it.CategoryIDIn, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "categoryIDNotIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("categoryIDNotIn"))
			it.CategoryIDNotIn, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "categoryIDGT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("categoryIDGT"))
			it.CategoryIDGT, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "categoryIDGTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("categoryIDGTE"))
			it.CategoryIDGTE, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "categoryIDLT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("categoryIDLT"))
			it.CategoryIDLT, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "categoryIDLTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("categoryIDLTE"))
			it.CategoryIDLTE, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "categoryIDContains":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("categoryIDContains"))
			it.CategoryIDContains, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "categoryIDHasPrefix":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("categoryIDHasPrefix"))
			it.CategoryIDHasPrefix, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "categoryIDHasSuffix":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("categoryIDHasSuffix"))
			it.CategoryIDHasSuffix, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "categoryIDIsNil":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("categoryIDIsNil"))
			it.CategoryIDIsNil, err = ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
		case "categoryIDNotNil":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("categoryIDNotNil"))
			it.CategoryIDNotNil, err = ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
		case "categoryIDEqualFold":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("categoryIDEqualFold"))
			it.CategoryIDEqualFold, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "categoryIDContainsFold":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("categoryIDContainsFold"))
			it.CategoryIDContainsFold, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "checkNumber":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("checkNumber"))
			it.CheckNumber, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "checkNumberNEQ":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("checkNumberNEQ"))
			it.CheckNumberNEQ, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "checkNumberIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("checkNumberIn"))
			it.CheckNumberIn, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "checkNumberNotIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("checkNumberNotIn"))
			it.CheckNumberNotIn, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "checkNumberGT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("checkNumberGT"))
			it.CheckNumberGT, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "checkNumberGTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("checkNumberGTE"))
			it.CheckNumberGTE, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "checkNumberLT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("checkNumberLT"))
			it.CheckNumberLT, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "checkNumberLTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("checkNumberLTE"))
			it.CheckNumberLTE, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "checkNumberContains":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("checkNumberContains"))
			it.CheckNumberContains, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "checkNumberHasPrefix":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("checkNumberHasPrefix"))
			it.CheckNumberHasPrefix, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "checkNumberHasSuffix":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("checkNumberHasSuffix"))
			it.CheckNumberHasSuffix, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "checkNumberEqualFold":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("checkNumberEqualFold"))
			it.CheckNumberEqualFold, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "checkNumberContainsFold":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("checkNumberContainsFold"))
			it.CheckNumberContainsFold, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "date":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("date"))
			it.Date, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "dateNEQ":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("dateNEQ"))
			it.DateNEQ, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "dateIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("dateIn"))
			it.DateIn, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "dateNotIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("dateNotIn"))
			it.DateNotIn, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "dateGT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("dateGT"))
			it.DateGT, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "dateGTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("dateGTE"))
			it.DateGTE, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "dateLT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("dateLT"))
			it.DateLT, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "dateLTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("dateLTE"))
			it.DateLTE, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "dateContains":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("dateContains"))
			it.DateContains, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "dateHasPrefix":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("dateHasPrefix"))
			it.DateHasPrefix, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "dateHasSuffix":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("dateHasSuffix"))
			it.DateHasSuffix, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "dateEqualFold":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("dateEqualFold"))
			it.DateEqualFold, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "dateContainsFold":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("dateContainsFold"))
			it.DateContainsFold, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "datetime":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("datetime"))
			it.Datetime, err = ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
		case "datetimeNEQ":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("datetimeNEQ"))
			it.DatetimeNEQ, err = ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
		case "datetimeIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("datetimeIn"))
			it.DatetimeIn, err = ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
		case "datetimeNotIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("datetimeNotIn"))
			it.DatetimeNotIn, err = ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
		case "datetimeGT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("datetimeGT"))
			it.DatetimeGT, err = ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
		case "datetimeGTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("datetimeGTE"))
			it.DatetimeGTE, err = ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
		case "datetimeLT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("datetimeLT"))
			it.DatetimeLT, err = ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
		case "datetimeLTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("datetimeLTE"))
			it.DatetimeLTE, err = ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
		case "datetimeIsNil":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("datetimeIsNil"))
			it.DatetimeIsNil, err = ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
		case "datetimeNotNil":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("datetimeNotNil"))
			it.DatetimeNotNil, err = ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
		case "authorizedDate":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("authorizedDate"))
			it.AuthorizedDate, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "authorizedDateNEQ":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("authorizedDateNEQ"))
			it.AuthorizedDateNEQ, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "authorizedDateIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("authorizedDateIn"))
			it.AuthorizedDateIn, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "authorizedDateNotIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("authorizedDateNotIn"))
			it.AuthorizedDateNotIn, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "authorizedDateGT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("authorizedDateGT"))
			it.AuthorizedDateGT, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "authorizedDateGTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("authorizedDateGTE"))
			it.AuthorizedDateGTE, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "authorizedDateLT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("authorizedDateLT"))
			it.AuthorizedDateLT, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "authorizedDateLTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("authorizedDateLTE"))
			it.AuthorizedDateLTE, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "authorizedDateContains":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("authorizedDateContains"))
			it.AuthorizedDateContains, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "authorizedDateHasPrefix":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("authorizedDateHasPrefix"))
			it.AuthorizedDateHasPrefix, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "authorizedDateHasSuffix":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("authorizedDateHasSuffix"))
			it.AuthorizedDateHasSuffix, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "authorizedDateIsNil":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("authorizedDateIsNil"))
			it.AuthorizedDateIsNil, err = ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
		case "authorizedDateNotNil":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("authorizedDateNotNil"))
			it.AuthorizedDateNotNil, err = ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
		case "authorizedDateEqualFold":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("authorizedDateEqualFold"))
			it.AuthorizedDateEqualFold, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "authorizedDateContainsFold":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("authorizedDateContainsFold"))
			it.AuthorizedDateContainsFold, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "authorizedDatetime":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("authorizedDatetime"))
			it.AuthorizedDatetime, err = ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
		case "authorizedDatetimeNEQ":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("authorizedDatetimeNEQ"))
			it.AuthorizedDatetimeNEQ, err = ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
		case "authorizedDatetimeIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("authorizedDatetimeIn"))
			it.AuthorizedDatetimeIn, err = ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
		case "authorizedDatetimeNotIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("authorizedDatetimeNotIn"))
			it.AuthorizedDatetimeNotIn, err = ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
		case "authorizedDatetimeGT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("authorizedDatetimeGT"))
			it.AuthorizedDatetimeGT, err = ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
		case "authorizedDatetimeGTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("authorizedDatetimeGTE"))
			it.AuthorizedDatetimeGTE, err = ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
		case "authorizedDatetimeLT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("authorizedDatetimeLT"))
			it.AuthorizedDatetimeLT, err = ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
		case "authorizedDatetimeLTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("authorizedDatetimeLTE"))
			it.AuthorizedDatetimeLTE, err = ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
		case "authorizedDatetimeIsNil":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("authorizedDatetimeIsNil"))
			it.AuthorizedDatetimeIsNil, err = ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
		case "authorizedDatetimeNotNil":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("authorizedDatetimeNotNil"))
			it.AuthorizedDatetimeNotNil, err = ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
		case "locationAddress":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("locationAddress"))
			it.LocationAddress, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "locationAddressNEQ":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("locationAddressNEQ"))
			it.LocationAddressNEQ, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "locationAddressIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("locationAddressIn"))
			it.LocationAddressIn, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "locationAddressNotIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("locationAddressNotIn"))
			it.LocationAddressNotIn, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "locationAddressGT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("locationAddressGT"))
			it.LocationAddressGT, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "locationAddressGTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("locationAddressGTE"))
			it.LocationAddressGTE, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "locationAddressLT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("locationAddressLT"))
			it.LocationAddressLT, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "locationAddressLTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("locationAddressLTE"))
			it.LocationAddressLTE, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "locationAddressContains":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("locationAddressContains"))
			it.LocationAddressContains, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "locationAddressHasPrefix":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("locationAddressHasPrefix"))
			it.LocationAddressHasPrefix, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "locationAddressHasSuffix":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("locationAddressHasSuffix"))
			it.LocationAddressHasSuffix, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "locationAddressEqualFold":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("locationAddressEqualFold"))
			it.LocationAddressEqualFold, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "locationAddressContainsFold":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("locationAddressContainsFold"))
			it.LocationAddressContainsFold, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "locationCity":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("locationCity"))
			it.LocationCity, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "locationCityNEQ":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("locationCityNEQ"))
			it.LocationCityNEQ, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "locationCityIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("locationCityIn"))
			it.LocationCityIn, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "locationCityNotIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("locationCityNotIn"))
			it.LocationCityNotIn, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "locationCityGT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("locationCityGT"))
			it.LocationCityGT, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "locationCityGTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("locationCityGTE"))
			it.LocationCityGTE, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "locationCityLT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("locationCityLT"))
			it.LocationCityLT, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "locationCityLTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("locationCityLTE"))
			it.LocationCityLTE, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "locationCityContains":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("locationCityContains"))
			it.LocationCityContains, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "locationCityHasPrefix":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("locationCityHasPrefix"))
			it.LocationCityHasPrefix, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "locationCityHasSuffix":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("locationCityHasSuffix"))
			it.LocationCityHasSuffix, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "locationCityEqualFold":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("locationCityEqualFold"))
			it.LocationCityEqualFold, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "locationCityContainsFold":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("locationCityContainsFold"))
			it.LocationCityContainsFold, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "locationRegion":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("locationRegion"))
			it.LocationRegion, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "locationRegionNEQ":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("locationRegionNEQ"))
			it.LocationRegionNEQ, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "locationRegionIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("locationRegionIn"))
			it.LocationRegionIn, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "locationRegionNotIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("locationRegionNotIn"))
			it.LocationRegionNotIn, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "locationRegionGT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("locationRegionGT"))
			it.LocationRegionGT, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "locationRegionGTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("locationRegionGTE"))
			it.LocationRegionGTE, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "locationRegionLT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("locationRegionLT"))
			it.LocationRegionLT, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "locationRegionLTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("locationRegionLTE"))
			it.LocationRegionLTE, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "locationRegionContains":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("locationRegionContains"))
			it.LocationRegionContains, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "locationRegionHasPrefix":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("locationRegionHasPrefix"))
			it.LocationRegionHasPrefix, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "locationRegionHasSuffix":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("locationRegionHasSuffix"))
			it.LocationRegionHasSuffix, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "locationRegionEqualFold":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("locationRegionEqualFold"))
			it.LocationRegionEqualFold, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "locationRegionContainsFold":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("locationRegionContainsFold"))
			it.LocationRegionContainsFold, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "locationPostalCode":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("locationPostalCode"))
			it.LocationPostalCode, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "locationPostalCodeNEQ":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("locationPostalCodeNEQ"))
			it.LocationPostalCodeNEQ, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "locationPostalCodeIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("locationPostalCodeIn"))
			it.LocationPostalCodeIn, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "locationPostalCodeNotIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("locationPostalCodeNotIn"))
			it.LocationPostalCodeNotIn, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "locationPostalCodeGT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("locationPostalCodeGT"))
			it.LocationPostalCodeGT, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "locationPostalCodeGTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("locationPostalCodeGTE"))
			it.LocationPostalCodeGTE, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "locationPostalCodeLT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("locationPostalCodeLT"))
			it.LocationPostalCodeLT, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "locationPostalCodeLTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("locationPostalCodeLTE"))
			it.LocationPostalCodeLTE, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "locationPostalCodeContains":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("locationPostalCodeContains"))
			it.LocationPostalCodeContains, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "locationPostalCodeHasPrefix":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("locationPostalCodeHasPrefix"))
			it.LocationPostalCodeHasPrefix, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "locationPostalCodeHasSuffix":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("locationPostalCodeHasSuffix"))
			it.LocationPostalCodeHasSuffix, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "locationPostalCodeEqualFold":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("locationPostalCodeEqualFold"))
			it.LocationPostalCodeEqualFold, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "locationPostalCodeContainsFold":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("locationPostalCodeContainsFold"))
			it.LocationPostalCodeContainsFold, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "locationLat":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("locationLat"))
			it.LocationLat, err = ec.unmarshalOFloat2float64(ctx, v)
			if err != nil {
				return it, err
			}
		case "locationLatNEQ":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("locationLatNEQ"))
			it.LocationLatNEQ, err = ec.unmarshalOFloat2float64(ctx, v)
			if err != nil {
				return it, err
			}
		case "locationLatIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("locationLatIn"))
			it.LocationLatIn, err = ec.unmarshalOFloat2float64(ctx, v)
			if err != nil {
				return it, err
			}
		case "locationLatNotIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("locationLatNotIn"))
			it.LocationLatNotIn, err = ec.unmarshalOFloat2float64(ctx, v)
			if err != nil {
				return it, err
			}
		case "locationLatGT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("locationLatGT"))
			it.LocationLatGT, err = ec.unmarshalOFloat2float64(ctx, v)
			if err != nil {
				return it, err
			}
		case "locationLatGTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("locationLatGTE"))
			it.LocationLatGTE, err = ec.unmarshalOFloat2float64(ctx, v)
			if err != nil {
				return it, err
			}
		case "locationLatLT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("locationLatLT"))
			it.LocationLatLT, err = ec.unmarshalOFloat2float64(ctx, v)
			if err != nil {
				return it, err
			}
		case "locationLatLTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("locationLatLTE"))
			it.LocationLatLTE, err = ec.unmarshalOFloat2float64(ctx, v)
			if err != nil {
				return it, err
			}
		case "locationLon":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("locationLon"))
			it.LocationLon, err = ec.unmarshalOFloat2float64(ctx, v)
			if err != nil {
				return it, err
			}
		case "locationLonNEQ":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("locationLonNEQ"))
			it.LocationLonNEQ, err = ec.unmarshalOFloat2float64(ctx, v)
			if err != nil {
				return it, err
			}
		case "locationLonIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("locationLonIn"))
			it.LocationLonIn, err = ec.unmarshalOFloat2float64(ctx, v)
			if err != nil {
				return it, err
			}
		case "locationLonNotIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("locationLonNotIn"))
			it.LocationLonNotIn, err = ec.unmarshalOFloat2float64(ctx, v)
			if err != nil {
				return it, err
			}
		case "locationLonGT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("locationLonGT"))
			it.LocationLonGT, err = ec.unmarshalOFloat2float64(ctx, v)
			if err != nil {
				return it, err
			}
		case "locationLonGTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("locationLonGTE"))
			it.LocationLonGTE, err = ec.unmarshalOFloat2float64(ctx, v)
			if err != nil {
				return it, err
			}
		case "locationLonLT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("locationLonLT"))
			it.LocationLonLT, err = ec.unmarshalOFloat2float64(ctx, v)
			if err != nil {
				return it, err
			}
		case "locationLonLTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("locationLonLTE"))
			it.LocationLonLTE, err = ec.unmarshalOFloat2float64(ctx, v)
			if err != nil {
				return it, err
			}
		case "locationStoreNumber":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("locationStoreNumber"))
			it.LocationStoreNumber, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "locationStoreNumberNEQ":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("locationStoreNumberNEQ"))
			it.LocationStoreNumberNEQ, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "locationStoreNumberIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("locationStoreNumberIn"))
			it.LocationStoreNumberIn, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "locationStoreNumberNotIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("locationStoreNumberNotIn"))
			it.LocationStoreNumberNotIn, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "locationStoreNumberGT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("locationStoreNumberGT"))
			it.LocationStoreNumberGT, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "locationStoreNumberGTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("locationStoreNumberGTE"))
			it.LocationStoreNumberGTE, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "locationStoreNumberLT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("locationStoreNumberLT"))
			it.LocationStoreNumberLT, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "locationStoreNumberLTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("locationStoreNumberLTE"))
			it.LocationStoreNumberLTE, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "locationStoreNumberContains":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("locationStoreNumberContains"))
			it.LocationStoreNumberContains, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "locationStoreNumberHasPrefix":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("locationStoreNumberHasPrefix"))
			it.LocationStoreNumberHasPrefix, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "locationStoreNumberHasSuffix":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("locationStoreNumberHasSuffix"))
			it.LocationStoreNumberHasSuffix, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "locationStoreNumberEqualFold":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("locationStoreNumberEqualFold"))
			it.LocationStoreNumberEqualFold, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "locationStoreNumberContainsFold":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("locationStoreNumberContainsFold"))
			it.LocationStoreNumberContainsFold, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "name":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
			it.Name, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "nameNEQ":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameNEQ"))
			it.NameNEQ, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "nameIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameIn"))
			it.NameIn, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "nameNotIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameNotIn"))
			it.NameNotIn, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "nameGT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameGT"))
			it.NameGT, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "nameGTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameGTE"))
			it.NameGTE, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "nameLT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameLT"))
			it.NameLT, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "nameLTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameLTE"))
			it.NameLTE, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "nameContains":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameContains"))
			it.NameContains, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "nameHasPrefix":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameHasPrefix"))
			it.NameHasPrefix, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "nameHasSuffix":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameHasSuffix"))
			it.NameHasSuffix, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "nameEqualFold":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameEqualFold"))
			it.NameEqualFold, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "nameContainsFold":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameContainsFold"))
			it.NameContainsFold, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "merchantName":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("merchantName"))
			it.MerchantName, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "merchantNameNEQ":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("merchantNameNEQ"))
			it.MerchantNameNEQ, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "merchantNameIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("merchantNameIn"))
			it.MerchantNameIn, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "merchantNameNotIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("merchantNameNotIn"))
			it.MerchantNameNotIn, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "merchantNameGT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("merchantNameGT"))
			it.MerchantNameGT, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "merchantNameGTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("merchantNameGTE"))
			it.MerchantNameGTE, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "merchantNameLT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("merchantNameLT"))
			it.MerchantNameLT, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "merchantNameLTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("merchantNameLTE"))
			it.MerchantNameLTE, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "merchantNameContains":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("merchantNameContains"))
			it.MerchantNameContains, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "merchantNameHasPrefix":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("merchantNameHasPrefix"))
			it.MerchantNameHasPrefix, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "merchantNameHasSuffix":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("merchantNameHasSuffix"))
			it.MerchantNameHasSuffix, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "merchantNameEqualFold":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("merchantNameEqualFold"))
			it.MerchantNameEqualFold, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "merchantNameContainsFold":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("merchantNameContainsFold"))
			it.MerchantNameContainsFold, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "paymentChannel":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("paymentChannel"))
			it.PaymentChannel, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "paymentChannelNEQ":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("paymentChannelNEQ"))
			it.PaymentChannelNEQ, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "paymentChannelIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("paymentChannelIn"))
			it.PaymentChannelIn, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "paymentChannelNotIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("paymentChannelNotIn"))
			it.PaymentChannelNotIn, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "paymentChannelGT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("paymentChannelGT"))
			it.PaymentChannelGT, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "paymentChannelGTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("paymentChannelGTE"))
			it.PaymentChannelGTE, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "paymentChannelLT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("paymentChannelLT"))
			it.PaymentChannelLT, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "paymentChannelLTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("paymentChannelLTE"))
			it.PaymentChannelLTE, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "paymentChannelContains":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("paymentChannelContains"))
			it.PaymentChannelContains, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "paymentChannelHasPrefix":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("paymentChannelHasPrefix"))
			it.PaymentChannelHasPrefix, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "paymentChannelHasSuffix":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("paymentChannelHasSuffix"))
			it.PaymentChannelHasSuffix, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "paymentChannelEqualFold":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("paymentChannelEqualFold"))
			it.PaymentChannelEqualFold, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "paymentChannelContainsFold":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("paymentChannelContainsFold"))
			it.PaymentChannelContainsFold, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "pending":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("pending"))
			it.Pending, err = ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
		case "pendingNEQ":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("pendingNEQ"))
			it.PendingNEQ, err = ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
		case "pendingTransactionID":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("pendingTransactionID"))
			it.PendingTransactionID, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "pendingTransactionIDNEQ":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("pendingTransactionIDNEQ"))
			it.PendingTransactionIDNEQ, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "pendingTransactionIDIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("pendingTransactionIDIn"))
			it.PendingTransactionIDIn, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "pendingTransactionIDNotIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("pendingTransactionIDNotIn"))
			it.PendingTransactionIDNotIn, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "pendingTransactionIDGT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("pendingTransactionIDGT"))
			it.PendingTransactionIDGT, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "pendingTransactionIDGTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("pendingTransactionIDGTE"))
			it.PendingTransactionIDGTE, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "pendingTransactionIDLT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("pendingTransactionIDLT"))
			it.PendingTransactionIDLT, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "pendingTransactionIDLTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("pendingTransactionIDLTE"))
			it.PendingTransactionIDLTE, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "pendingTransactionIDContains":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("pendingTransactionIDContains"))
			it.PendingTransactionIDContains, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "pendingTransactionIDHasPrefix":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("pendingTransactionIDHasPrefix"))
			it.PendingTransactionIDHasPrefix, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "pendingTransactionIDHasSuffix":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("pendingTransactionIDHasSuffix"))
			it.PendingTransactionIDHasSuffix, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "pendingTransactionIDEqualFold":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("pendingTransactionIDEqualFold"))
			it.PendingTransactionIDEqualFold, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "pendingTransactionIDContainsFold":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("pendingTransactionIDContainsFold"))
			it.PendingTransactionIDContainsFold, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "accountOwner":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("accountOwner"))
			it.AccountOwner, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "accountOwnerNEQ":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("accountOwnerNEQ"))
			it.AccountOwnerNEQ, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "accountOwnerIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("accountOwnerIn"))
			it.AccountOwnerIn, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "accountOwnerNotIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("accountOwnerNotIn"))
			it.AccountOwnerNotIn, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "accountOwnerGT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("accountOwnerGT"))
			it.AccountOwnerGT, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "accountOwnerGTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("accountOwnerGTE"))
			it.AccountOwnerGTE, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "accountOwnerLT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("accountOwnerLT"))
			it.AccountOwnerLT, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "accountOwnerLTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("accountOwnerLTE"))
			it.AccountOwnerLTE, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "accountOwnerContains":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("accountOwnerContains"))
			it.AccountOwnerContains, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "accountOwnerHasPrefix":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("accountOwnerHasPrefix"))
			it.AccountOwnerHasPrefix, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "accountOwnerHasSuffix":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("accountOwnerHasSuffix"))
			it.AccountOwnerHasSuffix, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "accountOwnerEqualFold":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("accountOwnerEqualFold"))
			it.AccountOwnerEqualFold, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "accountOwnerContainsFold":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("accountOwnerContainsFold"))
			it.AccountOwnerContainsFold, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "transactionID":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("transactionID"))
			it.TransactionID, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "transactionIDNEQ":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("transactionIDNEQ"))
			it.TransactionIDNEQ, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "transactionIDIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("transactionIDIn"))
			it.TransactionIDIn, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "transactionIDNotIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("transactionIDNotIn"))
			it.TransactionIDNotIn, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "transactionIDGT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("transactionIDGT"))
			it.TransactionIDGT, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "transactionIDGTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("transactionIDGTE"))
			it.TransactionIDGTE, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "transactionIDLT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("transactionIDLT"))
			it.TransactionIDLT, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "transactionIDLTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("transactionIDLTE"))
			it.TransactionIDLTE, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "transactionIDContains":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("transactionIDContains"))
			it.TransactionIDContains, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "transactionIDHasPrefix":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("transactionIDHasPrefix"))
			it.TransactionIDHasPrefix, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "transactionIDHasSuffix":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("transactionIDHasSuffix"))
			it.TransactionIDHasSuffix, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "transactionIDEqualFold":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("transactionIDEqualFold"))
			it.TransactionIDEqualFold, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "transactionIDContainsFold":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("transactionIDContainsFold"))
			it.TransactionIDContainsFold, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "transactionCode":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("transactionCode"))
			it.TransactionCode, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "transactionCodeNEQ":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("transactionCodeNEQ"))
			it.TransactionCodeNEQ, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "transactionCodeIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("transactionCodeIn"))
			it.TransactionCodeIn, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "transactionCodeNotIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("transactionCodeNotIn"))
			it.TransactionCodeNotIn, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "transactionCodeGT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("transactionCodeGT"))
			it.TransactionCodeGT, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "transactionCodeGTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("transactionCodeGTE"))
			it.TransactionCodeGTE, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "transactionCodeLT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("transactionCodeLT"))
			it.TransactionCodeLT, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "transactionCodeLTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("transactionCodeLTE"))
			it.TransactionCodeLTE, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "transactionCodeContains":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("transactionCodeContains"))
			it.TransactionCodeContains, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "transactionCodeHasPrefix":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("transactionCodeHasPrefix"))
			it.TransactionCodeHasPrefix, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "transactionCodeHasSuffix":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("transactionCodeHasSuffix"))
			it.TransactionCodeHasSuffix, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "transactionCodeEqualFold":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("transactionCodeEqualFold"))
			it.TransactionCodeEqualFold, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "transactionCodeContainsFold":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("transactionCodeContainsFold"))
			it.TransactionCodeContainsFold, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "createdAt":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createdAt"))
			it.CreatedAt, err = ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
		case "createdAtNEQ":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createdAtNEQ"))
			it.CreatedAtNEQ, err = ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
		case "createdAtIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createdAtIn"))
			it.CreatedAtIn, err = ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
		case "createdAtNotIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createdAtNotIn"))
			it.CreatedAtNotIn, err = ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
		case "createdAtGT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createdAtGT"))
			it.CreatedAtGT, err = ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
		case "createdAtGTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createdAtGTE"))
			it.CreatedAtGTE, err = ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
		case "createdAtLT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createdAtLT"))
			it.CreatedAtLT, err = ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
		case "createdAtLTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createdAtLTE"))
			it.CreatedAtLTE, err = ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
		case "hasInstitutionAccount":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasInstitutionAccount"))
			it.HasInstitutionAccount, err = ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
		case "hasInstitutionAccountWith":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasInstitutionAccountWith"))
			it.HasInstitutionAccountWith, err = ec.unmarshalOPlaidInstitutionAccountWhereInput2wallitentPlaidInstitutionAccountWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
		case "hasTransactionCategories":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasTransactionCategories"))
			it.HasTransactionCategories, err = ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
		case "hasTransactionCategoriesWith":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasTransactionCategoriesWith"))
			it.HasTransactionCategoriesWith, err = ec.unmarshalOSpendingCategoryWhereInput2wallitentSpendingCategoryWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputUpdateUserInput(ctx context.Context, obj interface{}) (ent.UpdateUserInput, error) {
	var it ent.UpdateUserInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"offerFrequency", "homeCountry", "clearHomeCountry", "homeState", "clearHomeState", "homeCity", "clearHomeCity"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "offerFrequency":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("offerFrequency"))
			it.OfferFrequency, err = ec.unmarshalOUserOfferFrequency2wallitentuserOfferFrequency(ctx, v)
			if err != nil {
				return it, err
			}
		case "homeCountry":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("homeCountry"))
			it.HomeCountry, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "clearHomeCountry":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("clearHomeCountry"))
			it.ClearHomeCountry, err = ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
		case "homeState":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("homeState"))
			it.HomeState, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "clearHomeState":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("clearHomeState"))
			it.ClearHomeState, err = ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
		case "homeCity":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("homeCity"))
			it.HomeCity, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "clearHomeCity":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("clearHomeCity"))
			it.ClearHomeCity, err = ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputUpdateUserNotificationChannelPreferencesInput(ctx context.Context, obj interface{}) (ent.UpdateUserNotificationChannelPreferencesInput, error) {
	var it ent.UpdateUserNotificationChannelPreferencesInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"chanel"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "chanel":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("chanel"))
			it.Chanel, err = ec.unmarshalOUserNotificationChannelPreferencesChanel2wallitentusernotificationchannelpreferencesChanel(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputUserNotificationChannelPreferencesWhereInput(ctx context.Context, obj interface{}) (ent.UserNotificationChannelPreferencesWhereInput, error) {
	var it ent.UserNotificationChannelPreferencesWhereInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"not", "and", "or", "id", "idNEQ", "idIn", "idNotIn", "idGT", "idGTE", "idLT", "idLTE", "chanel", "chanelNEQ", "chanelIn", "chanelNotIn", "hasChanelUsers", "hasChanelUsersWith"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "not":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("not"))
			it.Not, err = ec.unmarshalOUserNotificationChannelPreferencesWhereInput2wallitentUserNotificationChannelPreferencesWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
		case "and":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("and"))
			it.And, err = ec.unmarshalOUserNotificationChannelPreferencesWhereInput2wallitentUserNotificationChannelPreferencesWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
		case "or":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("or"))
			it.Or, err = ec.unmarshalOUserNotificationChannelPreferencesWhereInput2wallitentUserNotificationChannelPreferencesWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
		case "id":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
			it.ID, err = ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "idNEQ":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idNEQ"))
			it.IDNEQ, err = ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "idIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idIn"))
			it.IDIn, err = ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "idNotIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idNotIn"))
			it.IDNotIn, err = ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "idGT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idGT"))
			it.IDGT, err = ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "idGTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idGTE"))
			it.IDGTE, err = ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "idLT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idLT"))
			it.IDLT, err = ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "idLTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idLTE"))
			it.IDLTE, err = ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "chanel":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("chanel"))
			it.Chanel, err = ec.unmarshalOUserNotificationChannelPreferencesChanel2wallitentusernotificationchannelpreferencesChanel(ctx, v)
			if err != nil {
				return it, err
			}
		case "chanelNEQ":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("chanelNEQ"))
			it.ChanelNEQ, err = ec.unmarshalOUserNotificationChannelPreferencesChanel2wallitentusernotificationchannelpreferencesChanel(ctx, v)
			if err != nil {
				return it, err
			}
		case "chanelIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("chanelIn"))
			it.ChanelIn, err = ec.unmarshalOUserNotificationChannelPreferencesChanel2wallitentusernotificationchannelpreferencesChanel(ctx, v)
			if err != nil {
				return it, err
			}
		case "chanelNotIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("chanelNotIn"))
			it.ChanelNotIn, err = ec.unmarshalOUserNotificationChannelPreferencesChanel2wallitentusernotificationchannelpreferencesChanel(ctx, v)
			if err != nil {
				return it, err
			}
		case "hasChanelUsers":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasChanelUsers"))
			it.HasChanelUsers, err = ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
		case "hasChanelUsersWith":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasChanelUsersWith"))
			it.HasChanelUsersWith, err = ec.unmarshalOUserWhereInput2wallitentUserWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputUserWhereInput(ctx context.Context, obj interface{}) (ent.UserWhereInput, error) {
	var it ent.UserWhereInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"not", "and", "or", "id", "idNEQ", "idIn", "idNotIn", "idGT", "idGTE", "idLT", "idLTE", "identityProviderID", "identityProviderIDNEQ", "identityProviderIDIn", "identityProviderIDNotIn", "identityProviderIDGT", "identityProviderIDGTE", "identityProviderIDLT", "identityProviderIDLTE", "identityProviderIDContains", "identityProviderIDHasPrefix", "identityProviderIDHasSuffix", "identityProviderIDIsNil", "identityProviderIDNotNil", "identityProviderIDEqualFold", "identityProviderIDContainsFold", "offerFrequency", "offerFrequencyNEQ", "offerFrequencyIn", "offerFrequencyNotIn", "homeCountry", "homeCountryNEQ", "homeCountryIn", "homeCountryNotIn", "homeCountryGT", "homeCountryGTE", "homeCountryLT", "homeCountryLTE", "homeCountryContains", "homeCountryHasPrefix", "homeCountryHasSuffix", "homeCountryIsNil", "homeCountryNotNil", "homeCountryEqualFold", "homeCountryContainsFold", "homeState", "homeStateNEQ", "homeStateIn", "homeStateNotIn", "homeStateGT", "homeStateGTE", "homeStateLT", "homeStateLTE", "homeStateContains", "homeStateHasPrefix", "homeStateHasSuffix", "homeStateIsNil", "homeStateNotNil", "homeStateEqualFold", "homeStateContainsFold", "homeCity", "homeCityNEQ", "homeCityIn", "homeCityNotIn", "homeCityGT", "homeCityGTE", "homeCityLT", "homeCityLTE", "homeCityContains", "homeCityHasPrefix", "homeCityHasSuffix", "homeCityIsNil", "homeCityNotNil", "homeCityEqualFold", "homeCityContainsFold", "hasPlaidItems", "hasPlaidItemsWith", "hasSpendingCategories", "hasSpendingCategoriesWith", "hasNotificationChannels", "hasNotificationChannelsWith", "hasNotifications", "hasNotificationsWith", "hasAvailableDiscountOffers", "hasAvailableDiscountOffersWith"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "not":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("not"))
			it.Not, err = ec.unmarshalOUserWhereInput2wallitentUserWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
		case "and":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("and"))
			it.And, err = ec.unmarshalOUserWhereInput2wallitentUserWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
		case "or":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("or"))
			it.Or, err = ec.unmarshalOUserWhereInput2wallitentUserWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
		case "id":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
			it.ID, err = ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "idNEQ":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idNEQ"))
			it.IDNEQ, err = ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "idIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idIn"))
			it.IDIn, err = ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "idNotIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idNotIn"))
			it.IDNotIn, err = ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "idGT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idGT"))
			it.IDGT, err = ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "idGTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idGTE"))
			it.IDGTE, err = ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "idLT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idLT"))
			it.IDLT, err = ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "idLTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idLTE"))
			it.IDLTE, err = ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "identityProviderID":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("identityProviderID"))
			it.IdentityProviderID, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "identityProviderIDNEQ":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("identityProviderIDNEQ"))
			it.IdentityProviderIDNEQ, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "identityProviderIDIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("identityProviderIDIn"))
			it.IdentityProviderIDIn, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "identityProviderIDNotIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("identityProviderIDNotIn"))
			it.IdentityProviderIDNotIn, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "identityProviderIDGT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("identityProviderIDGT"))
			it.IdentityProviderIDGT, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "identityProviderIDGTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("identityProviderIDGTE"))
			it.IdentityProviderIDGTE, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "identityProviderIDLT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("identityProviderIDLT"))
			it.IdentityProviderIDLT, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "identityProviderIDLTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("identityProviderIDLTE"))
			it.IdentityProviderIDLTE, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "identityProviderIDContains":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("identityProviderIDContains"))
			it.IdentityProviderIDContains, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "identityProviderIDHasPrefix":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("identityProviderIDHasPrefix"))
			it.IdentityProviderIDHasPrefix, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "identityProviderIDHasSuffix":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("identityProviderIDHasSuffix"))
			it.IdentityProviderIDHasSuffix, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "identityProviderIDIsNil":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("identityProviderIDIsNil"))
			it.IdentityProviderIDIsNil, err = ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
		case "identityProviderIDNotNil":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("identityProviderIDNotNil"))
			it.IdentityProviderIDNotNil, err = ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
		case "identityProviderIDEqualFold":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("identityProviderIDEqualFold"))
			it.IdentityProviderIDEqualFold, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "identityProviderIDContainsFold":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("identityProviderIDContainsFold"))
			it.IdentityProviderIDContainsFold, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "offerFrequency":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("offerFrequency"))
			it.OfferFrequency, err = ec.unmarshalOUserOfferFrequency2wallitentuserOfferFrequency(ctx, v)
			if err != nil {
				return it, err
			}
		case "offerFrequencyNEQ":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("offerFrequencyNEQ"))
			it.OfferFrequencyNEQ, err = ec.unmarshalOUserOfferFrequency2wallitentuserOfferFrequency(ctx, v)
			if err != nil {
				return it, err
			}
		case "offerFrequencyIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("offerFrequencyIn"))
			it.OfferFrequencyIn, err = ec.unmarshalOUserOfferFrequency2wallitentuserOfferFrequency(ctx, v)
			if err != nil {
				return it, err
			}
		case "offerFrequencyNotIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("offerFrequencyNotIn"))
			it.OfferFrequencyNotIn, err = ec.unmarshalOUserOfferFrequency2wallitentuserOfferFrequency(ctx, v)
			if err != nil {
				return it, err
			}
		case "homeCountry":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("homeCountry"))
			it.HomeCountry, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "homeCountryNEQ":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("homeCountryNEQ"))
			it.HomeCountryNEQ, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "homeCountryIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("homeCountryIn"))
			it.HomeCountryIn, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "homeCountryNotIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("homeCountryNotIn"))
			it.HomeCountryNotIn, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "homeCountryGT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("homeCountryGT"))
			it.HomeCountryGT, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "homeCountryGTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("homeCountryGTE"))
			it.HomeCountryGTE, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "homeCountryLT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("homeCountryLT"))
			it.HomeCountryLT, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "homeCountryLTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("homeCountryLTE"))
			it.HomeCountryLTE, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "homeCountryContains":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("homeCountryContains"))
			it.HomeCountryContains, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "homeCountryHasPrefix":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("homeCountryHasPrefix"))
			it.HomeCountryHasPrefix, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "homeCountryHasSuffix":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("homeCountryHasSuffix"))
			it.HomeCountryHasSuffix, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "homeCountryIsNil":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("homeCountryIsNil"))
			it.HomeCountryIsNil, err = ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
		case "homeCountryNotNil":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("homeCountryNotNil"))
			it.HomeCountryNotNil, err = ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
		case "homeCountryEqualFold":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("homeCountryEqualFold"))
			it.HomeCountryEqualFold, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "homeCountryContainsFold":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("homeCountryContainsFold"))
			it.HomeCountryContainsFold, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "homeState":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("homeState"))
			it.HomeState, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "homeStateNEQ":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("homeStateNEQ"))
			it.HomeStateNEQ, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "homeStateIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("homeStateIn"))
			it.HomeStateIn, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "homeStateNotIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("homeStateNotIn"))
			it.HomeStateNotIn, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "homeStateGT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("homeStateGT"))
			it.HomeStateGT, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "homeStateGTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("homeStateGTE"))
			it.HomeStateGTE, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "homeStateLT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("homeStateLT"))
			it.HomeStateLT, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "homeStateLTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("homeStateLTE"))
			it.HomeStateLTE, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "homeStateContains":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("homeStateContains"))
			it.HomeStateContains, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "homeStateHasPrefix":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("homeStateHasPrefix"))
			it.HomeStateHasPrefix, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "homeStateHasSuffix":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("homeStateHasSuffix"))
			it.HomeStateHasSuffix, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "homeStateIsNil":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("homeStateIsNil"))
			it.HomeStateIsNil, err = ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
		case "homeStateNotNil":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("homeStateNotNil"))
			it.HomeStateNotNil, err = ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
		case "homeStateEqualFold":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("homeStateEqualFold"))
			it.HomeStateEqualFold, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "homeStateContainsFold":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("homeStateContainsFold"))
			it.HomeStateContainsFold, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "homeCity":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("homeCity"))
			it.HomeCity, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "homeCityNEQ":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("homeCityNEQ"))
			it.HomeCityNEQ, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "homeCityIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("homeCityIn"))
			it.HomeCityIn, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "homeCityNotIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("homeCityNotIn"))
			it.HomeCityNotIn, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "homeCityGT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("homeCityGT"))
			it.HomeCityGT, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "homeCityGTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("homeCityGTE"))
			it.HomeCityGTE, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "homeCityLT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("homeCityLT"))
			it.HomeCityLT, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "homeCityLTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("homeCityLTE"))
			it.HomeCityLTE, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "homeCityContains":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("homeCityContains"))
			it.HomeCityContains, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "homeCityHasPrefix":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("homeCityHasPrefix"))
			it.HomeCityHasPrefix, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "homeCityHasSuffix":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("homeCityHasSuffix"))
			it.HomeCityHasSuffix, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "homeCityIsNil":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("homeCityIsNil"))
			it.HomeCityIsNil, err = ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
		case "homeCityNotNil":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("homeCityNotNil"))
			it.HomeCityNotNil, err = ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
		case "homeCityEqualFold":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("homeCityEqualFold"))
			it.HomeCityEqualFold, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "homeCityContainsFold":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("homeCityContainsFold"))
			it.HomeCityContainsFold, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "hasPlaidItems":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasPlaidItems"))
			it.HasPlaidItems, err = ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
		case "hasPlaidItemsWith":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasPlaidItemsWith"))
			it.HasPlaidItemsWith, err = ec.unmarshalOPlaidItemWhereInput2wallitentPlaidItemWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
		case "hasSpendingCategories":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasSpendingCategories"))
			it.HasSpendingCategories, err = ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
		case "hasSpendingCategoriesWith":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasSpendingCategoriesWith"))
			it.HasSpendingCategoriesWith, err = ec.unmarshalOSpendingCategoryWhereInput2wallitentSpendingCategoryWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
		case "hasNotificationChannels":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasNotificationChannels"))
			it.HasNotificationChannels, err = ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
		case "hasNotificationChannelsWith":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasNotificationChannelsWith"))
			it.HasNotificationChannelsWith, err = ec.unmarshalOUserNotificationChannelPreferencesWhereInput2wallitentUserNotificationChannelPreferencesWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
		case "hasNotifications":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasNotifications"))
			it.HasNotifications, err = ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
		case "hasNotificationsWith":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasNotificationsWith"))
			it.HasNotificationsWith, err = ec.unmarshalONotificationWhereInput2wallitentNotificationWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
		case "hasAvailableDiscountOffers":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasAvailableDiscountOffers"))
			it.HasAvailableDiscountOffers, err = ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
		case "hasAvailableDiscountOffersWith":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasAvailableDiscountOffersWith"))
			it.HasAvailableDiscountOffersWith, err = ec.unmarshalODiscountOfferWhereInput2wallitentDiscountOfferWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

// endregion **************************** input.gotpl *****************************

// region    ************************** interface.gotpl ***************************

func (ec *executionContext) _Node(ctx context.Context, sel ast.SelectionSet, obj ent.Noder) graphql.Marshaler {
	switch obj := (obj).(type) {
	case nil:
		return graphql.Null
	case *ent.DiscountOffer:
		if obj == nil {
			return graphql.Null
		}
		return ec._DiscountOffer(ctx, sel, obj)
	case *ent.Merchant:
		if obj == nil {
			return graphql.Null
		}
		return ec._Merchant(ctx, sel, obj)
	case *ent.Notification:
		if obj == nil {
			return graphql.Null
		}
		return ec._Notification(ctx, sel, obj)
	case *ent.PlaidInstitution:
		if obj == nil {
			return graphql.Null
		}
		return ec._PlaidInstitution(ctx, sel, obj)
	case *ent.PlaidInstitutionAccount:
		if obj == nil {
			return graphql.Null
		}
		return ec._PlaidInstitutionAccount(ctx, sel, obj)
	case *ent.PlaidItem:
		if obj == nil {
			return graphql.Null
		}
		return ec._PlaidItem(ctx, sel, obj)
	case *ent.SpendingCategory:
		if obj == nil {
			return graphql.Null
		}
		return ec._SpendingCategory(ctx, sel, obj)
	case *ent.Transaction:
		if obj == nil {
			return graphql.Null
		}
		return ec._Transaction(ctx, sel, obj)
	case *ent.TransactionSync:
		if obj == nil {
			return graphql.Null
		}
		return ec._TransactionSync(ctx, sel, obj)
	case *ent.User:
		if obj == nil {
			return graphql.Null
		}
		return ec._User(ctx, sel, obj)
	case *ent.UserNotificationChannelPreferences:
		if obj == nil {
			return graphql.Null
		}
		return ec._UserNotificationChannelPreferences(ctx, sel, obj)
	default:
		panic(fmt.Errorf("unexpected type %T", obj))
	}
}

// endregion ************************** interface.gotpl ***************************

// region    **************************** object.gotpl ****************************

var discountOfferImplementors = []string{"DiscountOffer", "Node"}

func (ec *executionContext) _DiscountOffer(ctx context.Context, sel ast.SelectionSet, obj *ent.DiscountOffer) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, discountOfferImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("DiscountOffer")
		case "id":

			out.Values[i] = ec._DiscountOffer_id(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "amount":

			out.Values[i] = ec._DiscountOffer_amount(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "type":

			out.Values[i] = ec._DiscountOffer_type(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "currency":

			out.Values[i] = ec._DiscountOffer_currency(ctx, field, obj)

		case "description":

			out.Values[i] = ec._DiscountOffer_description(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "merchantSpecificIdentification":

			out.Values[i] = ec._DiscountOffer_merchantSpecificIdentification(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "createdAt":

			out.Values[i] = ec._DiscountOffer_createdAt(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "expiresAt":

			out.Values[i] = ec._DiscountOffer_expiresAt(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "ownerMerchant":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._DiscountOffer_ownerMerchant(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "discountEligibleUsers":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._DiscountOffer_discountEligibleUsers(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "discountOfferNotification":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._DiscountOffer_discountOfferNotification(ctx, field, obj)
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var discountOfferConnectionImplementors = []string{"DiscountOfferConnection"}

func (ec *executionContext) _DiscountOfferConnection(ctx context.Context, sel ast.SelectionSet, obj *ent.DiscountOfferConnection) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, discountOfferConnectionImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("DiscountOfferConnection")
		case "edges":

			out.Values[i] = ec._DiscountOfferConnection_edges(ctx, field, obj)

		case "pageInfo":

			out.Values[i] = ec._DiscountOfferConnection_pageInfo(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "totalCount":

			out.Values[i] = ec._DiscountOfferConnection_totalCount(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var discountOfferEdgeImplementors = []string{"DiscountOfferEdge"}

func (ec *executionContext) _DiscountOfferEdge(ctx context.Context, sel ast.SelectionSet, obj *ent.DiscountOfferEdge) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, discountOfferEdgeImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("DiscountOfferEdge")
		case "node":

			out.Values[i] = ec._DiscountOfferEdge_node(ctx, field, obj)

		case "cursor":

			out.Values[i] = ec._DiscountOfferEdge_cursor(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var institutionInfoImplementors = []string{"InstitutionInfo"}

func (ec *executionContext) _InstitutionInfo(ctx context.Context, sel ast.SelectionSet, obj *model.InstitutionInfo) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, institutionInfoImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("InstitutionInfo")
		case "institutionId":

			out.Values[i] = ec._InstitutionInfo_institutionId(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "name":

			out.Values[i] = ec._InstitutionInfo_name(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var linkTokenHostImplementors = []string{"LinkTokenHost"}

func (ec *executionContext) _LinkTokenHost(ctx context.Context, sel ast.SelectionSet, obj *model.LinkTokenHost) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, linkTokenHostImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("LinkTokenHost")
		case "linkToken":

			out.Values[i] = ec._LinkTokenHost_linkToken(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var merchantImplementors = []string{"Merchant", "Node"}

func (ec *executionContext) _Merchant(ctx context.Context, sel ast.SelectionSet, obj *ent.Merchant) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, merchantImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Merchant")
		case "id":

			out.Values[i] = ec._Merchant_id(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "name":

			out.Values[i] = ec._Merchant_name(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "discountOffers":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Merchant_discountOffers(ctx, field, obj)
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var mutationImplementors = []string{"Mutation"}

func (ec *executionContext) _Mutation(ctx context.Context, sel ast.SelectionSet) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, mutationImplementors)
	ctx = graphql.WithFieldContext(ctx, &graphql.FieldContext{
		Object: "Mutation",
	})

	out := graphql.NewFieldSet(fields)
	for i, field := range fields {
		innerCtx := graphql.WithRootFieldContext(ctx, &graphql.RootFieldContext{
			Object: field.Name,
			Field:  field,
		})

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Mutation")
		case "createLinkToken":

			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_createLinkToken(ctx, field)
			})

		case "exchangePublicToken":

			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_exchangePublicToken(ctx, field)
			})

		case "createDiscountOffer":

			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_createDiscountOffer(ctx, field)
			})

		case "createMerchant":

			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_createMerchant(ctx, field)
			})

		case "markNotificationsAsCheckedInApp":

			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_markNotificationsAsCheckedInApp(ctx, field)
			})

		case "exchangeAuthTokenForUserProfile":

			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_exchangeAuthTokenForUserProfile(ctx, field)
			})

		case "updateUser":

			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_updateUser(ctx, field)
			})

		case "setSpendingCategories":

			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_setSpendingCategories(ctx, field)
			})

		case "setNotificationChannels":

			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_setNotificationChannels(ctx, field)
			})

		case "setOfferFrequency":

			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_setOfferFrequency(ctx, field)
			})

		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	return out
}

var notificationImplementors = []string{"Notification", "Node"}

func (ec *executionContext) _Notification(ctx context.Context, sel ast.SelectionSet, obj *ent.Notification) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, notificationImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Notification")
		case "id":

			out.Values[i] = ec._Notification_id(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "checkedInApp":

			out.Values[i] = ec._Notification_checkedInApp(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "type":

			out.Values[i] = ec._Notification_type(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "createdAt":

			out.Values[i] = ec._Notification_createdAt(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "includedInAggregatedOfferAt":

			out.Values[i] = ec._Notification_includedInAggregatedOfferAt(ctx, field, obj)

		case "notificationRecipient":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Notification_notificationRecipient(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "notificationDiscountOffer":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Notification_notificationDiscountOffer(ctx, field, obj)
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var notificationConnectionImplementors = []string{"NotificationConnection"}

func (ec *executionContext) _NotificationConnection(ctx context.Context, sel ast.SelectionSet, obj *ent.NotificationConnection) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, notificationConnectionImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("NotificationConnection")
		case "edges":

			out.Values[i] = ec._NotificationConnection_edges(ctx, field, obj)

		case "pageInfo":

			out.Values[i] = ec._NotificationConnection_pageInfo(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "totalCount":

			out.Values[i] = ec._NotificationConnection_totalCount(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var notificationEdgeImplementors = []string{"NotificationEdge"}

func (ec *executionContext) _NotificationEdge(ctx context.Context, sel ast.SelectionSet, obj *ent.NotificationEdge) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, notificationEdgeImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("NotificationEdge")
		case "node":

			out.Values[i] = ec._NotificationEdge_node(ctx, field, obj)

		case "cursor":

			out.Values[i] = ec._NotificationEdge_cursor(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var pageInfoImplementors = []string{"PageInfo"}

func (ec *executionContext) _PageInfo(ctx context.Context, sel ast.SelectionSet, obj *ent.PageInfo) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, pageInfoImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("PageInfo")
		case "hasNextPage":

			out.Values[i] = ec._PageInfo_hasNextPage(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "hasPreviousPage":

			out.Values[i] = ec._PageInfo_hasPreviousPage(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "startCursor":

			out.Values[i] = ec._PageInfo_startCursor(ctx, field, obj)

		case "endCursor":

			out.Values[i] = ec._PageInfo_endCursor(ctx, field, obj)

		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var plaidAccountBalancesImplementors = []string{"PlaidAccountBalances"}

func (ec *executionContext) _PlaidAccountBalances(ctx context.Context, sel ast.SelectionSet, obj *model.PlaidAccountBalances) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, plaidAccountBalancesImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("PlaidAccountBalances")
		case "available":

			out.Values[i] = ec._PlaidAccountBalances_available(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "current":

			out.Values[i] = ec._PlaidAccountBalances_current(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "isoCurrencyCode":

			out.Values[i] = ec._PlaidAccountBalances_isoCurrencyCode(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var plaidAccountInfoImplementors = []string{"PlaidAccountInfo"}

func (ec *executionContext) _PlaidAccountInfo(ctx context.Context, sel ast.SelectionSet, obj *model.PlaidAccountInfo) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, plaidAccountInfoImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("PlaidAccountInfo")
		case "accountId":

			out.Values[i] = ec._PlaidAccountInfo_accountId(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "balances":

			out.Values[i] = ec._PlaidAccountInfo_balances(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "mask":

			out.Values[i] = ec._PlaidAccountInfo_mask(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "name":

			out.Values[i] = ec._PlaidAccountInfo_name(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "officialName":

			out.Values[i] = ec._PlaidAccountInfo_officialName(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "type":

			out.Values[i] = ec._PlaidAccountInfo_type(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "transactions":

			out.Values[i] = ec._PlaidAccountInfo_transactions(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var plaidInstitutionImplementors = []string{"PlaidInstitution", "Node"}

func (ec *executionContext) _PlaidInstitution(ctx context.Context, sel ast.SelectionSet, obj *ent.PlaidInstitution) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, plaidInstitutionImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("PlaidInstitution")
		case "id":

			out.Values[i] = ec._PlaidInstitution_id(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "institutionID":

			out.Values[i] = ec._PlaidInstitution_institutionID(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "name":

			out.Values[i] = ec._PlaidInstitution_name(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "plaidItem":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._PlaidInstitution_plaidItem(ctx, field, obj)
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "accounts":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._PlaidInstitution_accounts(ctx, field, obj)
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var plaidInstitutionAccountImplementors = []string{"PlaidInstitutionAccount", "Node"}

func (ec *executionContext) _PlaidInstitutionAccount(ctx context.Context, sel ast.SelectionSet, obj *ent.PlaidInstitutionAccount) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, plaidInstitutionAccountImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("PlaidInstitutionAccount")
		case "id":

			out.Values[i] = ec._PlaidInstitutionAccount_id(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "accountID":

			out.Values[i] = ec._PlaidInstitutionAccount_accountID(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "balanceAvailable":

			out.Values[i] = ec._PlaidInstitutionAccount_balanceAvailable(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "balanceCurrent":

			out.Values[i] = ec._PlaidInstitutionAccount_balanceCurrent(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "balanceIsoCurrencyCode":

			out.Values[i] = ec._PlaidInstitutionAccount_balanceIsoCurrencyCode(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "mask":

			out.Values[i] = ec._PlaidInstitutionAccount_mask(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "name":

			out.Values[i] = ec._PlaidInstitutionAccount_name(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "officialName":

			out.Values[i] = ec._PlaidInstitutionAccount_officialName(ctx, field, obj)

		case "type":

			out.Values[i] = ec._PlaidInstitutionAccount_type(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "parentInstitution":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._PlaidInstitutionAccount_parentInstitution(ctx, field, obj)
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "transactions":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._PlaidInstitutionAccount_transactions(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var plaidInstitutionAccountConnectionImplementors = []string{"PlaidInstitutionAccountConnection"}

func (ec *executionContext) _PlaidInstitutionAccountConnection(ctx context.Context, sel ast.SelectionSet, obj *ent.PlaidInstitutionAccountConnection) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, plaidInstitutionAccountConnectionImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("PlaidInstitutionAccountConnection")
		case "edges":

			out.Values[i] = ec._PlaidInstitutionAccountConnection_edges(ctx, field, obj)

		case "pageInfo":

			out.Values[i] = ec._PlaidInstitutionAccountConnection_pageInfo(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "totalCount":

			out.Values[i] = ec._PlaidInstitutionAccountConnection_totalCount(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var plaidInstitutionAccountEdgeImplementors = []string{"PlaidInstitutionAccountEdge"}

func (ec *executionContext) _PlaidInstitutionAccountEdge(ctx context.Context, sel ast.SelectionSet, obj *ent.PlaidInstitutionAccountEdge) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, plaidInstitutionAccountEdgeImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("PlaidInstitutionAccountEdge")
		case "node":

			out.Values[i] = ec._PlaidInstitutionAccountEdge_node(ctx, field, obj)

		case "cursor":

			out.Values[i] = ec._PlaidInstitutionAccountEdge_cursor(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var plaidInstitutionConnectionImplementors = []string{"PlaidInstitutionConnection"}

func (ec *executionContext) _PlaidInstitutionConnection(ctx context.Context, sel ast.SelectionSet, obj *ent.PlaidInstitutionConnection) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, plaidInstitutionConnectionImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("PlaidInstitutionConnection")
		case "edges":

			out.Values[i] = ec._PlaidInstitutionConnection_edges(ctx, field, obj)

		case "pageInfo":

			out.Values[i] = ec._PlaidInstitutionConnection_pageInfo(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "totalCount":

			out.Values[i] = ec._PlaidInstitutionConnection_totalCount(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var plaidInstitutionEdgeImplementors = []string{"PlaidInstitutionEdge"}

func (ec *executionContext) _PlaidInstitutionEdge(ctx context.Context, sel ast.SelectionSet, obj *ent.PlaidInstitutionEdge) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, plaidInstitutionEdgeImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("PlaidInstitutionEdge")
		case "node":

			out.Values[i] = ec._PlaidInstitutionEdge_node(ctx, field, obj)

		case "cursor":

			out.Values[i] = ec._PlaidInstitutionEdge_cursor(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var plaidItemImplementors = []string{"PlaidItem", "Node"}

func (ec *executionContext) _PlaidItem(ctx context.Context, sel ast.SelectionSet, obj *ent.PlaidItem) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, plaidItemImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("PlaidItem")
		case "id":

			out.Values[i] = ec._PlaidItem_id(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "itemID":

			out.Values[i] = ec._PlaidItem_itemID(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "accessToken":

			out.Values[i] = ec._PlaidItem_accessToken(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "createdAt":

			out.Values[i] = ec._PlaidItem_createdAt(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "updatedAt":

			out.Values[i] = ec._PlaidItem_updatedAt(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "owner":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._PlaidItem_owner(ctx, field, obj)
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "transactionSyncs":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._PlaidItem_transactionSyncs(ctx, field, obj)
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "institution":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._PlaidItem_institution(ctx, field, obj)
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var plaidItemConnectionImplementors = []string{"PlaidItemConnection"}

func (ec *executionContext) _PlaidItemConnection(ctx context.Context, sel ast.SelectionSet, obj *ent.PlaidItemConnection) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, plaidItemConnectionImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("PlaidItemConnection")
		case "edges":

			out.Values[i] = ec._PlaidItemConnection_edges(ctx, field, obj)

		case "pageInfo":

			out.Values[i] = ec._PlaidItemConnection_pageInfo(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "totalCount":

			out.Values[i] = ec._PlaidItemConnection_totalCount(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var plaidItemEdgeImplementors = []string{"PlaidItemEdge"}

func (ec *executionContext) _PlaidItemEdge(ctx context.Context, sel ast.SelectionSet, obj *ent.PlaidItemEdge) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, plaidItemEdgeImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("PlaidItemEdge")
		case "node":

			out.Values[i] = ec._PlaidItemEdge_node(ctx, field, obj)

		case "cursor":

			out.Values[i] = ec._PlaidItemEdge_cursor(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var queryImplementors = []string{"Query"}

func (ec *executionContext) _Query(ctx context.Context, sel ast.SelectionSet) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, queryImplementors)
	ctx = graphql.WithFieldContext(ctx, &graphql.FieldContext{
		Object: "Query",
	})

	out := graphql.NewFieldSet(fields)
	for i, field := range fields {
		innerCtx := graphql.WithRootFieldContext(ctx, &graphql.RootFieldContext{
			Object: field.Name,
			Field:  field,
		})

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Query")
		case "node":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_node(ctx, field)
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx, innerFunc)
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return rrm(innerCtx)
			})
		case "nodes":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_nodes(ctx, field)
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx, innerFunc)
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return rrm(innerCtx)
			})
		case "discountOffers":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_discountOffers(ctx, field)
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx, innerFunc)
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return rrm(innerCtx)
			})
		case "notifications":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_notifications(ctx, field)
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx, innerFunc)
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return rrm(innerCtx)
			})
		case "plaidItems":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_plaidItems(ctx, field)
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx, innerFunc)
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return rrm(innerCtx)
			})
		case "transactions":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_transactions(ctx, field)
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx, innerFunc)
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return rrm(innerCtx)
			})
		case "plaidInstitutionAccounts":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_plaidInstitutionAccounts(ctx, field)
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx, innerFunc)
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return rrm(innerCtx)
			})
		case "plaidInstitutions":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_plaidInstitutions(ctx, field)
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx, innerFunc)
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return rrm(innerCtx)
			})
		case "spendingCategories":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_spendingCategories(ctx, field)
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx, innerFunc)
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return rrm(innerCtx)
			})
		case "notificationChannels":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_notificationChannels(ctx, field)
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx, innerFunc)
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return rrm(innerCtx)
			})
		case "__type":

			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Query___type(ctx, field)
			})

		case "__schema":

			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Query___schema(ctx, field)
			})

		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	return out
}

var spendingCategoryImplementors = []string{"SpendingCategory", "Node"}

func (ec *executionContext) _SpendingCategory(ctx context.Context, sel ast.SelectionSet, obj *ent.SpendingCategory) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, spendingCategoryImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("SpendingCategory")
		case "id":

			out.Values[i] = ec._SpendingCategory_id(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "name":

			out.Values[i] = ec._SpendingCategory_name(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "categoryID":

			out.Values[i] = ec._SpendingCategory_categoryID(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "createdAt":

			out.Values[i] = ec._SpendingCategory_createdAt(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "categoryTransactions":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._SpendingCategory_categoryTransactions(ctx, field, obj)
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "interestedUsers":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._SpendingCategory_interestedUsers(ctx, field, obj)
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var spendingCategoryConnectionImplementors = []string{"SpendingCategoryConnection"}

func (ec *executionContext) _SpendingCategoryConnection(ctx context.Context, sel ast.SelectionSet, obj *ent.SpendingCategoryConnection) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, spendingCategoryConnectionImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("SpendingCategoryConnection")
		case "edges":

			out.Values[i] = ec._SpendingCategoryConnection_edges(ctx, field, obj)

		case "pageInfo":

			out.Values[i] = ec._SpendingCategoryConnection_pageInfo(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "totalCount":

			out.Values[i] = ec._SpendingCategoryConnection_totalCount(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var spendingCategoryEdgeImplementors = []string{"SpendingCategoryEdge"}

func (ec *executionContext) _SpendingCategoryEdge(ctx context.Context, sel ast.SelectionSet, obj *ent.SpendingCategoryEdge) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, spendingCategoryEdgeImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("SpendingCategoryEdge")
		case "node":

			out.Values[i] = ec._SpendingCategoryEdge_node(ctx, field, obj)

		case "cursor":

			out.Values[i] = ec._SpendingCategoryEdge_cursor(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var subscriptionImplementors = []string{"Subscription"}

func (ec *executionContext) _Subscription(ctx context.Context, sel ast.SelectionSet) func(ctx context.Context) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, subscriptionImplementors)
	ctx = graphql.WithFieldContext(ctx, &graphql.FieldContext{
		Object: "Subscription",
	})
	if len(fields) != 1 {
		ec.Errorf(ctx, "must subscribe to exactly one stream")
		return nil
	}

	switch fields[0].Name {
	case "notification":
		return ec._Subscription_notification(ctx, fields[0])
	default:
		panic("unknown field " + strconv.Quote(fields[0].Name))
	}
}

var transactionImplementors = []string{"Transaction", "Node"}

func (ec *executionContext) _Transaction(ctx context.Context, sel ast.SelectionSet, obj *ent.Transaction) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, transactionImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Transaction")
		case "id":

			out.Values[i] = ec._Transaction_id(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "financialAccountID":

			out.Values[i] = ec._Transaction_financialAccountID(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "amount":

			out.Values[i] = ec._Transaction_amount(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "isoCurrencyCode":

			out.Values[i] = ec._Transaction_isoCurrencyCode(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "unofficialCurrencyCode":

			out.Values[i] = ec._Transaction_unofficialCurrencyCode(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "category":

			out.Values[i] = ec._Transaction_category(ctx, field, obj)

		case "categoryID":

			out.Values[i] = ec._Transaction_categoryID(ctx, field, obj)

		case "checkNumber":

			out.Values[i] = ec._Transaction_checkNumber(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "date":

			out.Values[i] = ec._Transaction_date(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "datetime":

			out.Values[i] = ec._Transaction_datetime(ctx, field, obj)

		case "authorizedDate":

			out.Values[i] = ec._Transaction_authorizedDate(ctx, field, obj)

		case "authorizedDatetime":

			out.Values[i] = ec._Transaction_authorizedDatetime(ctx, field, obj)

		case "locationAddress":

			out.Values[i] = ec._Transaction_locationAddress(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "locationCity":

			out.Values[i] = ec._Transaction_locationCity(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "locationRegion":

			out.Values[i] = ec._Transaction_locationRegion(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "locationPostalCode":

			out.Values[i] = ec._Transaction_locationPostalCode(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "locationLat":

			out.Values[i] = ec._Transaction_locationLat(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "locationLon":

			out.Values[i] = ec._Transaction_locationLon(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "locationStoreNumber":

			out.Values[i] = ec._Transaction_locationStoreNumber(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "name":

			out.Values[i] = ec._Transaction_name(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "merchantName":

			out.Values[i] = ec._Transaction_merchantName(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "paymentChannel":

			out.Values[i] = ec._Transaction_paymentChannel(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "pending":

			out.Values[i] = ec._Transaction_pending(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "pendingTransactionID":

			out.Values[i] = ec._Transaction_pendingTransactionID(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "accountOwner":

			out.Values[i] = ec._Transaction_accountOwner(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "transactionID":

			out.Values[i] = ec._Transaction_transactionID(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "transactionCode":

			out.Values[i] = ec._Transaction_transactionCode(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "createdAt":

			out.Values[i] = ec._Transaction_createdAt(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "institutionAccount":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Transaction_institutionAccount(ctx, field, obj)
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "transactionCategories":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Transaction_transactionCategories(ctx, field, obj)
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var transactionConnectionImplementors = []string{"TransactionConnection"}

func (ec *executionContext) _TransactionConnection(ctx context.Context, sel ast.SelectionSet, obj *ent.TransactionConnection) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, transactionConnectionImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("TransactionConnection")
		case "edges":

			out.Values[i] = ec._TransactionConnection_edges(ctx, field, obj)

		case "pageInfo":

			out.Values[i] = ec._TransactionConnection_pageInfo(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "totalCount":

			out.Values[i] = ec._TransactionConnection_totalCount(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var transactionEdgeImplementors = []string{"TransactionEdge"}

func (ec *executionContext) _TransactionEdge(ctx context.Context, sel ast.SelectionSet, obj *ent.TransactionEdge) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, transactionEdgeImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("TransactionEdge")
		case "node":

			out.Values[i] = ec._TransactionEdge_node(ctx, field, obj)

		case "cursor":

			out.Values[i] = ec._TransactionEdge_cursor(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var transactionSyncImplementors = []string{"TransactionSync", "Node"}

func (ec *executionContext) _TransactionSync(ctx context.Context, sel ast.SelectionSet, obj *ent.TransactionSync) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, transactionSyncImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("TransactionSync")
		case "id":

			out.Values[i] = ec._TransactionSync_id(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "createdAt":

			out.Values[i] = ec._TransactionSync_createdAt(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "cursor":

			out.Values[i] = ec._TransactionSync_cursor(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "item":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._TransactionSync_item(ctx, field, obj)
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var userImplementors = []string{"User", "Node"}

func (ec *executionContext) _User(ctx context.Context, sel ast.SelectionSet, obj *ent.User) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, userImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("User")
		case "id":

			out.Values[i] = ec._User_id(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "identityProviderID":

			out.Values[i] = ec._User_identityProviderID(ctx, field, obj)

		case "offerFrequency":

			out.Values[i] = ec._User_offerFrequency(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "homeCountry":

			out.Values[i] = ec._User_homeCountry(ctx, field, obj)

		case "homeState":

			out.Values[i] = ec._User_homeState(ctx, field, obj)

		case "homeCity":

			out.Values[i] = ec._User_homeCity(ctx, field, obj)

		case "plaidItems":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._User_plaidItems(ctx, field, obj)
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "spendingCategories":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._User_spendingCategories(ctx, field, obj)
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "notificationChannels":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._User_notificationChannels(ctx, field, obj)
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "notifications":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._User_notifications(ctx, field, obj)
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "availableDiscountOffers":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._User_availableDiscountOffers(ctx, field, obj)
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var userNotificationChannelPreferencesImplementors = []string{"UserNotificationChannelPreferences", "Node"}

func (ec *executionContext) _UserNotificationChannelPreferences(ctx context.Context, sel ast.SelectionSet, obj *ent.UserNotificationChannelPreferences) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, userNotificationChannelPreferencesImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("UserNotificationChannelPreferences")
		case "id":

			out.Values[i] = ec._UserNotificationChannelPreferences_id(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "chanel":

			out.Values[i] = ec._UserNotificationChannelPreferences_chanel(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "chanelUsers":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._UserNotificationChannelPreferences_chanelUsers(ctx, field, obj)
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var userNotificationChannelPreferencesConnectionImplementors = []string{"UserNotificationChannelPreferencesConnection"}

func (ec *executionContext) _UserNotificationChannelPreferencesConnection(ctx context.Context, sel ast.SelectionSet, obj *ent.UserNotificationChannelPreferencesConnection) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, userNotificationChannelPreferencesConnectionImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("UserNotificationChannelPreferencesConnection")
		case "edges":

			out.Values[i] = ec._UserNotificationChannelPreferencesConnection_edges(ctx, field, obj)

		case "pageInfo":

			out.Values[i] = ec._UserNotificationChannelPreferencesConnection_pageInfo(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "totalCount":

			out.Values[i] = ec._UserNotificationChannelPreferencesConnection_totalCount(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var userNotificationChannelPreferencesEdgeImplementors = []string{"UserNotificationChannelPreferencesEdge"}

func (ec *executionContext) _UserNotificationChannelPreferencesEdge(ctx context.Context, sel ast.SelectionSet, obj *ent.UserNotificationChannelPreferencesEdge) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, userNotificationChannelPreferencesEdgeImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("UserNotificationChannelPreferencesEdge")
		case "node":

			out.Values[i] = ec._UserNotificationChannelPreferencesEdge_node(ctx, field, obj)

		case "cursor":

			out.Values[i] = ec._UserNotificationChannelPreferencesEdge_cursor(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var __DirectiveImplementors = []string{"__Directive"}

func (ec *executionContext) ___Directive(ctx context.Context, sel ast.SelectionSet, obj *introspection.Directive) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, __DirectiveImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__Directive")
		case "name":

			out.Values[i] = ec.___Directive_name(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "description":

			out.Values[i] = ec.___Directive_description(ctx, field, obj)

		case "locations":

			out.Values[i] = ec.___Directive_locations(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "args":

			out.Values[i] = ec.___Directive_args(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "isRepeatable":

			out.Values[i] = ec.___Directive_isRepeatable(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var __EnumValueImplementors = []string{"__EnumValue"}

func (ec *executionContext) ___EnumValue(ctx context.Context, sel ast.SelectionSet, obj *introspection.EnumValue) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, __EnumValueImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__EnumValue")
		case "name":

			out.Values[i] = ec.___EnumValue_name(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "description":

			out.Values[i] = ec.___EnumValue_description(ctx, field, obj)

		case "isDeprecated":

			out.Values[i] = ec.___EnumValue_isDeprecated(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "deprecationReason":

			out.Values[i] = ec.___EnumValue_deprecationReason(ctx, field, obj)

		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var __FieldImplementors = []string{"__Field"}

func (ec *executionContext) ___Field(ctx context.Context, sel ast.SelectionSet, obj *introspection.Field) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, __FieldImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__Field")
		case "name":

			out.Values[i] = ec.___Field_name(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "description":

			out.Values[i] = ec.___Field_description(ctx, field, obj)

		case "args":

			out.Values[i] = ec.___Field_args(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "type":

			out.Values[i] = ec.___Field_type(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "isDeprecated":

			out.Values[i] = ec.___Field_isDeprecated(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "deprecationReason":

			out.Values[i] = ec.___Field_deprecationReason(ctx, field, obj)

		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var __InputValueImplementors = []string{"__InputValue"}

func (ec *executionContext) ___InputValue(ctx context.Context, sel ast.SelectionSet, obj *introspection.InputValue) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, __InputValueImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__InputValue")
		case "name":

			out.Values[i] = ec.___InputValue_name(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "description":

			out.Values[i] = ec.___InputValue_description(ctx, field, obj)

		case "type":

			out.Values[i] = ec.___InputValue_type(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "defaultValue":

			out.Values[i] = ec.___InputValue_defaultValue(ctx, field, obj)

		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var __SchemaImplementors = []string{"__Schema"}

func (ec *executionContext) ___Schema(ctx context.Context, sel ast.SelectionSet, obj *introspection.Schema) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, __SchemaImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__Schema")
		case "description":

			out.Values[i] = ec.___Schema_description(ctx, field, obj)

		case "types":

			out.Values[i] = ec.___Schema_types(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "queryType":

			out.Values[i] = ec.___Schema_queryType(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "mutationType":

			out.Values[i] = ec.___Schema_mutationType(ctx, field, obj)

		case "subscriptionType":

			out.Values[i] = ec.___Schema_subscriptionType(ctx, field, obj)

		case "directives":

			out.Values[i] = ec.___Schema_directives(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var __TypeImplementors = []string{"__Type"}

func (ec *executionContext) ___Type(ctx context.Context, sel ast.SelectionSet, obj *introspection.Type) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, __TypeImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__Type")
		case "kind":

			out.Values[i] = ec.___Type_kind(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "name":

			out.Values[i] = ec.___Type_name(ctx, field, obj)

		case "description":

			out.Values[i] = ec.___Type_description(ctx, field, obj)

		case "fields":

			out.Values[i] = ec.___Type_fields(ctx, field, obj)

		case "interfaces":

			out.Values[i] = ec.___Type_interfaces(ctx, field, obj)

		case "possibleTypes":

			out.Values[i] = ec.___Type_possibleTypes(ctx, field, obj)

		case "enumValues":

			out.Values[i] = ec.___Type_enumValues(ctx, field, obj)

		case "inputFields":

			out.Values[i] = ec.___Type_inputFields(ctx, field, obj)

		case "ofType":

			out.Values[i] = ec.___Type_ofType(ctx, field, obj)

		case "specifiedByURL":

			out.Values[i] = ec.___Type_specifiedByURL(ctx, field, obj)

		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

// endregion **************************** object.gotpl ****************************

// region    ***************************** type.gotpl *****************************

func (ec *executionContext) unmarshalNBoolean2bool(ctx context.Context, v interface{}) (bool, error) {
	res, err := graphql.UnmarshalBoolean(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNBoolean2bool(ctx context.Context, sel ast.SelectionSet, v bool) graphql.Marshaler {
	res := graphql.MarshalBoolean(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) unmarshalNCreateDiscountOfferInput2wallitentCreateDiscountOfferInput(ctx context.Context, v interface{}) (ent.CreateDiscountOfferInput, error) {
	res, err := ec.unmarshalInputCreateDiscountOfferInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNCreateLinkTokenParams2wallitgraphmodelCreateLinkTokenParams(ctx context.Context, v interface{}) (model.CreateLinkTokenParams, error) {
	res, err := ec.unmarshalInputCreateLinkTokenParams(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNCreateMerchantInput2wallitentCreateMerchantInput(ctx context.Context, v interface{}) (ent.CreateMerchantInput, error) {
	res, err := ec.unmarshalInputCreateMerchantInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNCursor2wallitentCursor(ctx context.Context, v interface{}) (ent.Cursor, error) {
	var res ent.Cursor
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNCursor2wallitentCursor(ctx context.Context, sel ast.SelectionSet, v ent.Cursor) graphql.Marshaler {
	return v
}

func (ec *executionContext) marshalNDiscountOffer2wallitentDiscountOffer(ctx context.Context, sel ast.SelectionSet, v ent.DiscountOffer) graphql.Marshaler {
	return ec._DiscountOffer(ctx, sel, &v)
}

func (ec *executionContext) marshalNDiscountOffer2wallitentDiscountOffer(ctx context.Context, sel ast.SelectionSet, v *ent.DiscountOffer) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._DiscountOffer(ctx, sel, v)
}

func (ec *executionContext) marshalNDiscountOfferConnection2wallitentDiscountOfferConnection(ctx context.Context, sel ast.SelectionSet, v ent.DiscountOfferConnection) graphql.Marshaler {
	return ec._DiscountOfferConnection(ctx, sel, &v)
}

func (ec *executionContext) marshalNDiscountOfferConnection2wallitentDiscountOfferConnection(ctx context.Context, sel ast.SelectionSet, v *ent.DiscountOfferConnection) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._DiscountOfferConnection(ctx, sel, v)
}

func (ec *executionContext) unmarshalNDiscountOfferOrderField2wallitentDiscountOfferOrderField(ctx context.Context, v interface{}) (*ent.DiscountOfferOrderField, error) {
	var res = new(ent.DiscountOfferOrderField)
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNDiscountOfferOrderField2wallitentDiscountOfferOrderField(ctx context.Context, sel ast.SelectionSet, v *ent.DiscountOfferOrderField) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return v
}

func (ec *executionContext) unmarshalNDiscountOfferType2wallitentdiscountofferType(ctx context.Context, v interface{}) (discountoffer.Type, error) {
	var res discountoffer.Type
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNDiscountOfferType2wallitentdiscountofferType(ctx context.Context, sel ast.SelectionSet, v discountoffer.Type) graphql.Marshaler {
	return v
}

func (ec *executionContext) unmarshalNDiscountOfferWhereInput2wallitentDiscountOfferWhereInput(ctx context.Context, v interface{}) (*ent.DiscountOfferWhereInput, error) {
	res, err := ec.unmarshalInputDiscountOfferWhereInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNExchangeAuthTokenForUserProfileInput2wallitgraphmodelExchangeAuthTokenForUserProfileInput(ctx context.Context, v interface{}) (model.ExchangeAuthTokenForUserProfileInput, error) {
	res, err := ec.unmarshalInputExchangeAuthTokenForUserProfileInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNExchangePublicTokenParams2wallitgraphmodelExchangePublicTokenParams(ctx context.Context, v interface{}) (model.ExchangePublicTokenParams, error) {
	res, err := ec.unmarshalInputExchangePublicTokenParams(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNFloat2float64(ctx context.Context, v interface{}) (float64, error) {
	res, err := graphql.UnmarshalFloatContext(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNFloat2float64(ctx context.Context, sel ast.SelectionSet, v float64) graphql.Marshaler {
	res := graphql.MarshalFloatContext(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return graphql.WrapContextMarshaler(ctx, res)
}

func (ec *executionContext) unmarshalNID2int(ctx context.Context, v interface{}) (int, error) {
	res, err := graphql.UnmarshalIntID(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNID2int(ctx context.Context, sel ast.SelectionSet, v int) graphql.Marshaler {
	res := graphql.MarshalIntID(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) unmarshalNID2int(ctx context.Context, v interface{}) ([]int, error) {
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]int, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNID2int(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalNID2int(ctx context.Context, sel ast.SelectionSet, v []int) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	for i := range v {
		ret[i] = ec.marshalNID2int(ctx, sel, v[i])
	}

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalNInt2int(ctx context.Context, v interface{}) (int, error) {
	res, err := graphql.UnmarshalInt(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNInt2int(ctx context.Context, sel ast.SelectionSet, v int) graphql.Marshaler {
	res := graphql.MarshalInt(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) marshalNLinkTokenHost2wallitgraphmodelLinkTokenHost(ctx context.Context, sel ast.SelectionSet, v model.LinkTokenHost) graphql.Marshaler {
	return ec._LinkTokenHost(ctx, sel, &v)
}

func (ec *executionContext) marshalNLinkTokenHost2wallitgraphmodelLinkTokenHost(ctx context.Context, sel ast.SelectionSet, v *model.LinkTokenHost) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._LinkTokenHost(ctx, sel, v)
}

func (ec *executionContext) marshalNMerchant2wallitentMerchant(ctx context.Context, sel ast.SelectionSet, v ent.Merchant) graphql.Marshaler {
	return ec._Merchant(ctx, sel, &v)
}

func (ec *executionContext) marshalNMerchant2wallitentMerchant(ctx context.Context, sel ast.SelectionSet, v *ent.Merchant) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._Merchant(ctx, sel, v)
}

func (ec *executionContext) unmarshalNMerchantWhereInput2wallitentMerchantWhereInput(ctx context.Context, v interface{}) (*ent.MerchantWhereInput, error) {
	res, err := ec.unmarshalInputMerchantWhereInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNNode2wallitentNoder(ctx context.Context, sel ast.SelectionSet, v []ent.Noder) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalONode2wallitentNoder(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	return ret
}

func (ec *executionContext) marshalNNotification2wallitentNotification(ctx context.Context, sel ast.SelectionSet, v ent.Notification) graphql.Marshaler {
	return ec._Notification(ctx, sel, &v)
}

func (ec *executionContext) marshalNNotification2wallitentNotification(ctx context.Context, sel ast.SelectionSet, v *ent.Notification) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._Notification(ctx, sel, v)
}

func (ec *executionContext) marshalNNotificationConnection2wallitentNotificationConnection(ctx context.Context, sel ast.SelectionSet, v ent.NotificationConnection) graphql.Marshaler {
	return ec._NotificationConnection(ctx, sel, &v)
}

func (ec *executionContext) marshalNNotificationConnection2wallitentNotificationConnection(ctx context.Context, sel ast.SelectionSet, v *ent.NotificationConnection) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._NotificationConnection(ctx, sel, v)
}

func (ec *executionContext) unmarshalNNotificationOrderField2wallitentNotificationOrderField(ctx context.Context, v interface{}) (*ent.NotificationOrderField, error) {
	var res = new(ent.NotificationOrderField)
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNNotificationOrderField2wallitentNotificationOrderField(ctx context.Context, sel ast.SelectionSet, v *ent.NotificationOrderField) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return v
}

func (ec *executionContext) unmarshalNNotificationType2wallitentnotificationType(ctx context.Context, v interface{}) (notification.Type, error) {
	var res notification.Type
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNNotificationType2wallitentnotificationType(ctx context.Context, sel ast.SelectionSet, v notification.Type) graphql.Marshaler {
	return v
}

func (ec *executionContext) unmarshalNNotificationWhereInput2wallitentNotificationWhereInput(ctx context.Context, v interface{}) (*ent.NotificationWhereInput, error) {
	res, err := ec.unmarshalInputNotificationWhereInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNOrderDirection2wallitentOrderDirection(ctx context.Context, v interface{}) (ent.OrderDirection, error) {
	var res ent.OrderDirection
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNOrderDirection2wallitentOrderDirection(ctx context.Context, sel ast.SelectionSet, v ent.OrderDirection) graphql.Marshaler {
	return v
}

func (ec *executionContext) marshalNPageInfo2wallitentPageInfo(ctx context.Context, sel ast.SelectionSet, v ent.PageInfo) graphql.Marshaler {
	return ec._PageInfo(ctx, sel, &v)
}

func (ec *executionContext) marshalNPlaidAccountBalances2wallitgraphmodelPlaidAccountBalances(ctx context.Context, sel ast.SelectionSet, v *model.PlaidAccountBalances) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._PlaidAccountBalances(ctx, sel, v)
}

func (ec *executionContext) marshalNPlaidInstitutionAccount2wallitentPlaidInstitutionAccount(ctx context.Context, sel ast.SelectionSet, v *ent.PlaidInstitutionAccount) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._PlaidInstitutionAccount(ctx, sel, v)
}

func (ec *executionContext) unmarshalNPlaidInstitutionAccountWhereInput2wallitentPlaidInstitutionAccountWhereInput(ctx context.Context, v interface{}) (*ent.PlaidInstitutionAccountWhereInput, error) {
	res, err := ec.unmarshalInputPlaidInstitutionAccountWhereInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNPlaidInstitutionWhereInput2wallitentPlaidInstitutionWhereInput(ctx context.Context, v interface{}) (*ent.PlaidInstitutionWhereInput, error) {
	res, err := ec.unmarshalInputPlaidInstitutionWhereInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNPlaidItem2wallitentPlaidItem(ctx context.Context, sel ast.SelectionSet, v *ent.PlaidItem) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._PlaidItem(ctx, sel, v)
}

func (ec *executionContext) marshalNPlaidItemConnection2wallitentPlaidItemConnection(ctx context.Context, sel ast.SelectionSet, v ent.PlaidItemConnection) graphql.Marshaler {
	return ec._PlaidItemConnection(ctx, sel, &v)
}

func (ec *executionContext) marshalNPlaidItemConnection2wallitentPlaidItemConnection(ctx context.Context, sel ast.SelectionSet, v *ent.PlaidItemConnection) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._PlaidItemConnection(ctx, sel, v)
}

func (ec *executionContext) unmarshalNPlaidItemOrderField2wallitentPlaidItemOrderField(ctx context.Context, v interface{}) (*ent.PlaidItemOrderField, error) {
	var res = new(ent.PlaidItemOrderField)
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNPlaidItemOrderField2wallitentPlaidItemOrderField(ctx context.Context, sel ast.SelectionSet, v *ent.PlaidItemOrderField) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return v
}

func (ec *executionContext) unmarshalNPlaidItemWhereInput2wallitentPlaidItemWhereInput(ctx context.Context, v interface{}) (*ent.PlaidItemWhereInput, error) {
	res, err := ec.unmarshalInputPlaidItemWhereInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNSpendingCategory2wallitentSpendingCategory(ctx context.Context, sel ast.SelectionSet, v *ent.SpendingCategory) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._SpendingCategory(ctx, sel, v)
}

func (ec *executionContext) marshalNSpendingCategoryConnection2wallitentSpendingCategoryConnection(ctx context.Context, sel ast.SelectionSet, v ent.SpendingCategoryConnection) graphql.Marshaler {
	return ec._SpendingCategoryConnection(ctx, sel, &v)
}

func (ec *executionContext) marshalNSpendingCategoryConnection2wallitentSpendingCategoryConnection(ctx context.Context, sel ast.SelectionSet, v *ent.SpendingCategoryConnection) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._SpendingCategoryConnection(ctx, sel, v)
}

func (ec *executionContext) unmarshalNSpendingCategoryWhereInput2wallitentSpendingCategoryWhereInput(ctx context.Context, v interface{}) (*ent.SpendingCategoryWhereInput, error) {
	res, err := ec.unmarshalInputSpendingCategoryWhereInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNString2string(ctx context.Context, v interface{}) (string, error) {
	res, err := graphql.UnmarshalString(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNString2string(ctx context.Context, sel ast.SelectionSet, v string) graphql.Marshaler {
	res := graphql.MarshalString(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) unmarshalNString2string(ctx context.Context, v interface{}) (*string, error) {
	res, err := graphql.UnmarshalString(v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNString2string(ctx context.Context, sel ast.SelectionSet, v *string) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	res := graphql.MarshalString(*v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) unmarshalNTime2timeTime(ctx context.Context, v interface{}) (time.Time, error) {
	res, err := graphql.UnmarshalTime(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNTime2timeTime(ctx context.Context, sel ast.SelectionSet, v time.Time) graphql.Marshaler {
	res := graphql.MarshalTime(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) marshalNTransaction2wallitentTransaction(ctx context.Context, sel ast.SelectionSet, v *ent.Transaction) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._Transaction(ctx, sel, v)
}

func (ec *executionContext) marshalNTransactionConnection2wallitentTransactionConnection(ctx context.Context, sel ast.SelectionSet, v ent.TransactionConnection) graphql.Marshaler {
	return ec._TransactionConnection(ctx, sel, &v)
}

func (ec *executionContext) marshalNTransactionConnection2wallitentTransactionConnection(ctx context.Context, sel ast.SelectionSet, v *ent.TransactionConnection) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._TransactionConnection(ctx, sel, v)
}

func (ec *executionContext) unmarshalNTransactionOrderField2wallitentTransactionOrderField(ctx context.Context, v interface{}) (*ent.TransactionOrderField, error) {
	var res = new(ent.TransactionOrderField)
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNTransactionOrderField2wallitentTransactionOrderField(ctx context.Context, sel ast.SelectionSet, v *ent.TransactionOrderField) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return v
}

func (ec *executionContext) marshalNTransactionSync2wallitentTransactionSync(ctx context.Context, sel ast.SelectionSet, v *ent.TransactionSync) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._TransactionSync(ctx, sel, v)
}

func (ec *executionContext) unmarshalNTransactionSyncWhereInput2wallitentTransactionSyncWhereInput(ctx context.Context, v interface{}) (*ent.TransactionSyncWhereInput, error) {
	res, err := ec.unmarshalInputTransactionSyncWhereInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNTransactionWhereInput2wallitentTransactionWhereInput(ctx context.Context, v interface{}) (*ent.TransactionWhereInput, error) {
	res, err := ec.unmarshalInputTransactionWhereInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNUser2wallitentUser(ctx context.Context, sel ast.SelectionSet, v ent.User) graphql.Marshaler {
	return ec._User(ctx, sel, &v)
}

func (ec *executionContext) marshalNUser2wallitentUser(ctx context.Context, sel ast.SelectionSet, v []*ent.User) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNUser2wallitentUser(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNUser2wallitentUser(ctx context.Context, sel ast.SelectionSet, v *ent.User) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._User(ctx, sel, v)
}

func (ec *executionContext) marshalNUserNotificationChannelPreferences2wallitentUserNotificationChannelPreferences(ctx context.Context, sel ast.SelectionSet, v *ent.UserNotificationChannelPreferences) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._UserNotificationChannelPreferences(ctx, sel, v)
}

func (ec *executionContext) unmarshalNUserNotificationChannelPreferencesChanel2wallitentusernotificationchannelpreferencesChanel(ctx context.Context, v interface{}) (usernotificationchannelpreferences.Chanel, error) {
	var res usernotificationchannelpreferences.Chanel
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNUserNotificationChannelPreferencesChanel2wallitentusernotificationchannelpreferencesChanel(ctx context.Context, sel ast.SelectionSet, v usernotificationchannelpreferences.Chanel) graphql.Marshaler {
	return v
}

func (ec *executionContext) unmarshalNUserNotificationChannelPreferencesChanel2wallitentusernotificationchannelpreferencesChanel(ctx context.Context, v interface{}) ([]usernotificationchannelpreferences.Chanel, error) {
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]usernotificationchannelpreferences.Chanel, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNUserNotificationChannelPreferencesChanel2wallitentusernotificationchannelpreferencesChanel(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalNUserNotificationChannelPreferencesChanel2wallitentusernotificationchannelpreferencesChanel(ctx context.Context, sel ast.SelectionSet, v []usernotificationchannelpreferences.Chanel) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNUserNotificationChannelPreferencesChanel2wallitentusernotificationchannelpreferencesChanel(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNUserNotificationChannelPreferencesConnection2wallitentUserNotificationChannelPreferencesConnection(ctx context.Context, sel ast.SelectionSet, v ent.UserNotificationChannelPreferencesConnection) graphql.Marshaler {
	return ec._UserNotificationChannelPreferencesConnection(ctx, sel, &v)
}

func (ec *executionContext) marshalNUserNotificationChannelPreferencesConnection2wallitentUserNotificationChannelPreferencesConnection(ctx context.Context, sel ast.SelectionSet, v *ent.UserNotificationChannelPreferencesConnection) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._UserNotificationChannelPreferencesConnection(ctx, sel, v)
}

func (ec *executionContext) unmarshalNUserNotificationChannelPreferencesWhereInput2wallitentUserNotificationChannelPreferencesWhereInput(ctx context.Context, v interface{}) (*ent.UserNotificationChannelPreferencesWhereInput, error) {
	res, err := ec.unmarshalInputUserNotificationChannelPreferencesWhereInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNUserOfferFrequency2wallitentuserOfferFrequency(ctx context.Context, v interface{}) (user.OfferFrequency, error) {
	var res user.OfferFrequency
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNUserOfferFrequency2wallitentuserOfferFrequency(ctx context.Context, sel ast.SelectionSet, v user.OfferFrequency) graphql.Marshaler {
	return v
}

func (ec *executionContext) unmarshalNUserWhereInput2wallitentUserWhereInput(ctx context.Context, v interface{}) (*ent.UserWhereInput, error) {
	res, err := ec.unmarshalInputUserWhereInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalN__Directive2githubcom99designsgqlgengraphqlintrospectionDirective(ctx context.Context, sel ast.SelectionSet, v introspection.Directive) graphql.Marshaler {
	return ec.___Directive(ctx, sel, &v)
}

func (ec *executionContext) marshalN__Directive2githubcom99designsgqlgengraphqlintrospectionDirective(ctx context.Context, sel ast.SelectionSet, v []introspection.Directive) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__Directive2githubcom99designsgqlgengraphqlintrospectionDirective(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalN__DirectiveLocation2string(ctx context.Context, v interface{}) (string, error) {
	res, err := graphql.UnmarshalString(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalN__DirectiveLocation2string(ctx context.Context, sel ast.SelectionSet, v string) graphql.Marshaler {
	res := graphql.MarshalString(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) unmarshalN__DirectiveLocation2string(ctx context.Context, v interface{}) ([]string, error) {
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]string, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalN__DirectiveLocation2string(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalN__DirectiveLocation2string(ctx context.Context, sel ast.SelectionSet, v []string) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__DirectiveLocation2string(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalN__EnumValue2githubcom99designsgqlgengraphqlintrospectionEnumValue(ctx context.Context, sel ast.SelectionSet, v introspection.EnumValue) graphql.Marshaler {
	return ec.___EnumValue(ctx, sel, &v)
}

func (ec *executionContext) marshalN__Field2githubcom99designsgqlgengraphqlintrospectionField(ctx context.Context, sel ast.SelectionSet, v introspection.Field) graphql.Marshaler {
	return ec.___Field(ctx, sel, &v)
}

func (ec *executionContext) marshalN__InputValue2githubcom99designsgqlgengraphqlintrospectionInputValue(ctx context.Context, sel ast.SelectionSet, v introspection.InputValue) graphql.Marshaler {
	return ec.___InputValue(ctx, sel, &v)
}

func (ec *executionContext) marshalN__InputValue2githubcom99designsgqlgengraphqlintrospectionInputValue(ctx context.Context, sel ast.SelectionSet, v []introspection.InputValue) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__InputValue2githubcom99designsgqlgengraphqlintrospectionInputValue(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalN__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx context.Context, sel ast.SelectionSet, v introspection.Type) graphql.Marshaler {
	return ec.___Type(ctx, sel, &v)
}

func (ec *executionContext) marshalN__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx context.Context, sel ast.SelectionSet, v []introspection.Type) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalN__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx context.Context, sel ast.SelectionSet, v *introspection.Type) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec.___Type(ctx, sel, v)
}

func (ec *executionContext) unmarshalN__TypeKind2string(ctx context.Context, v interface{}) (string, error) {
	res, err := graphql.UnmarshalString(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalN__TypeKind2string(ctx context.Context, sel ast.SelectionSet, v string) graphql.Marshaler {
	res := graphql.MarshalString(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) unmarshalOBoolean2bool(ctx context.Context, v interface{}) (bool, error) {
	res, err := graphql.UnmarshalBoolean(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOBoolean2bool(ctx context.Context, sel ast.SelectionSet, v bool) graphql.Marshaler {
	res := graphql.MarshalBoolean(v)
	return res
}

func (ec *executionContext) unmarshalOBoolean2bool(ctx context.Context, v interface{}) (*bool, error) {
	if v == nil {
		return nil, nil
	}
	res, err := graphql.UnmarshalBoolean(v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOBoolean2bool(ctx context.Context, sel ast.SelectionSet, v *bool) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	res := graphql.MarshalBoolean(*v)
	return res
}

func (ec *executionContext) unmarshalOCursor2wallitentCursor(ctx context.Context, v interface{}) (*ent.Cursor, error) {
	if v == nil {
		return nil, nil
	}
	var res = new(ent.Cursor)
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOCursor2wallitentCursor(ctx context.Context, sel ast.SelectionSet, v *ent.Cursor) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return v
}

func (ec *executionContext) marshalODiscountOffer2wallitentDiscountOffer(ctx context.Context, sel ast.SelectionSet, v []*ent.DiscountOffer) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNDiscountOffer2wallitentDiscountOffer(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalODiscountOffer2wallitentDiscountOffer(ctx context.Context, sel ast.SelectionSet, v *ent.DiscountOffer) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._DiscountOffer(ctx, sel, v)
}

func (ec *executionContext) marshalODiscountOfferEdge2wallitentDiscountOfferEdge(ctx context.Context, sel ast.SelectionSet, v []*ent.DiscountOfferEdge) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalODiscountOfferEdge2wallitentDiscountOfferEdge(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	return ret
}

func (ec *executionContext) marshalODiscountOfferEdge2wallitentDiscountOfferEdge(ctx context.Context, sel ast.SelectionSet, v *ent.DiscountOfferEdge) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._DiscountOfferEdge(ctx, sel, v)
}

func (ec *executionContext) unmarshalODiscountOfferOrder2wallitentDiscountOfferOrder(ctx context.Context, v interface{}) (*ent.DiscountOfferOrder, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputDiscountOfferOrder(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalODiscountOfferType2wallitentdiscountofferType(ctx context.Context, v interface{}) ([]discountoffer.Type, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]discountoffer.Type, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNDiscountOfferType2wallitentdiscountofferType(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalODiscountOfferType2wallitentdiscountofferType(ctx context.Context, sel ast.SelectionSet, v []discountoffer.Type) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNDiscountOfferType2wallitentdiscountofferType(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalODiscountOfferType2wallitentdiscountofferType(ctx context.Context, v interface{}) (*discountoffer.Type, error) {
	if v == nil {
		return nil, nil
	}
	var res = new(discountoffer.Type)
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalODiscountOfferType2wallitentdiscountofferType(ctx context.Context, sel ast.SelectionSet, v *discountoffer.Type) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return v
}

func (ec *executionContext) unmarshalODiscountOfferWhereInput2wallitentDiscountOfferWhereInput(ctx context.Context, v interface{}) ([]*ent.DiscountOfferWhereInput, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]*ent.DiscountOfferWhereInput, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNDiscountOfferWhereInput2wallitentDiscountOfferWhereInput(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) unmarshalODiscountOfferWhereInput2wallitentDiscountOfferWhereInput(ctx context.Context, v interface{}) (*ent.DiscountOfferWhereInput, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputDiscountOfferWhereInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalOFloat2float64(ctx context.Context, v interface{}) ([]float64, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]float64, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNFloat2float64(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalOFloat2float64(ctx context.Context, sel ast.SelectionSet, v []float64) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	for i := range v {
		ret[i] = ec.marshalNFloat2float64(ctx, sel, v[i])
	}

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalOFloat2float64(ctx context.Context, v interface{}) (*float64, error) {
	if v == nil {
		return nil, nil
	}
	res, err := graphql.UnmarshalFloatContext(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOFloat2float64(ctx context.Context, sel ast.SelectionSet, v *float64) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	res := graphql.MarshalFloatContext(*v)
	return graphql.WrapContextMarshaler(ctx, res)
}

func (ec *executionContext) unmarshalOID2int(ctx context.Context, v interface{}) ([]int, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]int, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNID2int(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalOID2int(ctx context.Context, sel ast.SelectionSet, v []int) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	for i := range v {
		ret[i] = ec.marshalNID2int(ctx, sel, v[i])
	}

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalOID2int(ctx context.Context, v interface{}) (*int, error) {
	if v == nil {
		return nil, nil
	}
	res, err := graphql.UnmarshalIntID(v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOID2int(ctx context.Context, sel ast.SelectionSet, v *int) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	res := graphql.MarshalIntID(*v)
	return res
}

func (ec *executionContext) unmarshalOInt2int(ctx context.Context, v interface{}) ([]int, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]int, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNInt2int(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalOInt2int(ctx context.Context, sel ast.SelectionSet, v []int) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	for i := range v {
		ret[i] = ec.marshalNInt2int(ctx, sel, v[i])
	}

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalOInt2int(ctx context.Context, v interface{}) (*int, error) {
	if v == nil {
		return nil, nil
	}
	res, err := graphql.UnmarshalInt(v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOInt2int(ctx context.Context, sel ast.SelectionSet, v *int) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	res := graphql.MarshalInt(*v)
	return res
}

func (ec *executionContext) unmarshalOMerchantWhereInput2wallitentMerchantWhereInput(ctx context.Context, v interface{}) ([]*ent.MerchantWhereInput, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]*ent.MerchantWhereInput, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNMerchantWhereInput2wallitentMerchantWhereInput(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) unmarshalOMerchantWhereInput2wallitentMerchantWhereInput(ctx context.Context, v interface{}) (*ent.MerchantWhereInput, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputMerchantWhereInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalONode2wallitentNoder(ctx context.Context, sel ast.SelectionSet, v ent.Noder) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._Node(ctx, sel, v)
}

func (ec *executionContext) marshalONotification2wallitentNotification(ctx context.Context, sel ast.SelectionSet, v []*ent.Notification) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNNotification2wallitentNotification(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalONotification2wallitentNotification(ctx context.Context, sel ast.SelectionSet, v *ent.Notification) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._Notification(ctx, sel, v)
}

func (ec *executionContext) marshalONotificationEdge2wallitentNotificationEdge(ctx context.Context, sel ast.SelectionSet, v []*ent.NotificationEdge) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalONotificationEdge2wallitentNotificationEdge(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	return ret
}

func (ec *executionContext) marshalONotificationEdge2wallitentNotificationEdge(ctx context.Context, sel ast.SelectionSet, v *ent.NotificationEdge) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._NotificationEdge(ctx, sel, v)
}

func (ec *executionContext) unmarshalONotificationOrder2wallitentNotificationOrder(ctx context.Context, v interface{}) (*ent.NotificationOrder, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputNotificationOrder(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalONotificationType2wallitentnotificationType(ctx context.Context, v interface{}) ([]notification.Type, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]notification.Type, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNNotificationType2wallitentnotificationType(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalONotificationType2wallitentnotificationType(ctx context.Context, sel ast.SelectionSet, v []notification.Type) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNNotificationType2wallitentnotificationType(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalONotificationType2wallitentnotificationType(ctx context.Context, v interface{}) (*notification.Type, error) {
	if v == nil {
		return nil, nil
	}
	var res = new(notification.Type)
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalONotificationType2wallitentnotificationType(ctx context.Context, sel ast.SelectionSet, v *notification.Type) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return v
}

func (ec *executionContext) unmarshalONotificationWhereInput2wallitentNotificationWhereInput(ctx context.Context, v interface{}) ([]*ent.NotificationWhereInput, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]*ent.NotificationWhereInput, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNNotificationWhereInput2wallitentNotificationWhereInput(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) unmarshalONotificationWhereInput2wallitentNotificationWhereInput(ctx context.Context, v interface{}) (*ent.NotificationWhereInput, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputNotificationWhereInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOPlaidInstitution2wallitentPlaidInstitution(ctx context.Context, sel ast.SelectionSet, v *ent.PlaidInstitution) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._PlaidInstitution(ctx, sel, v)
}

func (ec *executionContext) marshalOPlaidInstitutionAccount2wallitentPlaidInstitutionAccount(ctx context.Context, sel ast.SelectionSet, v []*ent.PlaidInstitutionAccount) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNPlaidInstitutionAccount2wallitentPlaidInstitutionAccount(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalOPlaidInstitutionAccount2wallitentPlaidInstitutionAccount(ctx context.Context, sel ast.SelectionSet, v *ent.PlaidInstitutionAccount) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._PlaidInstitutionAccount(ctx, sel, v)
}

func (ec *executionContext) marshalOPlaidInstitutionAccountConnection2wallitentPlaidInstitutionAccountConnection(ctx context.Context, sel ast.SelectionSet, v *ent.PlaidInstitutionAccountConnection) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._PlaidInstitutionAccountConnection(ctx, sel, v)
}

func (ec *executionContext) marshalOPlaidInstitutionAccountEdge2wallitentPlaidInstitutionAccountEdge(ctx context.Context, sel ast.SelectionSet, v []*ent.PlaidInstitutionAccountEdge) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalOPlaidInstitutionAccountEdge2wallitentPlaidInstitutionAccountEdge(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	return ret
}

func (ec *executionContext) marshalOPlaidInstitutionAccountEdge2wallitentPlaidInstitutionAccountEdge(ctx context.Context, sel ast.SelectionSet, v *ent.PlaidInstitutionAccountEdge) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._PlaidInstitutionAccountEdge(ctx, sel, v)
}

func (ec *executionContext) unmarshalOPlaidInstitutionAccountWhereInput2wallitentPlaidInstitutionAccountWhereInput(ctx context.Context, v interface{}) ([]*ent.PlaidInstitutionAccountWhereInput, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]*ent.PlaidInstitutionAccountWhereInput, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNPlaidInstitutionAccountWhereInput2wallitentPlaidInstitutionAccountWhereInput(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) unmarshalOPlaidInstitutionAccountWhereInput2wallitentPlaidInstitutionAccountWhereInput(ctx context.Context, v interface{}) (*ent.PlaidInstitutionAccountWhereInput, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputPlaidInstitutionAccountWhereInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOPlaidInstitutionConnection2wallitentPlaidInstitutionConnection(ctx context.Context, sel ast.SelectionSet, v *ent.PlaidInstitutionConnection) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._PlaidInstitutionConnection(ctx, sel, v)
}

func (ec *executionContext) marshalOPlaidInstitutionEdge2wallitentPlaidInstitutionEdge(ctx context.Context, sel ast.SelectionSet, v []*ent.PlaidInstitutionEdge) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalOPlaidInstitutionEdge2wallitentPlaidInstitutionEdge(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	return ret
}

func (ec *executionContext) marshalOPlaidInstitutionEdge2wallitentPlaidInstitutionEdge(ctx context.Context, sel ast.SelectionSet, v *ent.PlaidInstitutionEdge) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._PlaidInstitutionEdge(ctx, sel, v)
}

func (ec *executionContext) unmarshalOPlaidInstitutionWhereInput2wallitentPlaidInstitutionWhereInput(ctx context.Context, v interface{}) ([]*ent.PlaidInstitutionWhereInput, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]*ent.PlaidInstitutionWhereInput, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNPlaidInstitutionWhereInput2wallitentPlaidInstitutionWhereInput(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) unmarshalOPlaidInstitutionWhereInput2wallitentPlaidInstitutionWhereInput(ctx context.Context, v interface{}) (*ent.PlaidInstitutionWhereInput, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputPlaidInstitutionWhereInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOPlaidItem2wallitentPlaidItem(ctx context.Context, sel ast.SelectionSet, v []*ent.PlaidItem) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNPlaidItem2wallitentPlaidItem(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalOPlaidItem2wallitentPlaidItem(ctx context.Context, sel ast.SelectionSet, v *ent.PlaidItem) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._PlaidItem(ctx, sel, v)
}

func (ec *executionContext) marshalOPlaidItemEdge2wallitentPlaidItemEdge(ctx context.Context, sel ast.SelectionSet, v []*ent.PlaidItemEdge) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalOPlaidItemEdge2wallitentPlaidItemEdge(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	return ret
}

func (ec *executionContext) marshalOPlaidItemEdge2wallitentPlaidItemEdge(ctx context.Context, sel ast.SelectionSet, v *ent.PlaidItemEdge) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._PlaidItemEdge(ctx, sel, v)
}

func (ec *executionContext) unmarshalOPlaidItemWhereInput2wallitentPlaidItemWhereInput(ctx context.Context, v interface{}) ([]*ent.PlaidItemWhereInput, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]*ent.PlaidItemWhereInput, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNPlaidItemWhereInput2wallitentPlaidItemWhereInput(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) unmarshalOPlaidItemWhereInput2wallitentPlaidItemWhereInput(ctx context.Context, v interface{}) (*ent.PlaidItemWhereInput, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputPlaidItemWhereInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOSpendingCategory2wallitentSpendingCategory(ctx context.Context, sel ast.SelectionSet, v []*ent.SpendingCategory) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNSpendingCategory2wallitentSpendingCategory(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalOSpendingCategory2wallitentSpendingCategory(ctx context.Context, sel ast.SelectionSet, v *ent.SpendingCategory) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._SpendingCategory(ctx, sel, v)
}

func (ec *executionContext) marshalOSpendingCategoryEdge2wallitentSpendingCategoryEdge(ctx context.Context, sel ast.SelectionSet, v []*ent.SpendingCategoryEdge) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalOSpendingCategoryEdge2wallitentSpendingCategoryEdge(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	return ret
}

func (ec *executionContext) marshalOSpendingCategoryEdge2wallitentSpendingCategoryEdge(ctx context.Context, sel ast.SelectionSet, v *ent.SpendingCategoryEdge) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._SpendingCategoryEdge(ctx, sel, v)
}

func (ec *executionContext) unmarshalOSpendingCategoryWhereInput2wallitentSpendingCategoryWhereInput(ctx context.Context, v interface{}) ([]*ent.SpendingCategoryWhereInput, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]*ent.SpendingCategoryWhereInput, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNSpendingCategoryWhereInput2wallitentSpendingCategoryWhereInput(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) unmarshalOSpendingCategoryWhereInput2wallitentSpendingCategoryWhereInput(ctx context.Context, v interface{}) (*ent.SpendingCategoryWhereInput, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputSpendingCategoryWhereInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalOString2string(ctx context.Context, v interface{}) (string, error) {
	res, err := graphql.UnmarshalString(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOString2string(ctx context.Context, sel ast.SelectionSet, v string) graphql.Marshaler {
	res := graphql.MarshalString(v)
	return res
}

func (ec *executionContext) unmarshalOString2string(ctx context.Context, v interface{}) ([]string, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]string, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNString2string(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalOString2string(ctx context.Context, sel ast.SelectionSet, v []string) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	for i := range v {
		ret[i] = ec.marshalNString2string(ctx, sel, v[i])
	}

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalOString2string(ctx context.Context, v interface{}) (*string, error) {
	if v == nil {
		return nil, nil
	}
	res, err := graphql.UnmarshalString(v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOString2string(ctx context.Context, sel ast.SelectionSet, v *string) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	res := graphql.MarshalString(*v)
	return res
}

func (ec *executionContext) unmarshalOTime2timeTime(ctx context.Context, v interface{}) (time.Time, error) {
	res, err := graphql.UnmarshalTime(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOTime2timeTime(ctx context.Context, sel ast.SelectionSet, v time.Time) graphql.Marshaler {
	res := graphql.MarshalTime(v)
	return res
}

func (ec *executionContext) unmarshalOTime2timeTime(ctx context.Context, v interface{}) ([]time.Time, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]time.Time, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNTime2timeTime(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalOTime2timeTime(ctx context.Context, sel ast.SelectionSet, v []time.Time) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	for i := range v {
		ret[i] = ec.marshalNTime2timeTime(ctx, sel, v[i])
	}

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalOTime2timeTime(ctx context.Context, v interface{}) (*time.Time, error) {
	if v == nil {
		return nil, nil
	}
	res, err := graphql.UnmarshalTime(v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOTime2timeTime(ctx context.Context, sel ast.SelectionSet, v *time.Time) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	res := graphql.MarshalTime(*v)
	return res
}

func (ec *executionContext) marshalOTransaction2wallitentTransaction(ctx context.Context, sel ast.SelectionSet, v []*ent.Transaction) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNTransaction2wallitentTransaction(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalOTransaction2wallitentTransaction(ctx context.Context, sel ast.SelectionSet, v *ent.Transaction) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._Transaction(ctx, sel, v)
}

func (ec *executionContext) marshalOTransactionEdge2wallitentTransactionEdge(ctx context.Context, sel ast.SelectionSet, v []*ent.TransactionEdge) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalOTransactionEdge2wallitentTransactionEdge(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	return ret
}

func (ec *executionContext) marshalOTransactionEdge2wallitentTransactionEdge(ctx context.Context, sel ast.SelectionSet, v *ent.TransactionEdge) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._TransactionEdge(ctx, sel, v)
}

func (ec *executionContext) unmarshalOTransactionOrder2wallitentTransactionOrder(ctx context.Context, v interface{}) (*ent.TransactionOrder, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputTransactionOrder(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOTransactionSync2wallitentTransactionSync(ctx context.Context, sel ast.SelectionSet, v []*ent.TransactionSync) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNTransactionSync2wallitentTransactionSync(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalOTransactionSyncWhereInput2wallitentTransactionSyncWhereInput(ctx context.Context, v interface{}) ([]*ent.TransactionSyncWhereInput, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]*ent.TransactionSyncWhereInput, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNTransactionSyncWhereInput2wallitentTransactionSyncWhereInput(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) unmarshalOTransactionSyncWhereInput2wallitentTransactionSyncWhereInput(ctx context.Context, v interface{}) (*ent.TransactionSyncWhereInput, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputTransactionSyncWhereInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalOTransactionWhereInput2wallitentTransactionWhereInput(ctx context.Context, v interface{}) ([]*ent.TransactionWhereInput, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]*ent.TransactionWhereInput, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNTransactionWhereInput2wallitentTransactionWhereInput(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) unmarshalOTransactionWhereInput2wallitentTransactionWhereInput(ctx context.Context, v interface{}) (*ent.TransactionWhereInput, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputTransactionWhereInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalOUpdateUserInput2wallitentUpdateUserInput(ctx context.Context, v interface{}) (*ent.UpdateUserInput, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputUpdateUserInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOUser2wallitentUser(ctx context.Context, sel ast.SelectionSet, v []*ent.User) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNUser2wallitentUser(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalOUser2wallitentUser(ctx context.Context, sel ast.SelectionSet, v *ent.User) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._User(ctx, sel, v)
}

func (ec *executionContext) marshalOUserNotificationChannelPreferences2wallitentUserNotificationChannelPreferences(ctx context.Context, sel ast.SelectionSet, v []*ent.UserNotificationChannelPreferences) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNUserNotificationChannelPreferences2wallitentUserNotificationChannelPreferences(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalOUserNotificationChannelPreferences2wallitentUserNotificationChannelPreferences(ctx context.Context, sel ast.SelectionSet, v *ent.UserNotificationChannelPreferences) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._UserNotificationChannelPreferences(ctx, sel, v)
}

func (ec *executionContext) unmarshalOUserNotificationChannelPreferencesChanel2wallitentusernotificationchannelpreferencesChanel(ctx context.Context, v interface{}) ([]usernotificationchannelpreferences.Chanel, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]usernotificationchannelpreferences.Chanel, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNUserNotificationChannelPreferencesChanel2wallitentusernotificationchannelpreferencesChanel(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalOUserNotificationChannelPreferencesChanel2wallitentusernotificationchannelpreferencesChanel(ctx context.Context, sel ast.SelectionSet, v []usernotificationchannelpreferences.Chanel) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNUserNotificationChannelPreferencesChanel2wallitentusernotificationchannelpreferencesChanel(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalOUserNotificationChannelPreferencesChanel2wallitentusernotificationchannelpreferencesChanel(ctx context.Context, v interface{}) (*usernotificationchannelpreferences.Chanel, error) {
	if v == nil {
		return nil, nil
	}
	var res = new(usernotificationchannelpreferences.Chanel)
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOUserNotificationChannelPreferencesChanel2wallitentusernotificationchannelpreferencesChanel(ctx context.Context, sel ast.SelectionSet, v *usernotificationchannelpreferences.Chanel) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return v
}

func (ec *executionContext) marshalOUserNotificationChannelPreferencesEdge2wallitentUserNotificationChannelPreferencesEdge(ctx context.Context, sel ast.SelectionSet, v []*ent.UserNotificationChannelPreferencesEdge) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalOUserNotificationChannelPreferencesEdge2wallitentUserNotificationChannelPreferencesEdge(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	return ret
}

func (ec *executionContext) marshalOUserNotificationChannelPreferencesEdge2wallitentUserNotificationChannelPreferencesEdge(ctx context.Context, sel ast.SelectionSet, v *ent.UserNotificationChannelPreferencesEdge) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._UserNotificationChannelPreferencesEdge(ctx, sel, v)
}

func (ec *executionContext) unmarshalOUserNotificationChannelPreferencesWhereInput2wallitentUserNotificationChannelPreferencesWhereInput(ctx context.Context, v interface{}) ([]*ent.UserNotificationChannelPreferencesWhereInput, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]*ent.UserNotificationChannelPreferencesWhereInput, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNUserNotificationChannelPreferencesWhereInput2wallitentUserNotificationChannelPreferencesWhereInput(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) unmarshalOUserNotificationChannelPreferencesWhereInput2wallitentUserNotificationChannelPreferencesWhereInput(ctx context.Context, v interface{}) (*ent.UserNotificationChannelPreferencesWhereInput, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputUserNotificationChannelPreferencesWhereInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalOUserOfferFrequency2wallitentuserOfferFrequency(ctx context.Context, v interface{}) ([]user.OfferFrequency, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]user.OfferFrequency, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNUserOfferFrequency2wallitentuserOfferFrequency(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalOUserOfferFrequency2wallitentuserOfferFrequency(ctx context.Context, sel ast.SelectionSet, v []user.OfferFrequency) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNUserOfferFrequency2wallitentuserOfferFrequency(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalOUserOfferFrequency2wallitentuserOfferFrequency(ctx context.Context, v interface{}) (*user.OfferFrequency, error) {
	if v == nil {
		return nil, nil
	}
	var res = new(user.OfferFrequency)
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOUserOfferFrequency2wallitentuserOfferFrequency(ctx context.Context, sel ast.SelectionSet, v *user.OfferFrequency) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return v
}

func (ec *executionContext) unmarshalOUserWhereInput2wallitentUserWhereInput(ctx context.Context, v interface{}) ([]*ent.UserWhereInput, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]*ent.UserWhereInput, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNUserWhereInput2wallitentUserWhereInput(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) unmarshalOUserWhereInput2wallitentUserWhereInput(ctx context.Context, v interface{}) (*ent.UserWhereInput, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputUserWhereInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalO__EnumValue2githubcom99designsgqlgengraphqlintrospectionEnumValue(ctx context.Context, sel ast.SelectionSet, v []introspection.EnumValue) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__EnumValue2githubcom99designsgqlgengraphqlintrospectionEnumValue(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalO__Field2githubcom99designsgqlgengraphqlintrospectionField(ctx context.Context, sel ast.SelectionSet, v []introspection.Field) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__Field2githubcom99designsgqlgengraphqlintrospectionField(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalO__InputValue2githubcom99designsgqlgengraphqlintrospectionInputValue(ctx context.Context, sel ast.SelectionSet, v []introspection.InputValue) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__InputValue2githubcom99designsgqlgengraphqlintrospectionInputValue(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalO__Schema2githubcom99designsgqlgengraphqlintrospectionSchema(ctx context.Context, sel ast.SelectionSet, v *introspection.Schema) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec.___Schema(ctx, sel, v)
}

func (ec *executionContext) marshalO__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx context.Context, sel ast.SelectionSet, v []introspection.Type) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalO__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx context.Context, sel ast.SelectionSet, v *introspection.Type) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec.___Type(ctx, sel, v)
}

// endregion ***************************** type.gotpl *****************************
